<html data-bs-theme="dark">

<head>
    <!-- ChartJs import -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.4/dist/chart.umd.min.js"></script>

    <!-- ChartJs Datalabel plugin -->
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.0.0"></script>

    <!-- ChartJs timeline plugin (helps create time axis) -->
    <script
        src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>

    <!-- DataTables and Bootstrap imports -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/5.3.0/css/bootstrap.min.css"
        rel="stylesheet" />
    <link href="https://cdn.datatables.net/v/bs5/jq-3.7.0/dt-2.1.8/datatables.min.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/5.3.0/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdn.datatables.net/v/bs5/jq-3.7.0/dt-2.1.8/datatables.min.js"></script>

    <!-- Favicon -->
    <link rel="icon" type="image/x-icon"
        href="data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKcAAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAAqAAAAAAAAAAAAAAAAAAAALIAAAD/AAAA4AAAANwAAADcAAAA3AAAANwAAADcAAAA3AAAANwAAADcAAAA4AAAAP8AAACxAAAAAAAAAKYAAAD/AAAAuwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC/AAAA/wAAAKkAAAD6AAAAzAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAN8AAAD/AAAA+gAAAMMAAAAAAAAAAgAAAGsAAABrAAAAawAAAGsAAABrAAAAawAAAGsAAABrAAAADAAAAAAAAADaAAAA/wAAAPoAAADDAAAAAAAAAIsAAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAANEAAAAAAAAA2gAAAP8AAAD6AAAAwwAAAAAAAAAAAAAAMgAAADIAAAAyAAAAMgAAADIAAAAyAAAAMgAAADIAAAAFAAAAAAAAANoAAAD/AAAA+gAAAMMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADaAAAA/wAAAPoAAADDAAAAAAAAADwAAAB8AAAAAAAAAGAAAABcAAAAAAAAAH8AAABKAAAAAAAAAAAAAAAAAAAA2gAAAP8AAAD6AAAAwwAAAAAAAADCAAAA/wAAACkAAADqAAAA4QAAAAAAAAD7AAAA/wAAALAAAAAGAAAAAAAAANoAAAD/AAAA+gAAAMMAAAAAAAAAIwAAAP4AAAD/AAAA/wAAAGAAAAAAAAAAAAAAAMkAAAD/AAAAigAAAAAAAADaAAAA/wAAAPoAAADDAAAAAAAAAAAAAAAIAAAAcAAAABkAAAAAAAAAAAAAAAAAAAAAAAAAEgAAAAAAAAAAAAAA2gAAAP8AAAD7AAAAywAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAN4AAAD/AAAAqwAAAP8AAACvAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALIAAAD/AAAAsgAAAAAAAAC5AAAA/wAAAMoAAADAAAAAwAAAAMAAAADAAAAAwAAAAMAAAADAAAAAwAAAAMkAAAD/AAAAvAAAAAAAAAAAAAAAAAAAAKwAAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAArQAAAAAAAAAAwAMAAIABAAAf+AAAP/wAAD/8AAAgBAAAP/wAAD/8AAA//AAAJIwAADHEAAA//AAAP/wAAB/4AACAAQAAwAMAAA==" />

    <style>
        :root {
            color-scheme: dark;
            font-family: Helvetica, sans-serif;
        }

        @media (prefers-color-scheme: light) {
            body {
                background-color: #eee;
            }
        }

        @media (prefers-color-scheme: dark) {
            body {
                background-color: #1c2227;
                color: #e2e1d7;
            }
        }

        .canvas {
            width: 800px;
            height: 540;
            text-align: center;
        }

        .keywordTable_wrapper .keywordTable_info {
            left: 300px;
            position: relative;
        }

        .card{
            margin-bottom: 10px;
        }
    </style>
</head>

<body>
    <div class="container-fluid mt-4">
        <div class="card">
            <div class="card-body">
                <!-- Title row -->
                <div class="row">
                    <div class="col-8">
                        <h1>Robot Framework Dashboard {{ date }}</h1>
                    </div>
                    <div class="col-1 d-flex">
                        <p class="mt-auto" id="runCount"></p>
                    </div>
                    <div class="col-1 d-flex">
                        <p class="mt-auto" id="suiteCount"></p>
                    </div>
                    <div class="col-1 d-flex">
                        <p class="mt-auto" id="testCount"></p>
                    </div>
                    <div class="col-1 d-flex">
                        <p class="mt-auto" id="keywordCount"></p>
                    </div>
                </div>

                <!-- Filter row -->
                <div class="row">
                    <div class="col-auto">
                        <label class="form-label form-label-sm" for="runs">Runs</label>
                        <select class="form-select form-select-sm" id="runs"></select>
                    </div>
                    <div class="col-auto">
                        <label class="form-label form-label-sm" for="tag">Tags</label>
                        <select class="form-select form-select-sm" id="tag"></select>
                    </div>
                    <div class="col-auto">
                        <label class="form-label form-label-sm" for="fromDate">From Date</label>
                        <input class="form-control form-control-sm" id="fromDate" type="date" />
                    </div>
                    <div class="col-auto">
                        <label class="form-label form-label-sm" for="fromTime">From Time</label>
                        <input class="form-control form-control-sm" id="fromTime" type="time" />
                    </div>
                    <div class="col-auto">
                        <label class="form-label form-label-sm" for="toDate">To Date</label>
                        <input class="form-control form-control-sm" id="toDate" type="date" />
                    </div>
                    <div class="col-auto">
                        <label class="form-label form-label-sm" for="toTime">To Time</label>
                        <input class="form-control form-control-sm" id="toTime" type="time" />
                    </div>
                    <div class="col-auto d-flex">
                        <button class="btn btn-outline-primary btn-sm mt-auto" id="resetFilters">Reset Filters</button>
                    </div>
                </div>
            </div>
        </div>

        <div class="card">
            <div class="card-body">
                <!-- Run title row -->
                <div class="row">
                    <div class="col-5">
                        <h2 id="runTitle">Run Statistics</h2>
                    </div>
                </div>

                <!-- Run row  -->
                <div class="row">
                    <div class="col canvas mb-5">
                        <canvas id="runStatisticsGraph"></canvas>
                        <button class="btn btn-outline-primary btn-sm mt-3"
                            id="updateRunStatisticsGraphBarPercentages">Percentages</button>
                        <button class="btn btn-outline-primary btn-sm mt-3"
                            id="updateRunStatisticsGraphBarAmount">Amount</button>
                        <button class="btn btn-outline-primary btn-sm mt-3"
                            id="updateRunStatisticsGraphLine">Timeline</button>
                    </div>
                    <div class="col canvas mb-5">
                        <canvas id="runDurationGraph"></canvas>
                        <button class="btn btn-outline-primary btn-sm mt-3" id="updateRunDurationGraphBar">Bar
                            View</button>
                        <button class="btn btn-outline-primary btn-sm mt-3" id="updateRunDurationGraphLine">Line
                            View</button>
                    </div>
                </div>
            </div>
        </div>

        <div class="card">
            <div class="card-body">
                <!-- Suite title and filters row -->
                <div class="row">
                    <div class="col-5">
                        <h2>Suite Statistics</h2>
                    </div>
                    <div class="col-auto">
                        <label class="form-label form-label-sm" for="suiteSelectSuites">Select Suite</label>
                        <select class="form-select form-select-sm" id="suiteSelectSuites"></select>
                    </div>
                </div>

                <!-- Suite row -->
                <div class="row">
                    <div class="col canvas mb-5">
                        <canvas id="suiteStatisticsGraph"></canvas>
                        <button class="btn btn-outline-primary btn-sm mt-3"
                            id="updateSuiteStatisticsGraphBarPercentages">Percentages</button>
                        <button class="btn btn-outline-primary btn-sm mt-3"
                            id="updateSuiteStatisticsGraphBarAmount">Amount</button>
                        <button class="btn btn-outline-primary btn-sm mt-3"
                            id="updateSuiteStatisticsGraphLine">Timeline</button>
                    </div>
                    <div class="col canvas mb-5">
                        <canvas id="suiteDurationGraph"></canvas>
                        <button class="btn btn-outline-primary btn-sm mt-3" id="updateSuiteDurationGraphBar">Bar
                            View</button>
                        <button class="btn btn-outline-primary btn-sm mt-3" id="updateSuiteDurationGraphLine">Line
                            View</button>
                    </div>
                </div>
            </div>
        </div>

        <div class="card">
            <div class="card-body">
                <!-- Test title and filters row -->
                <div class="row">
                    <div class="col-4">
                        <h2>Test Statistics</h2>
                    </div>
                    <div class="col-auto d-flex">
                        <div class="form-check form-switch mt-4">
                            <input class="form-check-input" type="checkbox" role="switch"
                                id="showOnlySelectedTestStatistic">
                            <label class="form-check-label" for="showOnlySelectedTestStatistic">Show Only Selected Test
                                Statistics</label>
                        </div>
                    </div>
                    <div class="col-auto">
                        <label class="form-label form-label-sm" for="suiteSelectTests">Select Suite</label>
                        <select class="form-select form-select-sm" id="suiteSelectTests"></select>
                    </div>
                    <div class="col-auto">
                        <label class="form-label form-label-sm" for="suiteSelectTests">Select Test</label>
                        <select class="form-select form-select-sm" id="testSelect"></select>
                    </div>
                </div>

                <!-- Test row -->
                <div class="row">
                    <div class="col canvas mb-5">
                        <canvas id="testStatusGraph"></canvas>
                    </div>
                    <div class="col canvas mb-5">
                        <canvas id="testDurationGraph"></canvas>
                        <button class="btn btn-outline-primary btn-sm mt-3" id="updateTestDurationGraphBar">Bar
                            View</button>
                        <button class="btn btn-outline-primary btn-sm mt-3" id="updateTestDurationGraphLine">Line
                            View</button>
                    </div>
                </div>
            </div>
        </div>

        <div class="card">
            <div class="card-body">
                <!-- Keyword title row -->
                <div class="row">
                    <div class="col-5">
                        <h2>Keyword Statistics</h2>
                    </div>
                </div>

                <!-- Keyword row -->
                <div class="row">
                    <div class="col canvas">
                        <table class="table table-striped" id="keywordTable"></table>
                    </div>
                </div>
                <div class="row">
                    <!-- Empty div is used for aligning -->
                    <div class="col-5"></div>
                    <div class="col-auto">
                        <label class="form-label form-label-sm" for="keywordSelect">Select Keyword</label>
                        <select class="form-select form-select-sm" id="keywordSelect"></select>
                    </div>
                </div>
                <div class="row">
                    <div class="col canvas mb-5">
                        <canvas id="keywordStatisticsGraph"></canvas>
                        <button class="btn btn-outline-primary btn-sm mt-3"
                            id="updateKeywordStatisticsGraphBarPercentages">Percentages</button>
                        <button class="btn btn-outline-primary btn-sm mt-3"
                            id="updateKeywordStatisticsGraphBarAmount">Amount</button>
                        <button class="btn btn-outline-primary btn-sm mt-3"
                            id="updateKeywordStatisticsGraphLine">Timeline</button>
                    </div>
                    <div class="col canvas mb-5">
                        <canvas id="keywordTimesRunGraph"></canvas>
                        <button class="btn btn-outline-primary btn-sm mt-3" id="updateKeywordTimesRunGraphBar">Bar
                            View</button>
                        <button class="btn btn-outline-primary btn-sm mt-3" id="updateKeywordTimesRunGraphLine">Line
                            View</button>
                    </div>
                </div>
                <div class="row">
                    <div class="col canvas mb-5">
                        <canvas id="keywordTotalTimeGraph"></canvas>
                        <button class="btn btn-outline-primary btn-sm mt-3" id="updateKeywordTotalTimeGraphBar">Bar
                            View</button>
                        <button class="btn btn-outline-primary btn-sm mt-3" id="updateKeywordTotalTimeGraphLine">Line
                            View</button>
                    </div>
                    <div class="col canvas mb-5">
                        <canvas id="keywordAverageTimeGraph"></canvas>
                        <button class="btn btn-outline-primary btn-sm mt-3" id="updateKeywordAverageTimeGraphBar">Bar
                            View</button>
                        <button class="btn btn-outline-primary btn-sm mt-3" id="updateKeywordAverageTimeGraphLine">Line
                            View</button>
                    </div>
                </div>
                <div class="row">
                    <div class="col canvas mb-5">
                        <canvas id="keywordMinTimeGraph"></canvas>
                        <button class="btn btn-outline-primary btn-sm mt-3" id="updateKeywordMinTimeGraphBar">Bar
                            View</button>
                        <button class="btn btn-outline-primary btn-sm mt-3" id="updateKeywordMinTimeGraphLine">Line
                            View</button>
                    </div>
                    <div class="col canvas mb-5">
                        <canvas id="keywordMaxTimeGraph"></canvas>
                        <button class="btn btn-outline-primary btn-sm mt-3" id="updateKeywordMaxTimeGraphBar">Bar
                            View</button>
                        <button class="btn btn-outline-primary btn-sm mt-3" id="updateKeywordMaxTimeGraphLine">Line
                            View</button>
                    </div>
                </div>
            </div>
        </div>
        <script>
            // theme
            if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
                Chart.defaults.color = '#e2e1d7';
                Chart.defaults.borderColor = 'rgba(255,255,255,0.1)';
                Chart.defaults.backgroundColor = 'rgba(255,255,0,0.1)';
                Chart.defaults.elements.line.borderColor = 'rgba(255,255,0,0.4)';
            }

            // colors
            var passedBackgroundColor = '#97bd61'
            var passedBorderColor = '#97bd61'
            var skippedBackgroundColor = '#fed84f'
            var skippedBorderColor = '#fed84f'
            var failedBackgroundColor = '#ce3e01'
            var failedBorderColor = '#ce3e01'
            var greyBackgroundColor = '#1c2227'
            var greyBorderColor = '#1c2227'

            // prepare input data
            var runs = {{ runs }}.sort((a, b) => new Date(a.run_start).getTime() - new Date(b.run_start).getTime());
            var suites = {{ suites }}.sort((a, b) => new Date(a.run_start).getTime() - new Date(b.run_start).getTime());
            var tests = {{ tests }}.sort((a, b) => new Date(a.run_start).getTime() - new Date(b.run_start).getTime());
            var keywords = {{ keywords }}.sort((a, b) => new Date(a.run_start).getTime() - new Date(b.run_start).getTime());

            // set default values
            document.getElementById('runCount').innerText = 'Runs ' + runs.length
            document.getElementById('testCount').innerText = 'Tests ' + tests.length
            document.getElementById('suiteCount').innerText = 'Suites ' + suites.length
            document.getElementById('keywordCount').innerText = 'Keywords ' + keywords.length

            // set filters and selects
            set_lowest_highest_dates()
            add_runs_in_select()
            add_tags_in_select()
            // create graphs
            var runStatisticsGraph
            var runStatisticsGraphType = 'percentages'
            var runDurationGraph
            var runDurationGraphType = 'bar'
            var suiteStatisticsGraph
            var suiteStatisticsGraphType = 'percentages'
            var suiteDurationGraph
            var suiteDurationGraphType = 'line'
            var testStatusGraph
            var testDurationGraph
            var testDurationGraphType = 'line'
            var keywordTable
            var keywordStatisticsGraph
            var keywordStatisticsGraphType = 'percentages'
            var keywordTimesRunGraph
            var keywordTimesRunGraphType = 'bar'
            var keywordTotalTimeGraph
            var keywordTotalTimeGraphType = 'bar'
            var keywordAverageTimeGraph
            var keywordAverageTimeGraphType = 'bar'
            var keywordMinTimeGraph
            var keywordMinTimeGraphType = 'bar'
            var keywordMaxTimeGraph
            var keywordMaxTimeGraphType = 'bar'
            // filtered data vars
            var filteredRuns
            var filteredSuites
            var filteredTests
            var filteredKeywords
            // var to keep track of show only selected test stats
            var showOnlySelectedTestStatistic = false

            //initialize graphs
            update_data_and_all_graphs()

            // eventlisteners
            document.getElementById('runs').addEventListener('change', update_data_and_all_graphs)
            document.getElementById('tag').addEventListener('change', update_data_and_all_graphs)
            document.getElementById('fromDate').addEventListener('change', update_data_and_all_graphs)
            document.getElementById('fromTime').addEventListener('change', update_data_and_all_graphs)
            document.getElementById('toDate').addEventListener('change', update_data_and_all_graphs)
            document.getElementById('toTime').addEventListener('change', update_data_and_all_graphs)

            document.getElementById('updateRunStatisticsGraphBarPercentages').addEventListener('click', (e) => { update_run_statistics_graph('percentages') })
            document.getElementById('updateRunStatisticsGraphBarAmount').addEventListener('click', (e) => { update_run_statistics_graph('amount') })
            document.getElementById('updateRunStatisticsGraphLine').addEventListener('click', (e) => { update_run_statistics_graph('line') })

            document.getElementById('updateRunDurationGraphBar').addEventListener('click', (e) => { update_run_duration_graph('bar') })
            document.getElementById('updateRunDurationGraphLine').addEventListener('click', (e) => { update_run_duration_graph('line') })

            document.getElementById('updateSuiteStatisticsGraphBarPercentages').addEventListener('click', (e) => { update_suite_statistics_graph('percentages') })
            document.getElementById('updateSuiteStatisticsGraphBarAmount').addEventListener('click', (e) => { update_suite_statistics_graph('amount') })
            document.getElementById('updateSuiteStatisticsGraphLine').addEventListener('click', (e) => { update_suite_statistics_graph('line') })

            document.getElementById('updateSuiteDurationGraphBar').addEventListener('click', (e) => { update_suite_duration_graph('bar') })
            document.getElementById('updateSuiteDurationGraphLine').addEventListener('click', (e) => { update_suite_duration_graph('line') })

            document.getElementById('updateTestDurationGraphBar').addEventListener('click', (e) => { update_test_duration_graph('bar') })
            document.getElementById('updateTestDurationGraphLine').addEventListener('click', (e) => { update_test_duration_graph('line') })

            document.getElementById('updateKeywordStatisticsGraphBarPercentages').addEventListener('click', (e) => { update_keyword_statistics_graph('percentages') })
            document.getElementById('updateKeywordStatisticsGraphBarAmount').addEventListener('click', (e) => { update_keyword_statistics_graph('amount') })
            document.getElementById('updateKeywordStatisticsGraphLine').addEventListener('click', (e) => { update_keyword_statistics_graph('line') })

            document.getElementById('updateKeywordTimesRunGraphBar').addEventListener('click', (e) => { update_keyword_times_run_graph('bar') })
            document.getElementById('updateKeywordTimesRunGraphLine').addEventListener('click', (e) => { update_keyword_times_run_graph('line') })

            document.getElementById('updateKeywordTotalTimeGraphBar').addEventListener('click', (e) => { update_keyword_total_time_graph('bar') })
            document.getElementById('updateKeywordTotalTimeGraphLine').addEventListener('click', (e) => { update_keyword_total_time_graph('line') })

            document.getElementById('updateKeywordAverageTimeGraphBar').addEventListener('click', (e) => { update_keyword_average_time_graph('bar') })
            document.getElementById('updateKeywordAverageTimeGraphLine').addEventListener('click', (e) => { update_keyword_average_time_graph('line') })

            document.getElementById('updateKeywordMinTimeGraphBar').addEventListener('click', (e) => { update_keyword_min_time_graph('bar') })
            document.getElementById('updateKeywordMinTimeGraphLine').addEventListener('click', (e) => { update_keyword_min_time_graph('line') })

            document.getElementById('updateKeywordMaxTimeGraphBar').addEventListener('click', (e) => { update_keyword_max_time_graph('bar') })
            document.getElementById('updateKeywordMaxTimeGraphLine').addEventListener('click', (e) => { update_keyword_max_time_graph('line') })


            document.getElementById('resetFilters').addEventListener('click', reset_filters)
            document.getElementById('suiteSelectSuites').addEventListener('change', (e) => {
                update_suite_duration_graph()
                update_suite_statistics_graph()
            })
            document.getElementById('showOnlySelectedTestStatistic').addEventListener('change', (e) => {
                showOnlySelectedTestStatistic = !showOnlySelectedTestStatistic
                update_test_status_graph()
            })
            document.getElementById('suiteSelectTests').addEventListener('change', (e) => {
                update_test_status_graph()
                update_test_duration_graph()
                add_tests_in_select()
            })
            document.getElementById('testSelect').addEventListener('change', (e) => {
                if (showOnlySelectedTestStatistic) { update_test_status_graph() }
                update_test_duration_graph()
            })
            document.getElementById('keywordSelect').addEventListener('change', (e) => {
                update_keyword_statistics_graph()
                update_keyword_times_run_graph()
                update_keyword_total_time_graph()
                update_keyword_average_time_graph()
                update_keyword_min_time_graph()
                update_keyword_max_time_graph()
            })

            function set_lowest_highest_dates() {
                var dates = []
                for (run of runs) {
                    dates.push(new Date(run.run_start))
                }
                var lowest = new Date(Math.min.apply(null, dates));
                var highest = new Date(Math.max.apply(null, dates));
                var tzoffset = (new Date()).getTimezoneOffset() * 60000;
                lowest = new Date((new Date(lowest - tzoffset)).getTime() + -1 * 60000) // this is to account for seconds in the initial filter value
                highest = new Date((new Date(highest - tzoffset)).getTime() + 1 * 60000) // this is to account for seconds in the initial filter value
                document.getElementById('fromDate').value = lowest.toISOString().split('T')[0]
                document.getElementById('fromTime').value = (lowest.toISOString().split('T')[1]).substring(0, 5)
                document.getElementById('toDate').value = highest.toISOString().split('T')[0]
                document.getElementById('toTime').value = (highest.toISOString().split('T')[1]).substring(0, 5)
            }

            function update_data_and_all_graphs() {
                update_filtered_data()
                update_all_graphs()
            }

            function update_filtered_data() {
                // filter run data
                filteredRuns = filter_runs(runs)
                filteredRuns = filter_tags(filteredRuns)
                filteredRuns = filter_dates(filteredRuns)
                // filter suites and tests based on filtered runs
                filteredSuites = filter_suites(filteredRuns)
                filteredTests = filter_tests(filteredRuns)
                filteredKeywords = filter_keywords(filteredRuns)
                // update tests select based on filtered runs
                add_suites_in_selects()
                add_tests_in_select()
                add_keywords_in_select()
            }

            function update_all_graphs() {
                // set titles with amount of filtered runs
                document.getElementById('runTitle').innerText = `Run Statistics (${Object.keys(filteredRuns).length} runs)`

                // destroy and create new graphs
                update_run_statistics_graph()
                update_run_duration_graph()
                update_suite_statistics_graph()
                update_suite_duration_graph()
                update_test_status_graph()
                update_test_duration_graph()
                update_keyword_table()
                update_keyword_statistics_graph()
                update_keyword_times_run_graph()
                update_keyword_total_time_graph()
                update_keyword_average_time_graph()
                update_keyword_min_time_graph()
                update_keyword_max_time_graph()
            }

            function update_run_statistics_graph(type) {
                if (typeof (type) === 'string') {
                    runStatisticsGraphType = type
                }
                if (runStatisticsGraph) { runStatisticsGraph.destroy() }
                create_run_statistics_graph()
            }

            function update_run_duration_graph(type) {
                if (typeof (type) === 'string') {
                    runDurationGraphType = type
                }
                if (runDurationGraph) { runDurationGraph.destroy() }
                create_run_duration_graph()
            }

            function update_suite_statistics_graph(type) {
                if (typeof (type) === 'string') {
                    suiteStatisticsGraphType = type
                }
                if (suiteStatisticsGraph) { suiteStatisticsGraph.destroy() }
                create_suite_statistics_graph()
            }

            function update_suite_duration_graph(type) {
                if (typeof (type) === 'string') {
                    suiteDurationGraphType = type
                }
                if (suiteDurationGraph) { suiteDurationGraph.destroy() }
                create_suite_duration_graph()
            }

            function update_test_status_graph() {
                if (testStatusGraph) { testStatusGraph.destroy() }
                create_test_status_graph()
            }

            function update_test_duration_graph(type) {
                if (typeof (type) === 'string') {
                    testDurationGraphType = type
                }
                if (testDurationGraph) { testDurationGraph.destroy() }
                create_test_duration_graph()
            }

            function update_keyword_table() {
                if (keywordTable) { keywordTable.destroy() }
                create_keyword_table()
            }

            function update_keyword_statistics_graph(type) {
                if (typeof (type) === 'string') {
                    keywordStatisticsGraphType = type
                } if (keywordStatisticsGraph) { keywordStatisticsGraph.destroy() }
                create_keyword_statistics_graph()
            }

            function update_keyword_times_run_graph(type) {
                if (typeof (type) === 'string') {
                    keywordTimesRunGraphType = type
                } if (keywordTimesRunGraph) { keywordTimesRunGraph.destroy() }
                create_keyword_times_run_graph()
            }

            function update_keyword_total_time_graph(type) {
                if (typeof (type) === 'string') {
                    keywordTotalTimeGraphType = type
                } if (keywordTotalTimeGraph) { keywordTotalTimeGraph.destroy() }
                create_keyword_total_time_graph()
            }

            function update_keyword_average_time_graph(type) {
                if (typeof (type) === 'string') {
                    keywordAverageTimeGraphType = type
                } if (keywordAverageTimeGraph) { keywordAverageTimeGraph.destroy() }
                create_keyword_average_time_graph()
            }

            function update_keyword_min_time_graph(type) {
                if (typeof (type) === 'string') {
                    keywordMinTimeGraphType = type
                } if (keywordMinTimeGraph) { keywordMinTimeGraph.destroy() }
                create_keyword_min_time_graph()
            }

            function update_keyword_max_time_graph(type) {
                if (typeof (type) === 'string') {
                    keywordMaxTimeGraphType = type
                } if (keywordMaxTimeGraph) { keywordMaxTimeGraph.destroy() }
                create_keyword_max_time_graph()
            }

            function filter_runs(runs) {
                var run = document.getElementById('runs').value
                var filteredRuns = {}
                for (const [key, value] of Object.entries(runs)) {
                    if (run != 'All' && value.name != run) {
                        continue
                    } else {
                        filteredRuns[key] = value
                    }
                }
                return filteredRuns
            }

            function filter_tags(runs) {
                var tag = document.getElementById('tag').value
                var filteredRuns = {}
                for (const [key, value] of Object.entries(runs)) {
                    if (tag != 'All') {
                        var runTags = value.tags.split(',')
                        for (runTag of runTags) {
                            if (tag != runTag) {
                                continue
                            } else {
                                filteredRuns[key] = value
                            }
                        }
                    } else {
                        filteredRuns = runs
                    }
                }
                return filteredRuns
            }

            function filter_dates(runs) {
                var fromDate = document.getElementById('fromDate').value
                var fromTime = document.getElementById('fromTime').value
                var toDate = document.getElementById('toDate').value
                var toTime = document.getElementById('toTime').value

                var filteredRuns = {}
                if (fromDate && fromTime && toDate && toTime) {
                    var fromDateTime = new Date(`${fromDate} ${fromTime}:00`)
                    var toDateTime = new Date(`${toDate} ${toTime}:00`)
                    if (fromDateTime <= toDateTime) {
                        for (const [key, value] of Object.entries(runs)) {
                            var run_start = new Date(value.run_start)
                            if (run_start < fromDateTime || run_start > toDateTime) {
                                continue
                            } else {
                                filteredRuns[key] = value
                            }
                        }
                    } else {
                        // you end up here if fromDate > toDate
                        alert('Filter error: The selected from date + time is later than your selected to date + time. Date filter has not been applied!')
                        filteredRuns = runs
                    }
                } else {
                    // no dates or not all value are provided
                    filteredRuns = runs
                }
                return filteredRuns
            }

            function filter_suites() {
                var validRunStarts = []
                for (const [key, value] of Object.entries(filteredRuns)) {
                    validRunStarts.push(value.run_start)
                }
                var filteredSuites = []
                for (const [key, value] of Object.entries(suites)) {
                    if (validRunStarts.includes(value.run_start)) {
                        filteredSuites.push(value)
                    }
                }
                return filteredSuites
            }

            function filter_tests() {
                var validRunStarts = []
                for (const [key, value] of Object.entries(filteredRuns)) {
                    validRunStarts.push(value.run_start)
                }
                var filteredTests = []
                for (const [key, value] of Object.entries(tests)) {
                    if (validRunStarts.includes(value.run_start)) {
                        filteredTests.push(value)
                    }
                }
                return filteredTests
            }

            function filter_keywords() {
                var validRunStarts = []
                for (const [key, value] of Object.entries(filteredRuns)) {
                    validRunStarts.push(value.run_start)
                }
                var filteredKeywords = []
                for (const [key, value] of Object.entries(keywords)) {
                    if (validRunStarts.includes(value.run_start)) {
                        filteredKeywords.push(value)
                    }
                }
                return filteredKeywords
            }

            function reset_filters() {
                document.getElementById('runs').value = 'All'
                document.getElementById('tag').value = 'All'
                set_lowest_highest_dates(runs)
                update_data_and_all_graphs()
            }

            function add_runs_in_select() {
                var runOptions = []
                for (run of runs) {
                    if (!runOptions.includes(run.name)) {
                        runOptions.push(run.name)
                    }
                }
                var runsSelect = document.getElementById('runs');
                runsSelect.options[runsSelect.options.length] = new Option('All', 'All');
                for (runOption of runOptions) {
                    runsSelect.options[runsSelect.options.length] = new Option(runOption, runOption);
                }
            }

            function add_tags_in_select() {
                var tags = []
                for (run of runs) {
                    var runTags = run.tags.split(',')
                    for (tag of runTags) {
                        if (!tags.includes(tag) && tag != '') {
                            tags.push(tag)
                        }
                    }
                }
                var tagsSelect = document.getElementById('tag');
                tagsSelect.options[tagsSelect.options.length] = new Option('All', 'All');
                for (tag of tags) {
                    tagsSelect.options[tagsSelect.options.length] = new Option(tag, tag);
                }
            }

            function add_suites_in_selects() {
                document.getElementById('suiteSelectTests').innerHTML = ''
                document.getElementById('suiteSelectSuites').innerHTML = ''
                var suiteNames = []
                for (suite of filteredSuites) {
                    if (!suiteNames.includes(suite.name)) {
                        suiteNames.push(suite.name)
                    }
                }
                var suiteSelectTests = document.getElementById('suiteSelectTests')
                var suiteSelectSuites = document.getElementById('suiteSelectSuites')
                for (suiteName of suiteNames.sort()) {
                    suiteSelectTests.options[suiteSelectTests.options.length] = new Option(suiteName, suiteName)
                    suiteSelectSuites.options[suiteSelectSuites.options.length] = new Option(suiteName, suiteName)
                }
            }

            function add_tests_in_select() {
                document.getElementById('testSelect').innerHTML = ''
                suiteSelect = document.getElementById('suiteSelectTests').value
                var testNames = []
                for (test of filteredTests) {
                    if (test.full_name.split('.').at(-2) == suiteSelect && !testNames.includes(test.name)) {
                        testNames.push(test.name)
                    }
                }
                var testSelect = document.getElementById('testSelect')
                testSelect.options[testSelect.options.length] = new Option('All', 'All')
                for (testName of testNames) {
                    testSelect.options[testSelect.options.length] = new Option(testName, testName)
                }
            }

            function add_keywords_in_select() {
                document.getElementById('keywordSelect').innerHTML = ''
                var keywordNames = []
                for (keyword of filteredKeywords) {
                    if (!keywordNames.includes(keyword.name)) {
                        keywordNames.push(keyword.name)
                    }
                }
                var keywordSelect = document.getElementById('keywordSelect')
                for (keywordName of keywordNames.sort()) {
                    keywordSelect.options[keywordSelect.options.length] = new Option(keywordName, keywordName)
                }
            }

            function create_run_statistics_graph() {
                var [passed, failed, skipped, labels] = [[], [], [], []]
                for (const [key, value] of Object.entries(filteredRuns)) {
                    if (runStatisticsGraphType == 'percentages') {
                        passed.push(Math.round(value.passed / value.total * 100 * 100) / 100)
                        failed.push(Math.round(value.failed / value.total * 100 * 100) / 100)
                        skipped.push(Math.round(value.skipped / value.total * 100 * 100) / 100)
                        labels.push(value.run_start)
                    } else {
                        passed.push(value.passed)
                        failed.push(value.failed)
                        skipped.push(value.skipped)
                        labels.push(value.run_start)
                    }
                }

                // required for both bar charts
                if (runStatisticsGraphType != 'line') {
                    var runStatisticsData = {
                        labels: labels,
                        datasets: [
                            {
                                label: 'Failed',
                                data: failed,
                                backgroundColor: failedBackgroundColor,
                                stack: 'Stack 0',
                            },
                            {
                                label: 'Skipped',
                                data: skipped,
                                backgroundColor: skippedBackgroundColor,
                                stack: 'Stack 0',
                            },
                            {
                                label: 'Passed',
                                data: passed,
                                backgroundColor: passedBackgroundColor,
                                stack: 'Stack 0',
                            },
                        ]
                    };
                } else {
                    var runStatisticsData = {
                        labels: labels,
                        datasets: [
                            {
                                label: 'Failed',
                                data: failed,
                                backgroundColor: failedBackgroundColor,
                                borderColor: failedBackgroundColor,
                            },
                            {
                                label: 'Skipped',
                                data: skipped,
                                backgroundColor: skippedBackgroundColor,
                                borderColor: skippedBackgroundColor,
                            },
                            {
                                label: 'Passed',
                                data: passed,
                                backgroundColor: passedBackgroundColor,
                                borderColor: passedBackgroundColor,
                            },
                        ]
                    }
                }
                if (runStatisticsGraphType == 'line') {
                    var config = get_graph_config('line', runStatisticsData, 'Run Of Tests (Line)', 'Date', 'amount')
                    runStatisticsGraph = new Chart('runStatisticsGraph', config);
                } else if (runStatisticsGraphType == 'amount') {
                    Chart.register(ChartDataLabels);
                    var config = get_graph_config('bar', runStatisticsData, 'Run Statistics (Bar)', 'Run', 'Amount Of Tests')
                    runStatisticsGraph = new Chart('runStatisticsGraph', config)
                } else if (runStatisticsGraphType == 'percentages') {
                    Chart.register(ChartDataLabels);
                    var config = get_graph_config('bar', runStatisticsData, 'Run Statistics (Bar)', 'Run', 'Percentage')
                    runStatisticsGraph = new Chart('runStatisticsGraph', config)
                }
            }

            function create_run_duration_graph() {
                if (runDurationGraphType == 'bar') {
                    var [labels, data] = [[], { 0: [] }]
                    // prepare data for bar chart
                    for (const [key, value] of Object.entries(filteredRuns)) {
                        labels.push(value.run_start)
                        var dataLength = data[0].length
                        if (data[value.name]) {
                            // add 0 to all not matching, and value.elapsed to matching
                            data[value.name].push(Math.round(value.elapsed_s * 100) / 100)
                        } else {
                            // add longest amount of 0's to matched and 1 zero to not matching
                            data[value.name] = []
                            for (let step = 0; step < dataLength; step++) {
                                data[value.name].push(0)
                            }
                            data[value.name].push(Math.round(value.elapsed_s * 100) / 100)
                        }
                        // add 0 to every other value
                        for (d in data) {
                            if (d != value.name) {
                                data[d].push(0)
                            }
                        }
                    }
                    delete data[0]
                    var runDurationData = {
                        labels: labels,
                        datasets: [],
                    }
                    for (key in data) {
                        runDurationData['datasets'].push({
                            label: key,
                            data: data[key],
                            stack: 'Stack 0'
                        })

                    }
                    var config = get_graph_config('bar', runDurationData, 'Run Duration (Bar)', 'Run', 'Duration')
                    runDurationGraph = new Chart('runDurationGraph', config)
                } else if (runDurationGraphType == 'line') {
                    var [labels, datasets, sets] = [[], [], {}]
                    for (const [key, value] of Object.entries(filteredRuns)) {
                        var full_name = value.full_name
                        var run_start = new Date(value.run_start)
                        var elapsed_s = Math.round(value.elapsed_s * 100) / 100
                        if (labels.includes(full_name)) {
                            var values = sets[full_name]
                            values.push({ x: run_start, y: elapsed_s })
                            sets[full_name] = values
                        } else {
                            labels.push(full_name)
                            sets[full_name] = [{ x: run_start, y: elapsed_s }]
                        }
                    }
                    for (const [key, value] of Object.entries(sets)) {
                        datasets.push({ label: key, fill: false, data: value })
                    }
                    var config = get_graph_config('line', { datasets: datasets }, 'Run Duration (Line)', 'Date', 'Duration')
                    runDurationGraph = new Chart('runDurationGraph', config);
                }
            }

            function create_suite_statistics_graph() {
                var suiteSelectSuites = document.getElementById('suiteSelectSuites').value
                var [passed, failed, skipped, labels] = [[], [], [], []]
                for (const [key, value] of Object.entries(filteredSuites)) {
                    if (value.name == suiteSelectSuites) {
                        if (suiteStatisticsGraphType == 'percentages') {
                            passed.push(Math.round(value.passed / value.total * 100 * 100) / 100)
                            failed.push(Math.round(value.failed / value.total * 100 * 100) / 100)
                            skipped.push(Math.round(value.skipped / value.total * 100 * 100) / 100)
                            labels.push(value.run_start)
                        } else {
                            passed.push(value.passed)
                            failed.push(value.failed)
                            skipped.push(value.skipped)
                            labels.push(value.run_start)
                        }
                    }
                }

                // required for both bar charts
                if (suiteStatisticsGraphType != 'line') {
                    var suiteStatisticsData = {
                        labels: labels,
                        datasets: [
                            {
                                label: 'Failed',
                                data: failed,
                                backgroundColor: failedBackgroundColor,
                                stack: 'Stack 0',
                            },
                            {
                                label: 'Skipped',
                                data: skipped,
                                backgroundColor: skippedBackgroundColor,
                                stack: 'Stack 0',
                            },
                            {
                                label: 'Passed',
                                data: passed,
                                backgroundColor: passedBackgroundColor,
                                stack: 'Stack 0',
                            },
                        ]
                    };
                } else {
                    var suiteStatisticsData = {
                        labels: labels,
                        datasets: [
                            {
                                label: 'Failed',
                                data: failed,
                                backgroundColor: failedBackgroundColor,
                                borderColor: failedBackgroundColor,
                            },
                            {
                                label: 'Skipped',
                                data: skipped,
                                backgroundColor: skippedBackgroundColor,
                                borderColor: skippedBackgroundColor,
                            },
                            {
                                label: 'Passed',
                                data: passed,
                                backgroundColor: passedBackgroundColor,
                                borderColor: passedBackgroundColor,
                            },
                        ]
                    };
                }
                if (suiteStatisticsGraphType == 'line') {
                    var config = get_graph_config('line', suiteStatisticsData, 'Amount Of Tests (Line)', 'Date', 'amount')
                    suiteStatisticsGraph = new Chart('suiteStatisticsGraph', config);
                } else if (suiteStatisticsGraphType == 'amount') {
                    Chart.register(ChartDataLabels);
                    var config = get_graph_config('bar', suiteStatisticsData, 'Suite Statistics (Bar)', 'Run', 'Amount Of Tests')
                    suiteStatisticsGraph = new Chart('suiteStatisticsGraph', config)
                } else if (suiteStatisticsGraphType == 'percentages') {
                    Chart.register(ChartDataLabels);
                    var config = get_graph_config('bar', suiteStatisticsData, 'Suite Statistics (Bar)', 'Run', 'Percentage')
                    suiteStatisticsGraph = new Chart('suiteStatisticsGraph', config)
                }
            }

            function create_suite_duration_graph() {
                var suiteSelectSuites = document.getElementById('suiteSelectSuites').value
                if (suiteDurationGraphType == 'bar') {
                    var [labels, data] = [[], { 0: [] }]
                    // prepare data for bar chart
                    for (const [key, value] of Object.entries(filteredSuites)) {
                        if (value.name != suiteSelectSuites) {
                            continue
                        }
                        labels.push(value.run_start)
                        var dataLength = data[0].length
                        if (data[value.name]) {
                            // add 0 to all not matching, and value.elapsed to matching
                            data[value.name].push(Math.round(value.elapsed_s * 100) / 100)
                        } else {
                            // add longest amount of 0's to matched and 1 zero to not matching
                            data[value.name] = []
                            for (let step = 0; step < dataLength; step++) {
                                data[value.name].push(0)
                            }
                            data[value.name].push(Math.round(value.elapsed_s * 100) / 100)
                        }
                        // add 0 to every other value
                        for (d in data) {
                            if (d != value.name) {
                                data[d].push(0)
                            }
                        }
                    }
                    delete data[0]
                    var suiteDurationData = {
                        labels: labels,
                        datasets: [],
                    }
                    for (key in data) {
                        suiteDurationData['datasets'].push({
                            label: key,
                            data: data[key],
                            stack: 'Stack 0'
                        })
                    }
                    var config = get_graph_config('bar', suiteDurationData, 'Suite Duration (Bar)', 'Run', 'Duration')
                    suiteDurationGraph = new Chart('suiteDurationGraph', config)
                } else if (suiteDurationGraphType == 'line') {
                    var [labels, datasets, sets] = [[], [], {}]
                    for (const [key, value] of Object.entries(filteredSuites)) {
                        if (value.name != suiteSelectSuites) {
                            continue
                        }
                        var name = value.name
                        var run_start = new Date(value.run_start)
                        var elapsed_s = Math.round(value.elapsed_s * 100) / 100
                        if (labels.includes(name)) {
                            var values = sets[name]
                            values.push({ x: run_start, y: elapsed_s })
                            sets[name] = values
                        } else {
                            labels.push(name)
                            sets[name] = [{ x: run_start, y: elapsed_s }]
                        }
                    }
                    for (const [key, value] of Object.entries(sets)) {
                        datasets.push({ label: key, fill: false, data: value })
                    }
                    var config = get_graph_config('line', { datasets: datasets }, 'Suite Duration (Line)', 'Date', 'Duration')
                    suiteDurationGraph = new Chart('suiteDurationGraph', config);
                }
            }

            function create_test_status_graph() {
                var suiteSelectTests = document.getElementById('suiteSelectTests').value
                var testSelect = document.getElementById('testSelect').value
                var labels = []
                var runStarts = []
                for (const [key, value] of Object.entries(filteredTests)) {
                    if (value.full_name.split('.').at(-2) != suiteSelectTests) {
                        continue
                    }
                    if (showOnlySelectedTestStatistic && testSelect != 'All' && value.name != testSelect) {
                        continue
                    }
                    if (!labels.includes(value.name)) {
                        labels.push(value.name)
                    }
                    if (!runStarts.includes(value.run_start)) {
                        runStarts.push(value.run_start)
                    }
                }

                var datasets = []
                var runAxis = 0
                for (runStart of runStarts) {
                    for (label of labels) {
                        var foundTests = filteredTests.filter(obj => {
                            // filter only tests in this suite, suite select check is required for duplicate test names over suites
                            return (obj.name == label && obj.run_start == runStart && obj.full_name.split('.').at(-2) == suiteSelectTests)
                        })
                        if (foundTests.length > 0) {
                            var value = foundTests[0]
                            if (value.passed == 1) {
                                datasets.push({
                                    label: label,
                                    data: [{ x: [runAxis, runAxis + 1], y: label }],
                                    backgroundColor: [passedBackgroundColor],
                                    borderWidth: 1
                                })
                            } else if (value.failed == 1) {
                                datasets.push({
                                    label: label,
                                    data: [{ x: [runAxis, runAxis + 1], y: label }],
                                    backgroundColor: [failedBackgroundColor],
                                    borderWidth: 1
                                })
                            } else if (value.skipped == 1) {
                                datasets.push({
                                    label: label,
                                    data: [{ x: [runAxis, runAxis + 1], y: label }],
                                    backgroundColor: [skippedBackgroundColor],
                                    borderWidth: 1
                                })
                            }
                        } else {
                            datasets.push({
                                label: label,
                                data: [{ x: [runAxis, runAxis + 1], y: label }],
                                backgroundColor: [greyBackgroundColor],
                                borderWidth: 1
                            })
                        }
                    }
                    runAxis += 1
                }
                testStatusGraph = new Chart('testStatusGraph', {
                    type: 'bar',
                    data: {
                        labels: labels,
                        datasets: datasets,
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        indexAxis: 'y',
                        scales: {
                            y: {
                                stacked: true,
                            },
                            x: {
                                ticks: {
                                    minRotation: 20,
                                    callback: function (value, index, ticks) {
                                        return runStarts[this.getLabelForValue(value)]
                                    }
                                }
                            }
                        },
                        plugins: {
                            title: {
                                text: 'Test Status (Bar)',
                                display: true
                            },
                            legend: {
                                display: false,
                            },
                            datalabels: {
                                display: false,
                            },
                            tooltip: {
                                callbacks: {
                                    label: function (context) {
                                        return runStarts[context.raw.x[0]];
                                    }
                                }
                            },
                        }
                    }
                });
            }

            function create_test_duration_graph() {
                var suiteSelectTests = document.getElementById('suiteSelectTests').value
                var testSelect = document.getElementById('testSelect').value
                if (testDurationGraphType == 'bar') {
                    var [labels, data] = [[], { 0: [] }]
                    // prepare data for bar chart
                    for (const [key, value] of Object.entries(filteredTests)) {
                        if (value.full_name.split('.').at(-2) != suiteSelectTests) {
                            continue
                        }
                        if (testSelect != 'All' && value.name != testSelect) {
                            continue
                        }
                        labels.push(value.run_start)
                        var dataLength = data[0].length
                        if (data[value.name]) {
                            // add 0 to all not matching, and value.elapsed to matching
                            data[value.name].push(Math.round(value.elapsed_s * 100) / 100)
                        } else {
                            // add longest amount of 0's to matched and 1 zero to not matching
                            data[value.name] = []
                            for (let step = 0; step < dataLength; step++) {
                                data[value.name].push(0)
                            }
                            data[value.name].push(Math.round(value.elapsed_s * 100) / 100)
                        }
                        // add 0 to every other value
                        for (d in data) {
                            if (d != value.name) {
                                data[d].push(0)
                            }
                        }
                    }
                    delete data[0]
                    var testDurationData = {
                        labels: labels,
                        datasets: [],
                    }
                    for (key in data) {
                        testDurationData['datasets'].push({
                            label: key,
                            data: data[key],
                            stack: 'Stack 0'
                        })

                    }
                    var config = get_graph_config('bar', testDurationData, 'Test Duration (Bar)', 'Run', 'Duration')
                    testDurationGraph = new Chart('testDurationGraph', config)
                } else if (testDurationGraphType == 'line') {
                    var [labels, datasets, sets] = [[], [], {}]
                    for (const [key, value] of Object.entries(filteredTests)) {
                        if (value.full_name.split('.').at(-2) != suiteSelectTests) {
                            continue
                        }
                        if (testSelect != 'All' && value.name != testSelect) {
                            continue
                        }
                        var name = value.name
                        var run_start = new Date(value.run_start)
                        var elapsed_s = Math.round(value.elapsed_s * 100) / 100
                        if (labels.includes(name)) {
                            var values = sets[name]
                            values.push({ x: run_start, y: elapsed_s })
                            sets[name] = values
                        } else {
                            labels.push(name)
                            sets[name] = [{ x: run_start, y: elapsed_s }]
                        }
                    }
                    for (const [key, value] of Object.entries(sets)) {
                        datasets.push({ label: key, fill: false, data: value })
                    }

                    var config = get_graph_config('line', { datasets: datasets }, 'Test Duration (Line)', 'Date', 'Duration')
                    testDurationGraph = new Chart('testDurationGraph', config);
                }
            }

            function create_keyword_table() {
                data = []
                for (keyword of filteredKeywords) {
                    data.push([
                        keyword.run_start,
                        keyword.name,
                        keyword.passed,
                        keyword.failed,
                        keyword.skipped,
                        keyword.times_run,
                        keyword.total_time_s,
                        keyword.average_time_s,
                        keyword.min_time_s,
                        keyword.max_time_s,
                    ])
                }
                keywordTable = new DataTable('#keywordTable', {
                    layout: {
                        topStart: 'info',
                        bottomStart: null,
                    },
                    columns: [
                        { title: 'run' },
                        { title: 'name' },
                        { title: 'passed' },
                        { title: 'failed' },
                        { title: 'skipped' },
                        { title: 'times_run' },
                        { title: 'total_execution_time' },
                        { title: 'average_execution_time' },
                        { title: 'min_execution_time' },
                        { title: 'max_execution_time' },
                    ],
                    data: data
                });
            }

            function create_keyword_statistics_graph() {
                var keywordSelect = document.getElementById('keywordSelect').value
                var [passed, failed, skipped, labels] = [[], [], [], []]
                for (const [key, value] of Object.entries(filteredKeywords)) {
                    if (value.name == keywordSelect) {
                        if (keywordStatisticsGraphType == 'percentages') {
                            passed.push(Math.round(value.passed / (value.passed + value.failed + value.skipped) * 100 * 100) / 100)
                            failed.push(Math.round(value.failed / (value.passed + value.failed + value.skipped) * 100 * 100) / 100)
                            skipped.push(Math.round(value.skipped / (value.passed + value.failed + value.skipped) * 100 * 100) / 100)
                            labels.push(value.run_start)
                        }
                        else {
                            passed.push(value.passed)
                            failed.push(value.failed)
                            skipped.push(value.skipped)
                            labels.push(value.run_start)
                        }
                    }
                }

                // required for both bar charts
                if (keywordStatisticsGraphType != 'line') {
                    var keywordStatisticsData = {
                        labels: labels,
                        datasets: [
                            {
                                label: 'Failed',
                                data: failed,
                                backgroundColor: failedBackgroundColor,
                                stack: 'Stack 0',
                            },
                            {
                                label: 'Skipped',
                                data: skipped,
                                backgroundColor: skippedBackgroundColor,
                                stack: 'Stack 0',
                            },
                            {
                                label: 'Passed',
                                data: passed,
                                backgroundColor: passedBackgroundColor,
                                stack: 'Stack 0',
                            },
                        ]
                    };
                } else {
                    var keywordStatisticsData = {
                        labels: labels,
                        datasets: [
                            {
                                label: 'Failed',
                                data: failed,
                                backgroundColor: failedBackgroundColor,
                                borderColor: failedBackgroundColor,
                            },
                            {
                                label: 'Skipped',
                                data: skipped,
                                backgroundColor: skippedBackgroundColor,
                                borderColor: skippedBackgroundColor,
                            },
                            {
                                label: 'Passed',
                                data: passed,
                                backgroundColor: passedBackgroundColor,
                                borderColor: passedBackgroundColor,
                            },
                        ]
                    };
                }
                if (keywordStatisticsGraphType == 'line') {
                    var config = get_graph_config('line', keywordStatisticsData, 'Keyword Statistics (Line)', 'Date', 'Amount')
                    keywordStatisticsGraph = new Chart('keywordStatisticsGraph', config);
                } else if (keywordStatisticsGraphType == 'amount') {
                    Chart.register(ChartDataLabels);
                    var config = get_graph_config('bar', keywordStatisticsData, 'Keyword Statistics (Bar)', 'Run', 'Amount')
                    keywordStatisticsGraph = new Chart('keywordStatisticsGraph', config)
                } else if (keywordStatisticsGraphType == 'percentages') {
                    Chart.register(ChartDataLabels);
                    var config = get_graph_config('bar', keywordStatisticsData, 'Keyword Statistics (Bar)', 'Run', 'Percentage')
                    keywordStatisticsGraph = new Chart('keywordStatisticsGraph', config);
                }
            }

            function create_keyword_times_run_graph() {
                var keywordSelect = document.getElementById('keywordSelect').value
                if (keywordTimesRunGraphType == 'bar') {
                    var [labels, data] = [[], { 0: [] }]
                    // prepare data for bar chart
                    for (const [key, value] of Object.entries(filteredKeywords)) {
                        if (value.name != keywordSelect) {
                            continue
                        }
                        labels.push(value.run_start)
                        var dataLength = data[0].length
                        if (data[value.name]) {
                            // add 0 to all not matching, and value.elapsed to matching
                            data[value.name].push(Math.round(value.times_run * 100) / 100)
                        } else {
                            // add longest amount of 0's to matched and 1 zero to not matching
                            data[value.name] = []
                            for (let step = 0; step < dataLength; step++) {
                                data[value.name].push(0)
                            }
                            data[value.name].push(Math.round(value.times_run * 100) / 100)
                        }
                        // add 0 to every other value
                        for (d in data) {
                            if (d != value.name) {
                                data[d].push(0)
                            }
                        }
                    }
                    delete data[0]
                    var keywordTimesRunData = {
                        labels: labels,
                        datasets: [],
                    }
                    for (key in data) {
                        keywordTimesRunData['datasets'].push({
                            label: key,
                            data: data[key],
                            stack: 'Stack 0'
                        })
                    }
                    var config = get_graph_config('bar', keywordTimesRunData, 'Times Run (Bar)', 'Run', 'Duration')
                    keywordTimesRunGraph = new Chart('keywordTimesRunGraph', config)
                } else if (keywordTimesRunGraphType == 'line') {
                    var [labels, datasets, sets] = [[], [], {}]
                    for (const [key, value] of Object.entries(filteredKeywords)) {
                        if (value.name != keywordSelect) {
                            continue
                        }
                        var name = value.name
                        var run_start = new Date(value.run_start)
                        var times_run = Math.round(value.times_run * 100) / 100
                        if (labels.includes(name)) {
                            var values = sets[name]
                            values.push({ x: run_start, y: times_run })
                            sets[name] = values
                        } else {
                            labels.push(name)
                            sets[name] = [{ x: run_start, y: times_run }]
                        }
                    }
                    for (const [key, value] of Object.entries(sets)) {
                        datasets.push({ label: key, fill: false, data: value })
                    }
                    var config = get_graph_config('line', { datasets: datasets }, 'Times Run (Line)', 'Date', 'Duration')
                    keywordTimesRunGraph = new Chart('keywordTimesRunGraph', config);
                }
            }

            function create_keyword_total_time_graph() {
                var keywordSelect = document.getElementById('keywordSelect').value
                if (keywordTotalTimeGraphType == 'bar') {
                    var [labels, data] = [[], { 0: [] }]
                    // prepare data for bar chart
                    for (const [key, value] of Object.entries(filteredKeywords)) {
                        if (value.name != keywordSelect) {
                            continue
                        }
                        labels.push(value.run_start)
                        var dataLength = data[0].length
                        if (data[value.name]) {
                            // add 0 to all not matching, and value.elapsed to matching
                            data[value.name].push(Math.round(value.total_time_s * 100) / 100)
                        } else {
                            // add longest amount of 0's to matched and 1 zero to not matching
                            data[value.name] = []
                            for (let step = 0; step < dataLength; step++) {
                                data[value.name].push(0)
                            }
                            data[value.name].push(Math.round(value.total_time_s * 100) / 100)
                        }
                        // add 0 to every other value
                        for (d in data) {
                            if (d != value.name) {
                                data[d].push(0)
                            }
                        }
                    }
                    delete data[0]
                    var keywordTotalTimeData = {
                        labels: labels,
                        datasets: [],
                    }
                    for (key in data) {
                        keywordTotalTimeData['datasets'].push({
                            label: key,
                            data: data[key],
                            stack: 'Stack 0'
                        })

                    }
                    var config = get_graph_config('bar', keywordTotalTimeData, 'Total Duration (Bar)', 'Run', 'Duration')
                    keywordTotalTimeGraph = new Chart('keywordTotalTimeGraph', config)
                } else if (keywordTotalTimeGraphType == 'line') {
                    var [labels, datasets, sets] = [[], [], {}]
                    for (const [key, value] of Object.entries(filteredKeywords)) {
                        if (value.name != keywordSelect) {
                            continue
                        }
                        var name = value.name
                        var run_start = new Date(value.run_start)
                        var total_time_s = Math.round(value.total_time_s * 100) / 100
                        if (labels.includes(name)) {
                            var values = sets[name]
                            values.push({ x: run_start, y: total_time_s })
                            sets[name] = values
                        } else {
                            labels.push(name)
                            sets[name] = [{ x: run_start, y: total_time_s }]
                        }
                    }
                    for (const [key, value] of Object.entries(sets)) {
                        datasets.push({ label: key, fill: false, data: value })
                    }
                    var config = get_graph_config('line', { datasets: datasets }, 'Total Duration (Line)', 'Date', 'Duration')
                    keywordTotalTimeGraph = new Chart('keywordTotalTimeGraph', config);
                }
            }

            function create_keyword_average_time_graph() {
                var keywordSelect = document.getElementById('keywordSelect').value
                if (keywordAverageTimeGraphType == 'bar') {
                    var [labels, data] = [[], { 0: [] }]
                    // prepare data for bar chart
                    for (const [key, value] of Object.entries(filteredKeywords)) {
                        if (value.name != keywordSelect) {
                            continue
                        }
                        labels.push(value.run_start)
                        var dataLength = data[0].length
                        if (data[value.name]) {
                            // add 0 to all not matching, and value.elapsed to matching
                            data[value.name].push(Math.round(value.average_time_s * 100) / 100)
                        } else {
                            // add longest amount of 0's to matched and 1 zero to not matching
                            data[value.name] = []
                            for (let step = 0; step < dataLength; step++) {
                                data[value.name].push(0)
                            }
                            data[value.name].push(Math.round(value.average_time_s * 100) / 100)
                        }
                        // add 0 to every other value
                        for (d in data) {
                            if (d != value.name) {
                                data[d].push(0)
                            }
                        }
                    }
                    delete data[0]
                    var keywordAverageTimeData = {
                        labels: labels,
                        datasets: [],
                    }
                    for (key in data) {
                        keywordAverageTimeData['datasets'].push({
                            label: key,
                            data: data[key],
                            stack: 'Stack 0'
                        })

                    }
                    var config = get_graph_config('bar', keywordAverageTimeData, 'Average Duration (Bar)', 'Run', 'Duration')
                    keywordAverageTimeGraph = new Chart('keywordAverageTimeGraph', config)
                } else if (keywordAverageTimeGraphType == 'line') {
                    var [labels, datasets, sets] = [[], [], {}]
                    for (const [key, value] of Object.entries(filteredKeywords)) {
                        if (value.name != keywordSelect) {
                            continue
                        }
                        var name = value.name
                        var run_start = new Date(value.run_start)
                        var average_time_s = Math.round(value.average_time_s * 100) / 100
                        if (labels.includes(name)) {
                            var values = sets[name]
                            values.push({ x: run_start, y: average_time_s })
                            sets[name] = values
                        } else {
                            labels.push(name)
                            sets[name] = [{ x: run_start, y: average_time_s }]
                        }
                    }
                    for (const [key, value] of Object.entries(sets)) {
                        datasets.push({ label: key, fill: false, data: value })
                    }
                    var config = get_graph_config('line', { datasets: datasets }, 'Average Duration (Line)', 'Date', 'Duration')
                    keywordAverageTimeGraph = new Chart('keywordAverageTimeGraph', config);
                }
            }

            function create_keyword_min_time_graph() {
                var keywordSelect = document.getElementById('keywordSelect').value
                if (keywordMinTimeGraphType == 'bar') {
                    var [labels, data] = [[], { 0: [] }]
                    // prepare data for bar chart
                    for (const [key, value] of Object.entries(filteredKeywords)) {
                        if (value.name != keywordSelect) {
                            continue
                        }
                        labels.push(value.run_start)
                        var dataLength = data[0].length
                        if (data[value.name]) {
                            // add 0 to all not matching, and value.elapsed to matching
                            data[value.name].push(Math.round(value.min_time_s * 100) / 100)
                        } else {
                            // add longest amount of 0's to matched and 1 zero to not matching
                            data[value.name] = []
                            for (let step = 0; step < dataLength; step++) {
                                data[value.name].push(0)
                            }
                            data[value.name].push(Math.round(value.min_time_s * 100) / 100)
                        }
                        // add 0 to every other value
                        for (d in data) {
                            if (d != value.name) {
                                data[d].push(0)
                            }
                        }
                    }
                    delete data[0]
                    var keywordMinTimeData = {
                        labels: labels,
                        datasets: [],
                    }
                    for (key in data) {
                        keywordMinTimeData['datasets'].push({
                            label: key,
                            data: data[key],
                            stack: 'Stack 0'
                        })

                    }
                    var config = get_graph_config('bar', keywordMinTimeData, 'Min Duration (Bar)', 'Run', 'Duration')
                    keywordMinTimeGraph = new Chart('keywordMinTimeGraph', config)
                } else if (keywordMinTimeGraphType == 'line') {
                    var [labels, datasets, sets] = [[], [], {}]
                    for (const [key, value] of Object.entries(filteredKeywords)) {
                        if (value.name != keywordSelect) {
                            continue
                        }
                        var name = value.name
                        var run_start = new Date(value.run_start)
                        var min_time_s = Math.round(value.min_time_s * 100) / 100
                        if (labels.includes(name)) {
                            var values = sets[name]
                            values.push({ x: run_start, y: min_time_s })
                            sets[name] = values
                        } else {
                            labels.push(name)
                            sets[name] = [{ x: run_start, y: min_time_s }]
                        }
                    }
                    for (const [key, value] of Object.entries(sets)) {
                        datasets.push({ label: key, fill: false, data: value })
                    }
                    var config = get_graph_config('line', { datasets: datasets }, 'Min Duration (Line)', 'Date', 'Duration')
                    keywordMinTimeGraph = new Chart('keywordMinTimeGraph', config);
                }
            }

            function create_keyword_max_time_graph() {
                var keywordSelect = document.getElementById('keywordSelect').value
                if (keywordMaxTimeGraphType == 'bar') {
                    var [labels, data] = [[], { 0: [] }]
                    // prepare data for bar chart
                    for (const [key, value] of Object.entries(filteredKeywords)) {
                        if (value.name != keywordSelect) {
                            continue
                        }
                        labels.push(value.run_start)
                        var dataLength = data[0].length
                        if (data[value.name]) {
                            // add 0 to all not matching, and value.elapsed to matching
                            data[value.name].push(Math.round(value.max_time_s * 100) / 100)
                        } else {
                            // add longest amount of 0's to matched and 1 zero to not matching
                            data[value.name] = []
                            for (let step = 0; step < dataLength; step++) {
                                data[value.name].push(0)
                            }
                            data[value.name].push(Math.round(value.max_time_s * 100) / 100)
                        }
                        // add 0 to every other value
                        for (d in data) {
                            if (d != value.name) {
                                data[d].push(0)
                            }
                        }
                    }
                    delete data[0]
                    var keywordMaxTimeData = {
                        labels: labels,
                        datasets: [],
                    }
                    for (key in data) {
                        keywordMaxTimeData['datasets'].push({
                            label: key,
                            data: data[key],
                            stack: 'Stack 0'
                        })

                    }
                    var config = get_graph_config('bar', keywordMaxTimeData, 'Max Duration (Bar)', 'Run', 'Duration')
                    keywordMaxTimeGraph = new Chart('keywordMaxTimeGraph', config)
                } else if (keywordMaxTimeGraphType == 'line') {
                    var [labels, datasets, sets] = [[], [], {}]
                    for (const [key, value] of Object.entries(filteredKeywords)) {
                        if (value.name != keywordSelect) {
                            continue
                        }
                        var name = value.name
                        var run_start = new Date(value.run_start)
                        var max_time_s = Math.round(value.max_time_s * 100) / 100
                        if (labels.includes(name)) {
                            var values = sets[name]
                            values.push({ x: run_start, y: max_time_s })
                            sets[name] = values
                        } else {
                            labels.push(name)
                            sets[name] = [{ x: run_start, y: max_time_s }]
                        }
                    }
                    for (const [key, value] of Object.entries(sets)) {
                        datasets.push({ label: key, fill: false, data: value })
                    }
                    var config = get_graph_config('line', { datasets: datasets }, 'Max Duration (Line)', 'Date', 'Duration')
                    keywordMaxTimeGraph = new Chart('keywordMaxTimeGraph', config);
                }
            }

            function get_graph_config(graphType, graphData, graphTitle, xTitle, yTitle) {
                if (graphType == 'line') {
                    return {
                        type: 'line',
                        data: graphData,
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                title: {
                                    text: graphTitle,
                                    display: true
                                },
                                datalabels: {
                                    display: false,
                                },
                                legend: {
                                    display: true,
                                }
                            },
                            scales: {
                                x: {
                                    type: 'time',
                                    time: {
                                        tooltipFormat: 'dd.MM.yyyy - HH:mm:ss.SSS'
                                    },
                                    title: {
                                        display: true,
                                        text: xTitle
                                    }
                                },
                                y: {
                                    beginAtZero: true,
                                    title: {
                                        display: true,
                                        text: yTitle
                                    },
                                    grace: '5%'
                                }
                            }
                        }
                    }
                } else if (graphType == 'bar') {
                    return {
                        type: 'bar',
                        data: graphData,
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                x: {
                                    title: {
                                        display: true,
                                        text: xTitle
                                    },
                                    ticks: {
                                        minRotation: 20
                                    }
                                },
                                y: {
                                    stacked: true,
                                    title: {
                                        display: true,
                                        text: yTitle
                                    },
                                    grace: '5%'
                                }
                            },
                            interaction: {
                                mode: 'x'
                            },
                            plugins: {
                                title: {
                                    display: true,
                                    text: graphTitle,
                                },
                                tooltip: {
                                    filter: tooltipItem => tooltipItem.dataset.data[tooltipItem.dataIndex] > 0
                                },
                                datalabels: {
                                    color: '#000000',
                                    align: 'center',
                                    anchor: 'center',
                                    formatter: function (value) {
                                        if (value > 0) {
                                            return value
                                        } else {
                                            value = '';
                                            return value;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        </script>
</body>

</html>