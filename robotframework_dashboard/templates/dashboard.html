<html data-bs-theme="dark" class="dark-mode w-100">

<head>
    <title>"placeholder_dashboard_title"</title>
    <!-- ChartJs import -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.4/dist/chart.umd.min.js"></script>

    <!-- ChartJs Datalabel plugin -->
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.0.0"></script>

    <!-- ChartJs timeline plugin (helps create time axis) -->
    <script
        src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>

    <!-- ChartJs boxplot plugin (for time deviation graph) -->
    <script type="text/javascript"
        src="https://unpkg.com/@sgratzl/chartjs-chart-boxplot@3.6.0/build/index.umd.min.js"></script>

    <!-- ChartJs heatmap/matrix plugin -->
    <script src="https://cdn.jsdelivr.net/npm/chartjs-chart-matrix@2.0.1/dist/chartjs-chart-matrix.min.js"></script>

    <!-- DataTables and Bootstrap imports -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/5.3.0/css/bootstrap.min.css"
        rel="stylesheet" />
    <link href="https://cdn.datatables.net/v/bs5/jq-3.7.0/dt-2.1.8/datatables.min.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/5.3.0/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdn.datatables.net/v/bs5/jq-3.7.0/dt-2.1.8/datatables.min.js"></script>

    <!-- Pako that is used to decompress the initial data -->
    <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>

    <!-- Favicon -->
    <link rel="icon" type="image/x-icon"
        href="data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKcAAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAAqAAAAAAAAAAAAAAAAAAAALIAAAD/AAAA4AAAANwAAADcAAAA3AAAANwAAADcAAAA3AAAANwAAADcAAAA4AAAAP8AAACxAAAAAAAAAKYAAAD/AAAAuwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC/AAAA/wAAAKkAAAD6AAAAzAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAN8AAAD/AAAA+gAAAMMAAAAAAAAAAgAAAGsAAABrAAAAawAAAGsAAABrAAAAawAAAGsAAABrAAAADAAAAAAAAADaAAAA/wAAAPoAAADDAAAAAAAAAIsAAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAANEAAAAAAAAA2gAAAP8AAAD6AAAAwwAAAAAAAAAAAAAAMgAAADIAAAAyAAAAMgAAADIAAAAyAAAAMgAAADIAAAAFAAAAAAAAANoAAAD/AAAA+gAAAMMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADaAAAA/wAAAPoAAADDAAAAAAAAADwAAAB8AAAAAAAAAGAAAABcAAAAAAAAAH8AAABKAAAAAAAAAAAAAAAAAAAA2gAAAP8AAAD6AAAAwwAAAAAAAADCAAAA/wAAACkAAADqAAAA4QAAAAAAAAD7AAAA/wAAALAAAAAGAAAAAAAAANoAAAD/AAAA+gAAAMMAAAAAAAAAIwAAAP4AAAD/AAAA/wAAAGAAAAAAAAAAAAAAAMkAAAD/AAAAigAAAAAAAADaAAAA/wAAAPoAAADDAAAAAAAAAAAAAAAIAAAAcAAAABkAAAAAAAAAAAAAAAAAAAAAAAAAEgAAAAAAAAAAAAAA2gAAAP8AAAD7AAAAywAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAN4AAAD/AAAAqwAAAP8AAACvAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALIAAAD/AAAAsgAAAAAAAAC5AAAA/wAAAMoAAADAAAAAwAAAAMAAAADAAAAAwAAAAMAAAADAAAAAwAAAAMkAAAD/AAAAvAAAAAAAAAAAAAAAAAAAAKwAAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAArQAAAAAAAAAAwAMAAIABAAAf+AAAP/wAAD/8AAAgBAAAP/wAAD/8AAA//AAAJIwAADHEAAA//AAAP/wAAB/4AACAAQAAwAMAAA==" />

    <style>
        /* LIGHT MODE STYLING */
        body {
            background-color: #eee;
        }

        .border-bottom {
            border-color: rgba(0, 0, 0, 0.175) !important;
        }

        .fullscreen,
        .sticky-top,
        body {
            background-color: #eee;
        }

        .form-switch .form-check-input:not(:checked) {
            background-image: url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='-4 -4 8 8'%3e%3ccircle r='3' fill='black'/></svg>");
            border-color: black;
        }

        .information[data-title]::after {
            background-color: white;
            color: black;
        }

        .stat-label {
            font-size: 1rem;
            color: darkgrey;
        }

        .white-text {
            color: black;
        }

        /* DARK MODE STYLING */
        .dark-mode :root {
            color-scheme: dark;
        }

        .dark-mode .canvas,
        .dark-mode .overview-card .card {
            background: rgba(30, 41, 59, 0.9);
        }

        .dark-mode .fullscreen {
            background: rgba(30, 41, 59, 1);
        }

        .dark-mode .modal-content {
            background: #0f172a;
        }

        .dark-mode .border-bottom {
            border-color: rgba(255, 255, 255, 0.15) !important;
        }

        .dark-mode .sticky-top,
        .dark-mode .card,
        .dark-mode body,
        .dark-mode .modal-dialog {
            background: #0f172a;
            color: #eee;
        }

        .dark-mode .list-group-item:not(.disabled),
        .dark-mode .form-label,
        .dark-mode .form-control,
        .dark-mode .form-select {
            color: #eee;
        }

        .dark-mode .list-group-item .disabled {
            color: rgba(173, 181, 189, 0.75);
        }

        .dark-mode .form-switch .form-check-input:not(:checked) {
            background-image: url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='-4 -4 8 8'%3e%3ccircle r='3' fill='white'/></svg>");
            border-color: #eee;
        }

        .dark-mode .table>:not(caption)>*>* {
            color: #eee;
        }

        .dark-mode .collapse-icon {
            color: #eee;
        }

        .dark-mode .information[data-title]::after {
            background-color: #0f172a;
            color: #eee;
        }

        .dark-mode .stat-label {
            font-size: 0.85rem;
            color: #9ca3af;
        }

        .dark-mode .white-text {
            color: #eee;
        }

        /* GENERAL STYLING */
        :root {
            font-family: Helvetica, sans-serif;
        }

        h4,
        h6 {
            margin-bottom: 0rem;
        }

        body.lock-scroll {
            overflow: hidden;
        }

        #settings,
        #database,
        .nav-item {
            cursor: pointer;
        }

        .rounded-start-sm {
            border-top-left-radius: 0.25rem !important;
            border-bottom-left-radius: 0.25rem !important;
        }

        .rounded-end-sm {
            border-top-right-radius: 0.25rem !important;
            border-bottom-right-radius: 0.25rem !important;
        }

        .information[data-title]:hover::after {
            opacity: 1;
            visibility: visible;
            transition: opacity 0.2s ease-in-out;
        }

        .information[data-title]::after {
            content: attr(data-title);
            white-space: pre-line;
            font-size: 0.95rem;
            position: absolute;
            padding: 8px 12px;
            border-radius: 8px;
            top: calc(100% + 8px);
            right: -70px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            opacity: 0;
            border: 1px solid #1e293b;
            z-index: 9999;
            visibility: hidden;
            max-width: min(90vw, 360px);
            width: max-content;
            overflow-wrap: break-word;
            text-align: left;
            box-sizing: border-box;
        }

        .information[data-title] {
            position: relative;
            cursor: pointer;
        }

        .canvas {
            min-width: 400px;
            width: 700px;
            height: 540px;
            text-align: center;
            padding: 1.5rem;
            border-radius: 16px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        .canvas:not(.fullscreen) .donut-charts {
            height: 450px;
        }

        .canvas.fullscreen .donut-charts {
            height: 100%;
        }

        .canvas:not(.fullscreen) {
            margin: 1rem;
        }

        .canvas-vertical,
        .canvas.fullscreen {
            overflow-y: auto;
        }

        canvas {
            padding-bottom: 1.5rem;
        }

        .canvas.fullscreen canvas,
        .canvas.fullscreen .donut-charts {
            height: calc(100% - 51px) !important;
        }

        .card {
            margin-top: 1rem;
            margin-bottom: 1rem;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        .dt-container {
            margin-top: 20px;
        }

        .stats {
            float: right;
            text-align: right;
            font-size: 0.9em;
            white-space: nowrap;
        }

        .fullscreen {
            position: fixed;
            width: 100%;
            height: 100%;
            left: 0;
            top: 0;
            z-index: 10;
            padding: 11px 20px 70px 20px;
            border-radius: 0px;
        }

        .selectBox {
            position: relative;
        }

        .selectBox select {
            width: 100%;
        }

        .overSelect {
            position: absolute;
            left: 0;
            right: 0;
            top: 0;
            bottom: 0;
        }

        #checkboxes {
            display: none;
            position: absolute;
            z-index: 2;
        }

        #checkboxes label {
            display: block;
        }

        .border,
        .controls {
            min-height: 165px;
        }

        .hideItemText {
            margin-right: auto;
        }

        .moveUp {
            margin: 5px 2px 0px 2px;
            padding: 2px 1px 2px 1px;
            height: 16px !important;
        }

        .moveDown {
            margin: 5px 2px 0px 2px;
            padding: 3px 1px 2px 1px;
            height: 16px !important;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: 600;
        }

        .fullscreen .stat-value {
            font-size: 4rem;
        }

        .fullscreen .stat-label {
            font-size: 2rem;
        }

        .green-text,
        .text-passed {
            color: rgba(151, 189, 97, 0.9);
        }

        .border-passed {
            border-color: rgba(151, 189, 97, 0.9);
        }

        .red-text,
        .text-failed {
            color: rgba(206, 62, 1, 0.9);
        }

        .border-failed {
            border-color: rgba(206, 62, 1, 0.9);
        }

        .yellow-text {
            color: rgba(254, 216, 79, 0.9);
        }

        .border-skipped {
            border-color: rgba(254, 216, 79, 0.9);
        }

        .blue-text {
            color: dodgerblue;
        }

        .overview-canvas {
            height: 200px;
        }

        .overview-card {
            cursor: pointer;
            min-width: 300px;
        }

        .overview-card .card {
            border-radius: 1rem
        }
    </style>
</head>

<body>
    <nav class="navbar navbar-expand-sm sticky-top navbar-dark ps-4 pe-4 border-bottom pb-1" id="navigation">
        <div class="navbar-nav ms-4">
            <a class="nav-link p-2" id="rflogo" href="https://robotframework.org/" target="_blank"
                title="Robot Framework"></a>
            <a class="nav-item nav-link" id="menuOverview">Overview</span></a>
            <a class="nav-item nav-link active" id="menuDashboard">Dashboard</a>
            <a class="nav-item nav-link" id="runStatisticsSectionNav"><i>Runs</i></a>
            <a class="nav-item nav-link" id="suiteStatisticsSectionNav"><i>Suites</i></a>
            <a class="nav-item nav-link" id="testStatisticsSectionNav"><i>Tests</i></a>
            <a class="nav-item nav-link" id="keywordStatisticsSectionNav"><i>Keywords</i></a>
            <a class="nav-item nav-link" id="menuCompare">Compare</a>
            <a class="nav-item nav-link" id="openDashboard" href="/" hidden>Admin</a>
        </div>
        <ul class="navbar-nav flex-row flex-wrap ms-md-auto me-4">
            <li class="nav-item">
                <a class="nav-link p-2" id="filters" data-bs-toggle="modal" data-bs-target="#filtersModal"
                    title="Filters"></a>
            </li>
            <li class="nav-item">
                <a class="nav-link p-2" id="customizeView" data-bs-toggle="modal" data-bs-target="#customizeModal"
                    title="Customize View"></a>
            </li>
            <li class="nav-item">
                <a class="nav-link p-2" id="settings" data-bs-toggle="modal" data-bs-target="#settingsModal"
                    title="Settings"></a>
            </li>
            <li class="nav-item">
                <a class="nav-link p-2" id="toggleTheme" title="Theme"></a>
            </li>
            <li class="nav-item">
                <a class="nav-link p-2" id="database" data-bs-toggle="modal" data-bs-target="#databaseModal"
                    title="Database Summary"></a>
            </li>
            <li class="nav-item">
                <a class="nav-link p-2 information" id="versionInformation" data-title='"placeholder_version"'></a>
            </li>
            <li class="nav-item">
                <a class="nav-link p-2" target="_blank" id="bug" title="Report a bug or feature request"
                    href="https://github.com/timdegroot1996/robotframework-dashboard/issues"></a>
            </li>
            <li class="nav-item">
                <a class="nav-link p-2" target="_blank" id="github" title="GitHub"
                    href="https://github.com/timdegroot1996/robotframework-dashboard"></a>
            </li>
        </ul>
    </nav>

    <div class="container-fluid">
        <div class="text-center mt-5" id="loading">
            <div class="spinner-border" style="width: 5rem; height: 5rem;" role="status">
                <span class="sr-only"></span>
            </div>
        </div>

        <div class="card" id="overviewStatisticsSection" hidden>
            <div class="card-header">
                <div class="row">
                    <div class="col-auto align-self-center">
                        <div class="btn btn-sm collapse-icon" id="overviewDetailsButton" data-bs-toggle="collapse"
                            data-bs-target="#overviewData" aria-expanded="true" aria-controls="overviewData"></div>
                    </div>
                    <div class="col-4">
                        <h4 id="overviewTitle"></h4>
                    </div>
                    <div class="col-auto">
                        <div class="btn-group ms-1">
                            <label class="form-check-label mt-2" for="useRunTags">Use Run Tags</label>
                        </div>
                        <div class="btn-group form-switch ms-1">
                            <input class="form-check-input mt-2" type="checkbox" role="switch" id="useRunTags" />
                        </div>
                    </div>
                    <div class="col-auto">
                        <div class="btn-group">
                            <label class="form-check-label" for="overviewDurationPercentage">Percentage</label>
                        </div>
                        <div class="btn-group">
                            <select class="form-select form-select-sm mt-1" id="overviewDurationPercentage">
                                <option value="10">10</option>
                                <option value="20" selected>20</option>
                                <option value="30">30</option>
                                <option value="40">40</option>
                                <option value="50">50</option>
                                <option value="60">60</option>
                                <option value="70">70</option>
                                <option value="80">80</option>
                                <option value="90">90</option>
                                <option value="100">100</option>
                            </select>
                        </div>
                    </div>
                    <div class="col-auto">
                        <button type="button" class="btn btn-outline-light btn-sm mb-3 mt-1 information"
                            id="overviewStatisticsInformation"
                            data-title="This section shows the projects and their associated runs:
- Duration color indicates performance relative to the average: green if more than x% faster, red if more than x% slower. You can adjust this threshold using the Percentage toggle.
- Passed runs represent the percentage of runs with zero failures.
- You can define your own projects or groupings by appending '-o path/to/output.xml:project_yourprojectname' when generating results.
- If runs don't include custom 'project_' tags, they will be grouped by their run name by default. You can change this behavior using the Use Run Tags toggle."></button>
                    </div>
                </div>
            </div>
            <!-- Placeholder DIV to keep the graphs, they will be moved based on the config to the card overviewData -->
            <div id="overviewDataHidden" hidden></div>
            <div class="card-body collapse show" id="overviewData"></div>
        </div>

        <div class="card" id="runStatisticsSection" hidden>
            <div class="card-header">
                <div class="row">
                    <div class="col-auto align-self-center">
                        <div class="btn btn-sm collapse-icon" id="runDetailsButton" data-bs-toggle="collapse"
                            data-bs-target="#runData" aria-expanded="true" aria-controls="runData"></div>
                    </div>
                    <div class="col">
                        <h4 id="runTitle"></h4>
                    </div>
                </div>
            </div>
            <!-- Placeholder DIV to keep the graphs, they will be moved based on the config to the card runData -->
            <div id="runDataHidden" hidden></div>
            <div class="card-body collapse show" id="runData"></div>
        </div>

        <div class="card" id="suiteStatisticsSection" hidden>
            <div class="card-header">
                <div class="row">
                    <div class="col-auto align-self-center">
                        <div class="btn btn-sm collapse-icon" id="suiteDetailsButton" data-bs-toggle="collapse"
                            data-bs-target="#suiteData" aria-expanded="true" aria-controls="suiteData"></div>
                    </div>
                    <div class="col-3">
                        <h4 id="suiteTitle"></h4>
                    </div>
                    <div class="col-auto">
                        <div class="btn-group">
                            <label class="form-label mt-2" for="suiteFolder">Folder: </label>
                        </div>
                        <div class="btn-group">
                            <p class="form-label mt-2" id="suiteFolder">All</p>
                        </div>
                    </div>
                    <div class="col-auto">
                        <div class="btn-group">
                            <button class="btn btn-outline-light btn-sm mt-1" id="resetSuiteFolder">Reset
                                Folder</button>
                        </div>
                    </div>
                    <div class="col-auto">
                        <div class="btn-group">
                            <label class="form-label mt-2" for="suiteSelectSuites">Suite</label>
                        </div>
                        <div class="btn-group">
                            <select class="form-select form-select-sm" id="suiteSelectSuites"></select>
                        </div>
                    </div>
                    <div class="col-auto">
                        <div class="btn-group ms-1">
                            <label class="form-check-label mt-2" for="useSuitePathsSuiteSection">Use Suite
                                Paths</label>
                        </div>
                        <div class="btn-group form-switch ms-1">
                            <input class="form-check-input mt-2" type="checkbox" role="switch"
                                id="useSuitePathsSuiteSection" />
                        </div>
                    </div>
                </div>
            </div>
            <!-- Placeholder DIV to keep the graphs, they will be moved based on the config to the card suiteData -->
            <div id="suiteDataHidden" hidden></div>
            <div class="card-body collapse show" id="suiteData"></div>
        </div>

        <div class="card" id="testStatisticsSection" hidden>
            <div class="card-header">
                <div class="row">
                    <div class="col-auto align-self-center">
                        <div class="btn btn-sm collapse-icon" id="testDetailsButton" data-bs-toggle="collapse"
                            data-bs-target="#testData" aria-expanded="true" aria-controls="testData"></div>
                    </div>
                    <div class="col-3">
                        <h4 id="testTitle"></h4>
                    </div>
                    <div class="col-auto">
                        <div class="btn-group">
                            <label class="form-label mt-2" for="suiteSelectTests">Suite</label>
                        </div>
                        <div class="btn-group">
                            <select class="form-select form-select-sm" id="suiteSelectTests"></select>
                        </div>
                    </div>
                    <div class="col-auto">
                        <div class="btn-group ms-1">
                            <label class="form-check-label mt-2" for="useSuitePathsTestSection">Use Suite
                                Paths</label>
                        </div>
                        <div class="btn-group form-switch ms-1">
                            <input class="form-check-input mt-2" type="checkbox" role="switch"
                                id="useSuitePathsTestSection" />
                        </div>
                    </div>
                    <div class="col-auto">
                        <div class="btn-group">
                            <label class="form-label mt-2" for="testSelect">Test</label>
                        </div>
                        <div class="btn-group">
                            <select class="form-select form-select-sm" id="testSelect"></select>
                        </div>
                    </div>
                    <div class="col-auto">
                        <div class="btn-group">
                            <label class="form-label mt-2" for="testTagsSelect">Test Tags</label>
                        </div>
                        <div class="btn-group">
                            <select class="form-select form-select-sm" id="testTagsSelect"></select>
                        </div>
                    </div>
                </div>
            </div>
            <!-- Placeholder DIV to keep the graphs, they will be moved based on the config to the card keywordData -->
            <div id="testDataHidden" hidden></div>
            <div class="card-body collapse show" id="testData"></div>
        </div>

        <div class="card" id="keywordStatisticsSection" hidden>
            <div class="card-header">
                <div class="row">
                    <div class="col-auto align-self-center">
                        <div class="btn btn-sm collapse-icon" id="keywordDetailsButton" data-bs-toggle="collapse"
                            data-bs-target="#keywordData" aria-expanded="true" aria-controls="keywordData"></div>
                    </div>
                    <div class="col-3">
                        <h4 id="keywordTitle"></h4>
                    </div>
                    <div class="col-auto">
                        <div class="btn-group">
                            <label class="form-label mt-2" for="keywordSelect">Keyword</label>
                        </div>
                        <div class="btn-group">
                            <select class="form-select form-select-sm" id="keywordSelect"></select>
                        </div>
                    </div>
                </div>
            </div>
            <!-- Placeholder DIV to keep the graphs, they will be moved based on the config to the card keywordData -->
            <div id="keywordDataHidden" hidden></div>
            <div class="card-body collapse show" id="keywordData"></div>
        </div>

        <div class="card" id="compareStatisticsSection" hidden>
            <div class="card-header">
                <div class="row">
                    <div class="col-auto align-self-center">
                        <div class="btn btn-sm collapse-icon" id="compareDetailsButton" data-bs-toggle="collapse"
                            data-bs-target="#compareData" aria-expanded="true" aria-controls="compareData"></div>
                    </div>
                    <div class="col-3">
                        <h4 id="compareTitle"></h4>
                    </div>
                    <div class="col-auto">
                        <div class="btn-group">
                            <label class="form-label mt-2" for="compareRun1">Run 1</label>
                        </div>
                        <div class="btn-group">
                            <select class="form-select form-select-sm" id="compareRun1"></select>
                        </div>
                    </div>
                    <div class="col-auto">
                        <div class="btn-group">
                            <label class="form-label mt-2" for="compareRun2">Run 2</label>
                        </div>
                        <div class="btn-group">
                            <select class="form-select form-select-sm" id="compareRun2"></select>
                        </div>
                    </div>
                    <div class="col-auto">
                        <div class="btn-group">
                            <label class="form-label mt-2" for="compareRun3">Run 3</label>
                        </div>
                        <div class="btn-group">
                            <select class="form-select form-select-sm" id="compareRun3"></select>
                        </div>
                    </div>
                    <div class="col-auto">
                        <div class="btn-group">
                            <label class="form-label mt-2" for="compareRun4">Run 4</label>
                        </div>
                        <div class="btn-group">
                            <select class="form-select form-select-sm" id="compareRun4"></select>
                        </div>
                    </div>
                </div>
            </div>
            <!-- Placeholder DIV to keep the graphs, they will be moved based on the config to the card compareData -->
            <div id="compareDataHidden" hidden></div>
            <div class="card-body collapse show" id="compareData"></div>
        </div>

        <!-- Modal for the filter -->
        <div class="modal fade" id="filtersModal" tabindex="-1" aria-labelledby="filtersModalLabel">
            <div class="modal-dialog modal-lg">
                <div class="modal-content">
                    <div class="modal-header">
                        <h1 class="modal-title" id="filtersModalLabel">Filters</h1>
                        <div>
                            <button type="button" class="btn btn-outline-light btn-sm mt-auto ms-3" id="resetFilters"
                                data-bs-dismiss="modal">Reset Filters</button>
                            <button type="button" class="btn btn-outline-light btn-sm mt-auto ms-3"
                                data-bs-dismiss="modal">Close</button>
                        </div>
                    </div>
                    <div class="modal-body">
                        <div class="col-auto mt-1 ps-2 pe-2">
                            <label class="form-label form-label-sm mb-0" for="runs" id="runsLabel">Runs</label>
                            <select class="form-select form-select-sm" id="runs"></select>
                        </div>
                        <div class="col-auto mt-1 ps-2 pe-2" id="runTagFilter">
                            <div class="selectBox" id="selectRunTags">
                                <label class="form-label form-label-sm mb-0" for="runTag" id="runTagLabel">Run
                                    Tags</label>
                                <select class="form-select form-select-sm">
                                    <option>Select Tags</option>
                                </select>
                                <div class="overSelect"></div>
                            </div>
                            <div id="checkboxes">
                                <ul class="list-group" id="runTag"></ul>
                            </div>
                        </div>
                        <div class="col-auto mt-1 ps-2 pe-2">
                            <label class="form-label form-label-sm mb-0" for="fromDate" id="fromDateLabel">From
                                Date</label>
                            <input class="form-control form-control-sm" id="fromDate" type="date" />
                        </div>
                        <div class="col-auto mt-1 ps-2 pe-2">
                            <label class="form-label form-label-sm mb-0" for="fromTime" id="fromTimeLabel">From
                                Time</label>
                            <input class="form-control form-control-sm" id="fromTime" type="time" />
                        </div>
                        <div class="col-auto mt-1 ps-2 pe-2">
                            <label class="form-label form-label-sm mb-0" for="toDate" id="toDateLabel">To Date</label>
                            <input class="form-control form-control-sm" id="toDate" type="date" />
                        </div>
                        <div class="col-auto mt-1 ps-2 pe-2">
                            <label class="form-label form-label-sm mb-0" for="toTime" id="toTimeLabel">To Time</label>
                            <input class="form-control form-control-sm" id="toTime" type="time" />
                        </div>
                        <div class="col-auto mt-1 ps-2 pe-2">
                            <label class="form-label form-label-sm mb-0" for="amount" id="amountLabel"
                                title="Amount of runs that are shown. Only the most recent x runs are shown after applying the other filters.">Amount</label>
                            <input class="form-control form-control-sm" type="number" min=0 id="amount"
                                title="Amount of runs that are shown. Only the most recent x runs are shown after applying the other filters."
                                value="10">
                        </div>
                        <div class="col-auto mt-1 ps-2 pe-2" id="metadataFilter" hidden>
                            <label class="form-label form-label-sm mb-0" for="metadata"
                                id="metadataLabel">Metadata</label>
                            <select class="form-select form-select-sm" id="metadata"></select>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Database Details Modal -->
        <div class="modal fade" id="databaseModal" tabindex="-1" aria-labelledby="databaseModalLabel">
            <div class="modal-dialog">
                <div class="modal-content">
                    <div class="modal-header">
                        <h1 class="modal-title" id="databaseModalLabel">Database Summary</h1>
                        <div>
                            <button type="button" class="btn btn-outline-light btn-sm mt-auto ms-3"
                                data-bs-dismiss="modal">Close</button>
                        </div>
                    </div>
                    <div class="modal-body">
                        <span id="stats"></span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Settings Modal -->
        <div class="modal fade" id="settingsModal" tabindex="-1" aria-labelledby="settingsModalLabel">
            <div class="modal-dialog modal-lg">
                <div class="modal-content">
                    <div class="modal-header">
                        <h1 class="modal-title" id="settingsModalLabel">Settings</h1>
                        <div>
                            <button type="button" class="btn btn-outline-light btn-sm mt-auto ms-3"
                                data-bs-dismiss="modal">Close</button>
                        </div>
                    </div>
                    <div class="modal-body">
                        <div class="row">
                            <div class="col-8 btn-group ms-1">
                                <label class="form-check-label mt-1" for="toggleLegends">Graphs: Show
                                    Legends</label>
                            </div>
                            <div class="col btn-group form-switch ms-2">
                                <input class="form-check-input mt-2" type="checkbox" role="switch" id="toggleLegends" />
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-8 btn-group ms-1">
                                <label class="form-check-label mt-1" for="toggleLabels">Graphs: Show Run Start/Alias
                                    Labels On Axes</label>
                            </div>
                            <div class="col btn-group form-switch ms-2">
                                <input class="form-check-input mt-2" type="checkbox" role="switch" id="toggleLabels" />
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-8 btn-group ms-1">
                                <label class="form-check-label mt-1" for="toggleAliases">Graphs: Show Alias Labels
                                    (Defaults
                                    to Run Start Labels)</label>
                            </div>
                            <div class="col btn-group form-switch ms-2">
                                <input class="form-check-input mt-2" type="checkbox" role="switch" id="toggleAliases" />
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-8 btn-group ms-1">
                                <label class="form-check-label mt-1" for="toggleMilliseconds">Graphs: Show
                                    Milliseconds Run Start Labels</label>
                            </div>
                            <div class="col btn-group form-switch ms-2">
                                <input class="form-check-input mt-2" type="checkbox" role="switch"
                                    id="toggleMilliseconds" />
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-8 btn-group ms-1">
                                <label class="form-check-label mt-1" for="toggleAnimations">Graphs: Show Drawing
                                    Animations</label>
                            </div>
                            <div class="col btn-group form-switch ms-2">
                                <input class="form-check-input mt-2" type="checkbox" role="switch"
                                    id="toggleAnimations" />
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-8 btn-group ms-1">
                                <label class="form-check-label mt-1" for="toggleAnimationDuration">Graphs: Animation
                                    Duration (Milliseconds)</label>
                            </div>
                            <div class="col-2 ps-0 mt-1">
                                <input class="form-control form-control-sm" type="number"
                                    id="toggleAnimationDuration" />
                            </div>
                        </div>
                        <div class="row pb-4">
                            <div class="col-8 btn-group ms-1">
                                <label class="form-check-label mt-1" for="toggleMaxGraphsPerRow">Graphs: Maximum
                                    Graphs
                                    Per Row</label>
                            </div>
                            <div class="col-2 ps-0 mt-1">
                                <select class="form-select form-select-sm" id="toggleMaxGraphsPerRow">
                                    <option value="1">1</option>
                                    <option value="2">2</option>
                                    <option value="3">3</option>
                                    <option value="4">4</option>
                                </select>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Customize View Modal -->
        <div class="modal fade" id="customizeModal" tabindex="-1" aria-labelledby="customizeModalLabel">
            <div class="modal-dialog modal-xl">
                <div class="modal-content">
                    <div class="modal-header">
                        <h1 class="modal-title" id="customizeModalLabel">Customize View</h1>
                        <div>
                            <button type="button" class="btn btn-outline-light btn-sm mt-auto" data-bs-dismiss="modal"
                                id="resetGraphConfig">Reset View</button>
                            <button type="button" class="btn btn-outline-light btn-sm mt-auto ms-3"
                                data-bs-dismiss="modal">Close</button>
                        </div>
                    </div>
                    <div class="modal-body">
                        <div class="row">
                            <div class="col">
                                <h4 class="ms-1 mb-2">Show Sections</h4>
                                <div class="border border-3 rounded-3">
                                    <ol id="sectionShow" class="list-group list-group-numbered"></ol>
                                </div>
                            </div>
                            <div class="col-auto mt-5">
                                <div class="controls mt-5">
                                    <button class="btn btn-sm" id="sectionRight"></button>
                                    <button class="btn btn-sm" id="sectionLeft"></button>
                                </div>
                            </div>
                            <div class="col">
                                <h4 class="ms-1 mb-2">Hide Sections</h4>
                                <div class="border border-3 rounded-3">
                                    <ol id="sectionHide" class="list-group"></ol>
                                </div>
                            </div>
                            <div class="col">
                                <h4 class="ms-1 mb-2">Show Graphs</h4>
                                <div class="border border-3 rounded-3">
                                    <ol id="graphShow" class="list-group list-group-numbered"></ol>
                                </div>
                            </div>
                            <div class="col-auto mt-5">
                                <div class="controls mt-5">
                                    <button class="btn btn-sm" id="graphRight"></button>
                                    <button class="btn btn-sm" id="graphLeft"></button>
                                </div>
                            </div>
                            <div class="col">
                                <h4 class="ms-1 mb-2">Hide Graphs</h4>
                                <div class="border border-3 rounded-3">
                                    <ol id="graphHide" class="list-group"></ol>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        /////////////////////////////
        // GLOBAL VARIABLE SECTION //
        /////////////////////////////

        // svgs
        const arrowRight = '<svg xmlns="http://www.w3.org/2000/svg" width="16px" height="16px" viewBox="0 0 52 52"><g><path fill="currentColor" d="M17.9,4.4l20.7,20.5c0.6,0.6,0.6,1.6,0,2.2L17.9,47.6c-0.6,0.6-1.6,0.6-2.2,0l-2.2-2.2c-0.6-0.6-0.6-1.6,0-2.2l16.3-16.1c0.6-0.6,0.6-1.6,0-2.2L13.6,8.8c-0.6-0.6-0.6-1.6,0-2.2l2.2-2.2C16.4,3.9,17.3,3.9,17.9,4.4z"></path></g></svg>';
        const arrowRightSmall = '<svg xmlns="http://www.w3.org/2000/svg" width="12px" height="12px" viewBox="0 0 52 52"><g><path fill="currentColor" d="M17.9,4.4l20.7,20.5c0.6,0.6,0.6,1.6,0,2.2L17.9,47.6c-0.6,0.6-1.6,0.6-2.2,0l-2.2-2.2c-0.6-0.6-0.6-1.6,0-2.2l16.3-16.1c0.6-0.6,0.6-1.6,0-2.2L13.6,8.8c-0.6-0.6-0.6-1.6,0-2.2l2.2-2.2C16.4,3.9,17.3,3.9,17.9,4.4z"></path></g></svg>';
        const arrowDown = '<svg xmlns="http://www.w3.org/2000/svg" width="16px" height="16px" viewBox="0 0 52 52"><path fill="currentColor" d="M47.6,17.8L27.1,38.5c-0.6,0.6-1.6,0.6-2.2,0L4.4,17.8c-0.6-0.6-0.6-1.6,0-2.2l2.2-2.2c0.6-0.6,1.6-0.6,2.2,0l16.1,16.3c0.6,0.6,1.6,0.6,2.2,0l16.1-16.2c0.6-0.6,1.6-0.6,2.2,0l2.2,2.2C48.1,16.3,48.1,17.2,47.6,17.8z"/></svg>';
        const arrowDownSmall = '<svg xmlns="http://www.w3.org/2000/svg" width="12px" height="12px" viewBox="0 0 52 52"><path fill="currentColor" d="M47.6,17.8L27.1,38.5c-0.6,0.6-1.6,0.6-2.2,0L4.4,17.8c-0.6-0.6-0.6-1.6,0-2.2l2.2-2.2c0.6-0.6,1.6-0.6,2.2,0l16.1,16.3c0.6,0.6,1.6,0.6,2.2,0l16.1-16.2c0.6-0.6,1.6-0.6,2.2,0l2.2,2.2C48.1,16.3,48.1,17.2,47.6,17.8z"/></svg>';
        const arrowLeft = '<svg xmlns="http://www.w3.org/2000/svg" width="16px" height="16px" viewBox="0 0 52 52"><g transform="scale(-1,1) translate(-52,0)"><path fill="currentColor" d="M17.9,4.4l20.7,20.5c0.6,0.6,0.6,1.6,0,2.2L17.9,47.6c-0.6,0.6-1.6,0.6-2.2,0l-2.2-2.2c-0.6-0.6-0.6-1.6,0-2.2l16.3-16.1c0.6-0.6,0.6-1.6,0-2.2L13.6,8.8c-0.6-0.6-0.6-1.6,0-2.2l2.2-2.2C16.4,3.9,17.3,3.9,17.9,4.4z"/></g></svg>';
        const arrowDownVerySmall = '<svg xmlns="http://www.w3.org/2000/svg" width="8px" height="8px" viewBox="0 0 52 52"><path fill="currentColor" d="M47.6,17.8L27.1,38.5c-0.6,0.6-1.6,0.6-2.2,0L4.4,17.8c-0.6-0.6-0.6-1.6,0-2.2l2.2-2.2c0.6-0.6,1.6-0.6,2.2,0l16.1,16.3c0.6,0.6,1.6,0.6,2.2,0l16.1-16.2c0.6-0.6,1.6-0.6,2.2,0l2.2,2.2C48.1,16.3,48.1,17.2,47.6,17.8z"/></svg>';
        const arrowUpVerySmall = '<svg xmlns="http://www.w3.org/2000/svg" width="8px" height="8px" viewBox="0 0 52 52" transform="matrix(-1,1.2246467991473532e-16,-1.2246467991473532e-16,-1,0,0)"><path fill="currentColor" d="M47.6,17.8L27.1,38.5c-0.6,0.6-1.6,0.6-2.2,0L4.4,17.8c-0.6-0.6-0.6-1.6,0-2.2l2.2-2.2c0.6-0.6,1.6-0.6,2.2,0l16.1,16.3c0.6,0.6,1.6,0.6,2.2,0l16.1-16.2c0.6-0.6,1.6-0.6,2.2,0l2.2,2.2C48.1,16.3,48.1,17.2,47.6,17.8z"></path></svg>';
        const informationSVG = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="21" fill="currentColor" class="bi bi-info-circle" viewBox="0 0 16 16"><path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14m0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16" /><path d="m8.93 6.588-2.29.287-.082.38.45.083c.294.07.352.176.288.469l-.738 3.468c-.194.897.105 1.319.808 1.319.545 0 1.178-.252 1.465-.598l.088-.416c-.2.176-.492.246-.686.246-.275 0-.375-.193-.304-.533zM9 4.5a1 1 0 1 1-2 0 1 1 0 0 1 2 0" /></svg>';
        const githubDarkSVG = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><path fill="white" d="M12 1C5.923 1 1 5.923 1 12c0 4.867 3.149 8.979 7.521 10.436.55.096.756-.233.756-.522 0-.262-.013-1.128-.013-2.049-2.764.509-3.479-.674-3.699-1.292-.124-.317-.66-1.293-1.127-1.554-.385-.207-.936-.715-.014-.729.866-.014 1.485.797 1.691 1.128.99 1.663 2.571 1.196 3.204.907.096-.715.385-1.196.701-1.471-2.448-.275-5.005-1.224-5.005-5.432 0-1.196.426-2.186 1.128-2.956-.111-.275-.496-1.402.11-2.915 0 0 .921-.288 3.024 1.128a10.193 10.193 0 0 1 2.75-.371c.936 0 1.871.123 2.75.371 2.104-1.43 3.025-1.128 3.025-1.128.605 1.513.221 2.64.111 2.915.701.77 1.127 1.747 1.127 2.956 0 4.222-2.571 5.157-5.019 5.432.399.344.743 1.004.743 2.035 0 1.471-.014 2.654-.014 3.025 0 .289.206.632.756.522C19.851 20.979 23 16.854 23 12c0-6.077-4.922-11-11-11Z"></path></svg>';
        const githubLightSVG = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><path d="M12 1C5.923 1 1 5.923 1 12c0 4.867 3.149 8.979 7.521 10.436.55.096.756-.233.756-.522 0-.262-.013-1.128-.013-2.049-2.764.509-3.479-.674-3.699-1.292-.124-.317-.66-1.293-1.127-1.554-.385-.207-.936-.715-.014-.729.866-.014 1.485.797 1.691 1.128.99 1.663 2.571 1.196 3.204.907.096-.715.385-1.196.701-1.471-2.448-.275-5.005-1.224-5.005-5.432 0-1.196.426-2.186 1.128-2.956-.111-.275-.496-1.402.11-2.915 0 0 .921-.288 3.024 1.128a10.193 10.193 0 0 1 2.75-.371c.936 0 1.871.123 2.75.371 2.104-1.43 3.025-1.128 3.025-1.128.605 1.513.221 2.64.111 2.915.701.77 1.127 1.747 1.127 2.956 0 4.222-2.571 5.157-5.019 5.432.399.344.743 1.004.743 2.035 0 1.471-.014 2.654-.014 3.025 0 .289.206.632.756.522C19.851 20.979 23 16.854 23 12c0-6.077-4.922-11-11-11Z"></path></svg>';
        const settingsDarkSVG = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><path fill="white" d="M16 12a4 4 0 1 1-8 0 4 4 0 0 1 8 0Zm-1.5 0a2.5 2.5 0 1 0-5 0 2.5 2.5 0 0 0 5 0Z"></path><path fill="white" d="M12 1c.266 0 .532.009.797.028.763.055 1.345.617 1.512 1.304l.352 1.45c.019.078.09.171.225.221.247.089.49.19.728.302.13.061.246.044.315.002l1.275-.776c.603-.368 1.411-.353 1.99.147.402.349.78.726 1.128 1.129.501.578.515 1.386.147 1.99l-.776 1.274c-.042.069-.058.185.002.315.112.238.213.481.303.728.048.135.142.205.22.225l1.45.352c.687.167 1.249.749 1.303 1.512.038.531.038 1.063 0 1.594-.054.763-.616 1.345-1.303 1.512l-1.45.352c-.078.019-.171.09-.221.225-.089.248-.19.491-.302.728-.061.13-.044.246-.002.315l.776 1.275c.368.603.353 1.411-.147 1.99-.349.402-.726.78-1.129 1.128-.578.501-1.386.515-1.99.147l-1.274-.776c-.069-.042-.185-.058-.314.002a8.606 8.606 0 0 1-.729.303c-.135.048-.205.142-.225.22l-.352 1.45c-.167.687-.749 1.249-1.512 1.303-.531.038-1.063.038-1.594 0-.763-.054-1.345-.616-1.512-1.303l-.352-1.45c-.019-.078-.09-.171-.225-.221a8.138 8.138 0 0 1-.728-.302c-.13-.061-.246-.044-.315-.002l-1.275.776c-.603.368-1.411.353-1.99-.147-.402-.349-.78-.726-1.128-1.129-.501-.578-.515-1.386-.147-1.99l.776-1.274c.042-.069.058-.185-.002-.314a8.606 8.606 0 0 1-.303-.729c-.048-.135-.142-.205-.22-.225l-1.45-.352c-.687-.167-1.249-.749-1.304-1.512a11.158 11.158 0 0 1 0-1.594c.055-.763.617-1.345 1.304-1.512l1.45-.352c.078-.019.171-.09.221-.225.089-.248.19-.491.302-.728.061-.13.044-.246.002-.315l-.776-1.275c-.368-.603-.353-1.411.147-1.99.349-.402.726-.78 1.129-1.128.578-.501 1.386-.515 1.99-.147l1.274.776c.069.042.185.058.315-.002.238-.112.481-.213.728-.303.135-.048.205-.142.225-.22l.352-1.45c.167-.687.749-1.249 1.512-1.304C11.466 1.01 11.732 1 12 1Zm-.69 1.525c-.055.004-.135.05-.161.161l-.353 1.45a1.832 1.832 0 0 1-1.172 1.277 7.147 7.147 0 0 0-.6.249 1.833 1.833 0 0 1-1.734-.074l-1.274-.776c-.098-.06-.186-.036-.228 0a9.774 9.774 0 0 0-.976.976c-.036.042-.06.131 0 .228l.776 1.274c.314.529.342 1.18.074 1.734a7.147 7.147 0 0 0-.249.6 1.831 1.831 0 0 1-1.278 1.173l-1.45.351c-.11.027-.156.107-.16.162a9.63 9.63 0 0 0 0 1.38c.004.055.05.135.161.161l1.45.353a1.832 1.832 0 0 1 1.277 1.172c.074.204.157.404.249.6.268.553.24 1.204-.074 1.733l-.776 1.275c-.06.098-.036.186 0 .228.301.348.628.675.976.976.042.036.131.06.228 0l1.274-.776a1.83 1.83 0 0 1 1.734-.075c.196.093.396.176.6.25a1.831 1.831 0 0 1 1.173 1.278l.351 1.45c.027.11.107.156.162.16a9.63 9.63 0 0 0 1.38 0c.055-.004.135-.05.161-.161l.353-1.45a1.834 1.834 0 0 1 1.172-1.278 6.82 6.82 0 0 0 .6-.248 1.831 1.831 0 0 1 1.733.074l1.275.776c.098.06.186.036.228 0 .348-.301.675-.628.976-.976.036-.042.06-.131 0-.228l-.776-1.275a1.834 1.834 0 0 1-.075-1.733c.093-.196.176-.396.25-.6a1.831 1.831 0 0 1 1.278-1.173l1.45-.351c.11-.027.156-.107.16-.162a9.63 9.63 0 0 0 0-1.38c-.004-.055-.05-.135-.161-.161l-1.45-.353c-.626-.152-1.08-.625-1.278-1.172a6.576 6.576 0 0 0-.248-.6 1.833 1.833 0 0 1 .074-1.734l.776-1.274c.06-.098.036-.186 0-.228a9.774 9.774 0 0 0-.976-.976c-.042-.036-.131-.06-.228 0l-1.275.776a1.831 1.831 0 0 1-1.733.074 6.88 6.88 0 0 0-.6-.249 1.835 1.835 0 0 1-1.173-1.278l-.351-1.45c-.027-.11-.107-.156-.162-.16a9.63 9.63 0 0 0-1.38 0Z"></path></svg>'
        const settingsLightSVG = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><path d="M16 12a4 4 0 1 1-8 0 4 4 0 0 1 8 0Zm-1.5 0a2.5 2.5 0 1 0-5 0 2.5 2.5 0 0 0 5 0Z"></path><path d="M12 1c.266 0 .532.009.797.028.763.055 1.345.617 1.512 1.304l.352 1.45c.019.078.09.171.225.221.247.089.49.19.728.302.13.061.246.044.315.002l1.275-.776c.603-.368 1.411-.353 1.99.147.402.349.78.726 1.128 1.129.501.578.515 1.386.147 1.99l-.776 1.274c-.042.069-.058.185.002.315.112.238.213.481.303.728.048.135.142.205.22.225l1.45.352c.687.167 1.249.749 1.303 1.512.038.531.038 1.063 0 1.594-.054.763-.616 1.345-1.303 1.512l-1.45.352c-.078.019-.171.09-.221.225-.089.248-.19.491-.302.728-.061.13-.044.246-.002.315l.776 1.275c.368.603.353 1.411-.147 1.99-.349.402-.726.78-1.129 1.128-.578.501-1.386.515-1.99.147l-1.274-.776c-.069-.042-.185-.058-.314.002a8.606 8.606 0 0 1-.729.303c-.135.048-.205.142-.225.22l-.352 1.45c-.167.687-.749 1.249-1.512 1.303-.531.038-1.063.038-1.594 0-.763-.054-1.345-.616-1.512-1.303l-.352-1.45c-.019-.078-.09-.171-.225-.221a8.138 8.138 0 0 1-.728-.302c-.13-.061-.246-.044-.315-.002l-1.275.776c-.603.368-1.411.353-1.99-.147-.402-.349-.78-.726-1.128-1.129-.501-.578-.515-1.386-.147-1.99l.776-1.274c.042-.069.058-.185-.002-.314a8.606 8.606 0 0 1-.303-.729c-.048-.135-.142-.205-.22-.225l-1.45-.352c-.687-.167-1.249-.749-1.304-1.512a11.158 11.158 0 0 1 0-1.594c.055-.763.617-1.345 1.304-1.512l1.45-.352c.078-.019.171-.09.221-.225.089-.248.19-.491.302-.728.061-.13.044-.246.002-.315l-.776-1.275c-.368-.603-.353-1.411.147-1.99.349-.402.726-.78 1.129-1.128.578-.501 1.386-.515 1.99-.147l1.274.776c.069.042.185.058.315-.002.238-.112.481-.213.728-.303.135-.048.205-.142.225-.22l.352-1.45c.167-.687.749-1.249 1.512-1.304C11.466 1.01 11.732 1 12 1Zm-.69 1.525c-.055.004-.135.05-.161.161l-.353 1.45a1.832 1.832 0 0 1-1.172 1.277 7.147 7.147 0 0 0-.6.249 1.833 1.833 0 0 1-1.734-.074l-1.274-.776c-.098-.06-.186-.036-.228 0a9.774 9.774 0 0 0-.976.976c-.036.042-.06.131 0 .228l.776 1.274c.314.529.342 1.18.074 1.734a7.147 7.147 0 0 0-.249.6 1.831 1.831 0 0 1-1.278 1.173l-1.45.351c-.11.027-.156.107-.16.162a9.63 9.63 0 0 0 0 1.38c.004.055.05.135.161.161l1.45.353a1.832 1.832 0 0 1 1.277 1.172c.074.204.157.404.249.6.268.553.24 1.204-.074 1.733l-.776 1.275c-.06.098-.036.186 0 .228.301.348.628.675.976.976.042.036.131.06.228 0l1.274-.776a1.83 1.83 0 0 1 1.734-.075c.196.093.396.176.6.25a1.831 1.831 0 0 1 1.173 1.278l.351 1.45c.027.11.107.156.162.16a9.63 9.63 0 0 0 1.38 0c.055-.004.135-.05.161-.161l.353-1.45a1.834 1.834 0 0 1 1.172-1.278 6.82 6.82 0 0 0 .6-.248 1.831 1.831 0 0 1 1.733.074l1.275.776c.098.06.186.036.228 0 .348-.301.675-.628.976-.976.036-.042.06-.131 0-.228l-.776-1.275a1.834 1.834 0 0 1-.075-1.733c.093-.196.176-.396.25-.6a1.831 1.831 0 0 1 1.278-1.173l1.45-.351c.11-.027.156-.107.16-.162a9.63 9.63 0 0 0 0-1.38c-.004-.055-.05-.135-.161-.161l-1.45-.353c-.626-.152-1.08-.625-1.278-1.172a6.576 6.576 0 0 0-.248-.6 1.833 1.833 0 0 1 .074-1.734l.776-1.274c.06-.098.036-.186 0-.228a9.774 9.774 0 0 0-.976-.976c-.042-.036-.131-.06-.228 0l-1.275.776a1.831 1.831 0 0 1-1.733.074 6.88 6.88 0 0 0-.6-.249 1.835 1.835 0 0 1-1.173-1.278l-.351-1.45c-.027-.11-.107-.156-.162-.16a9.63 9.63 0 0 0-1.38 0Z"></path></svg>'
        const databaseDarkSVG = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><path fill="white" d="M12 1.25c2.487 0 4.773.402 6.466 1.079.844.337 1.577.758 2.112 1.264.536.507.922 1.151.922 1.907v12.987l-.026.013h.026c0 .756-.386 1.4-.922 1.907-.535.506-1.268.927-2.112 1.264-1.693.677-3.979 1.079-6.466 1.079s-4.774-.402-6.466-1.079c-.844-.337-1.577-.758-2.112-1.264C2.886 19.9 2.5 19.256 2.5 18.5h.026l-.026-.013V5.5c0-.756.386-1.4.922-1.907.535-.506 1.268-.927 2.112-1.264C7.226 1.652 9.513 1.25 12 1.25ZM4 14.371v4.116l-.013.013H4c0 .211.103.487.453.817.351.332.898.666 1.638.962 1.475.589 3.564.971 5.909.971 2.345 0 4.434-.381 5.909-.971.739-.296 1.288-.63 1.638-.962.349-.33.453-.607.453-.817h.013L20 18.487v-4.116a7.85 7.85 0 0 1-1.534.8c-1.693.677-3.979 1.079-6.466 1.079s-4.774-.402-6.466-1.079a7.843 7.843 0 0 1-1.534-.8ZM20 12V7.871a7.85 7.85 0 0 1-1.534.8C16.773 9.348 14.487 9.75 12 9.75s-4.774-.402-6.466-1.079A7.85 7.85 0 0 1 4 7.871V12c0 .21.104.487.453.817.35.332.899.666 1.638.961 1.475.59 3.564.972 5.909.972 2.345 0 4.434-.382 5.909-.972.74-.295 1.287-.629 1.638-.96.35-.33.453-.607.453-.818ZM4 5.5c0 .211.103.487.453.817.351.332.898.666 1.638.962 1.475.589 3.564.971 5.909.971 2.345 0 4.434-.381 5.909-.971.739-.296 1.288-.63 1.638-.962.349-.33.453-.607.453-.817 0-.211-.103-.487-.453-.817-.351-.332-.898-.666-1.638-.962-1.475-.589-3.564-.971-5.909-.971-2.345 0-4.434.381-5.909.971-.739.296-1.288.63-1.638.962C4.104 5.013 4 5.29 4 5.5Z"></path></svg>'
        const databaseLightSVG = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><path d="M12 1.25c2.487 0 4.773.402 6.466 1.079.844.337 1.577.758 2.112 1.264.536.507.922 1.151.922 1.907v12.987l-.026.013h.026c0 .756-.386 1.4-.922 1.907-.535.506-1.268.927-2.112 1.264-1.693.677-3.979 1.079-6.466 1.079s-4.774-.402-6.466-1.079c-.844-.337-1.577-.758-2.112-1.264C2.886 19.9 2.5 19.256 2.5 18.5h.026l-.026-.013V5.5c0-.756.386-1.4.922-1.907.535-.506 1.268-.927 2.112-1.264C7.226 1.652 9.513 1.25 12 1.25ZM4 14.371v4.116l-.013.013H4c0 .211.103.487.453.817.351.332.898.666 1.638.962 1.475.589 3.564.971 5.909.971 2.345 0 4.434-.381 5.909-.971.739-.296 1.288-.63 1.638-.962.349-.33.453-.607.453-.817h.013L20 18.487v-4.116a7.85 7.85 0 0 1-1.534.8c-1.693.677-3.979 1.079-6.466 1.079s-4.774-.402-6.466-1.079a7.843 7.843 0 0 1-1.534-.8ZM20 12V7.871a7.85 7.85 0 0 1-1.534.8C16.773 9.348 14.487 9.75 12 9.75s-4.774-.402-6.466-1.079A7.85 7.85 0 0 1 4 7.871V12c0 .21.104.487.453.817.35.332.899.666 1.638.961 1.475.59 3.564.972 5.909.972 2.345 0 4.434-.382 5.909-.972.74-.295 1.287-.629 1.638-.96.35-.33.453-.607.453-.818ZM4 5.5c0 .211.103.487.453.817.351.332.898.666 1.638.962 1.475.589 3.564.971 5.909.971 2.345 0 4.434-.381 5.909-.971.739-.296 1.288-.63 1.638-.962.349-.33.453-.607.453-.817 0-.211-.103-.487-.453-.817-.351-.332-.898-.666-1.638-.962-1.475-.589-3.564-.971-5.909-.971-2.345 0-4.434.381-5.909.971-.739.296-1.288.63-1.638.962C4.104 5.013 4 5.29 4 5.5Z"></path></svg>'
        const filterDarkSVG = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><path fill="white" d="M11 18.25a.75.75 0 0 1 .75-.75h8.5a.75.75 0 0 1 0 1.5h-8.5a.75.75 0 0 1-.75-.75Zm-8-12a.75.75 0 0 1 .75-.75h7.5a.75.75 0 0 1 0 1.5h-7.5A.75.75 0 0 1 3 6.25Zm13 6a.75.75 0 0 1 .75-.75h3.5a.75.75 0 0 1 0 1.5h-3.5a.75.75 0 0 1-.75-.75ZM8.75 16a.75.75 0 0 1 .75.75v3a.75.75 0 0 1-1.5 0v-3a.75.75 0 0 1 .75-.75Z"></path><path fill="white" d="M3 18.25a.75.75 0 0 1 .75-.75h4.5a.75.75 0 0 1 0 1.5h-4.5a.75.75 0 0 1-.75-.75Zm0-6a.75.75 0 0 1 .75-.75h8.5a.75.75 0 0 1 0 1.5h-8.5a.75.75 0 0 1-.75-.75ZM16.75 10a.75.75 0 0 1 .75.75v3a.75.75 0 0 1-1.5 0v-3a.75.75 0 0 1 .75-.75ZM14 6.25a.75.75 0 0 1 .75-.75h5.5a.75.75 0 0 1 0 1.5h-5.5a.75.75 0 0 1-.75-.75ZM11.25 4a.75.75 0 0 1 .75.75v3a.75.75 0 0 1-1.5 0v-3a.75.75 0 0 1 .75-.75Z"></path></svg>'
        const filterLightSVG = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><path d="M11 18.25a.75.75 0 0 1 .75-.75h8.5a.75.75 0 0 1 0 1.5h-8.5a.75.75 0 0 1-.75-.75Zm-8-12a.75.75 0 0 1 .75-.75h7.5a.75.75 0 0 1 0 1.5h-7.5A.75.75 0 0 1 3 6.25Zm13 6a.75.75 0 0 1 .75-.75h3.5a.75.75 0 0 1 0 1.5h-3.5a.75.75 0 0 1-.75-.75ZM8.75 16a.75.75 0 0 1 .75.75v3a.75.75 0 0 1-1.5 0v-3a.75.75 0 0 1 .75-.75Z"></path><path d="M3 18.25a.75.75 0 0 1 .75-.75h4.5a.75.75 0 0 1 0 1.5h-4.5a.75.75 0 0 1-.75-.75Zm0-6a.75.75 0 0 1 .75-.75h8.5a.75.75 0 0 1 0 1.5h-8.5a.75.75 0 0 1-.75-.75ZM16.75 10a.75.75 0 0 1 .75.75v3a.75.75 0 0 1-1.5 0v-3a.75.75 0 0 1 .75-.75ZM14 6.25a.75.75 0 0 1 .75-.75h5.5a.75.75 0 0 1 0 1.5h-5.5a.75.75 0 0 1-.75-.75ZM11.25 4a.75.75 0 0 1 .75.75v3a.75.75 0 0 1-1.5 0v-3a.75.75 0 0 1 .75-.75Z"></path></svg>'
        const rflogoDarkSVG = '<svg data-v-266d6681="" data-v-7dd69bf4="" version="1.1" id="face" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24" class="fill-white"><path fill="white" data-v-266d6681="" id="path" d="M5,10.2c0-1.9,1.5-3.4,3.4-3.4c1.9,0,3.4,1.5,3.4,3.4c0,0.7-0.6,1.2-1.2,1.2c-0.7,0-1.2-0.6-1.2-1.2 c0-0.5-0.4-0.9-0.9-0.9c-0.5,0-0.9,0.4-0.9,0.9c0,0.7-0.6,1.2-1.2,1.2S5,10.9,5,10.2 M19,15.9c0,0.7-0.6,1.2-1.2,1.2H6.4 c-0.7,0-1.2-0.6-1.2-1.2c0-0.7,0.6-1.2,1.2-1.2h11.5C18.5,14.7,19,15.3,19,15.9 M13.7,10.9c-0.4-0.6-0.2-1.3,0.3-1.7l2.9-1.9 c0.6-0.4,1.3-0.2,1.7,0.3c0.4,0.6,0.2,1.3-0.3,1.7l-2.9,1.9c-0.2,0.1-0.5,0.2-0.7,0.2C14.3,11.5,13.9,11.3,13.7,10.9 M21.5,18.5 c0,0.2-0.1,0.5-0.3,0.6l-2.1,2.1c-0.2,0.2-0.4,0.3-0.6,0.3h-13c-0.2,0-0.5-0.1-0.6-0.3l-2.1-2.1c-0.2-0.2-0.3-0.4-0.3-0.6v-13 c0-0.2,0.1-0.5,0.3-0.6l2.1-2.1C5,2.6,5.2,2.5,5.5,2.5h13c0.2,0,0.5,0.1,0.6,0.3l2.1,2.1c0.2,0.2,0.3,0.4,0.3,0.6V18.5z M23.3,3.4 l-2.8-2.8C20.1,0.2,19.6,0,19,0H5C4.4,0,3.9,0.2,3.4,0.7L0.7,3.4C0.2,3.9,0,4.4,0,5v14c0,0.6,0.2,1.2,0.7,1.6l2.8,2.8 C3.9,23.8,4.4,24,5,24h14c0.6,0,1.2-0.2,1.6-0.7l2.8-2.8c0.4-0.4,0.7-1,0.7-1.6V5C24,4.4,23.8,3.9,23.3,3.4"></path></svg>'
        const rflogoLightSVG = '<svg data-v-266d6681="" data-v-7dd69bf4="" version="1.1" id="face" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24" class="fill-white"><path data-v-266d6681="" id="path" d="M5,10.2c0-1.9,1.5-3.4,3.4-3.4c1.9,0,3.4,1.5,3.4,3.4c0,0.7-0.6,1.2-1.2,1.2c-0.7,0-1.2-0.6-1.2-1.2 c0-0.5-0.4-0.9-0.9-0.9c-0.5,0-0.9,0.4-0.9,0.9c0,0.7-0.6,1.2-1.2,1.2S5,10.9,5,10.2 M19,15.9c0,0.7-0.6,1.2-1.2,1.2H6.4 c-0.7,0-1.2-0.6-1.2-1.2c0-0.7,0.6-1.2,1.2-1.2h11.5C18.5,14.7,19,15.3,19,15.9 M13.7,10.9c-0.4-0.6-0.2-1.3,0.3-1.7l2.9-1.9 c0.6-0.4,1.3-0.2,1.7,0.3c0.4,0.6,0.2,1.3-0.3,1.7l-2.9,1.9c-0.2,0.1-0.5,0.2-0.7,0.2C14.3,11.5,13.9,11.3,13.7,10.9 M21.5,18.5 c0,0.2-0.1,0.5-0.3,0.6l-2.1,2.1c-0.2,0.2-0.4,0.3-0.6,0.3h-13c-0.2,0-0.5-0.1-0.6-0.3l-2.1-2.1c-0.2-0.2-0.3-0.4-0.3-0.6v-13 c0-0.2,0.1-0.5,0.3-0.6l2.1-2.1C5,2.6,5.2,2.5,5.5,2.5h13c0.2,0,0.5,0.1,0.6,0.3l2.1,2.1c0.2,0.2,0.3,0.4,0.3,0.6V18.5z M23.3,3.4 l-2.8-2.8C20.1,0.2,19.6,0,19,0H5C4.4,0,3.9,0.2,3.4,0.7L0.7,3.4C0.2,3.9,0,4.4,0,5v14c0,0.6,0.2,1.2,0.7,1.6l2.8,2.8 C3.9,23.8,4.4,24,5,24h14c0.6,0,1.2-0.2,1.6-0.7l2.8-2.8c0.4-0.4,0.7-1,0.7-1.6V5C24,4.4,23.8,3.9,23.3,3.4"></path></svg>'
        const clockDarkSVG = `<svg class="mb-1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16"><path fill="white" d="M8 0a8 8 0 1 1 0 16A8 8 0 0 1 8 0ZM1.5 8a6.5 6.5 0 1 0 13 0 6.5 6.5 0 0 0-13 0Zm7-3.25v2.992l2.028.812a.75.75 0 0 1-.557 1.392l-2.5-1A.751.751 0 0 1 7 8.25v-3.5a.75.75 0 0 1 1.5 0Z"></path></svg>`
        const clockLightSVG = `<svg class="mb-1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16"><path d="M8 0a8 8 0 1 1 0 16A8 8 0 0 1 8 0ZM1.5 8a6.5 6.5 0 1 0 13 0 6.5 6.5 0 0 0-13 0Zm7-3.25v2.992l2.028.812a.75.75 0 0 1-.557 1.392l-2.5-1A.751.751 0 0 1 7 8.25v-3.5a.75.75 0 0 1 1.5 0Z"></path></svg>`
        const sunSVG = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><path fill="white" d="M12 19a7 7 0 1 1 0-14 7 7 0 0 1 0 14Zm0-1.5a5.5 5.5 0 1 0 0-11 5.5 5.5 0 1 0 0 11Zm-5.657.157a.75.75 0 0 1 0 1.06l-1.768 1.768a.749.749 0 0 1-1.275-.326.749.749 0 0 1 .215-.734l1.767-1.768a.75.75 0 0 1 1.061 0ZM3.515 3.515a.75.75 0 0 1 1.06 0l1.768 1.768a.749.749 0 0 1-.326 1.275.749.749 0 0 1-.734-.215L3.515 4.575a.75.75 0 0 1 0-1.06ZM12 0a.75.75 0 0 1 .75.75v2.5a.75.75 0 0 1-1.5 0V.75A.75.75 0 0 1 12 0ZM4 12a.75.75 0 0 1-.75.75H.75a.75.75 0 0 1 0-1.5h2.5A.75.75 0 0 1 4 12Zm8 8a.75.75 0 0 1 .75.75v2.5a.75.75 0 0 1-1.5 0v-2.5A.75.75 0 0 1 12 20Zm12-8a.75.75 0 0 1-.75.75h-2.5a.75.75 0 0 1 0-1.5h2.5A.75.75 0 0 1 24 12Zm-6.343 5.657a.75.75 0 0 1 1.06 0l1.768 1.768a.751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018l-1.768-1.767a.75.75 0 0 1 0-1.061Zm2.828-14.142a.75.75 0 0 1 0 1.06l-1.768 1.768a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042l1.767-1.768a.75.75 0 0 1 1.061 0Z"></path></svg>`
        const moonSVG = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><path d="M14.768 3.96v.001l-.002-.005a9.08 9.08 0 0 0-.218-.779c-.13-.394.21-.8.602-.67.29.096.575.205.855.328l.01.005A10.002 10.002 0 0 1 12 22a10.002 10.002 0 0 1-9.162-5.985l-.004-.01a9.722 9.722 0 0 1-.329-.855c-.13-.392.277-.732.67-.602.257.084.517.157.78.218l.004.002A9 9 0 0 0 14.999 6a9.09 9.09 0 0 0-.231-2.04ZM16.5 6c0 5.799-4.701 10.5-10.5 10.5-.426 0-.847-.026-1.26-.075A8.5 8.5 0 1 0 16.425 4.74c.05.413.075.833.075 1.259Z"></path></svg>`
        const brushDarkSVG = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><path fill="white" d="M19.642 6.653c-1.31 1.812-3.251 3.86-4.945 5.575l-.091.092-2.69-2.69.098-.098c1.69-1.71 3.732-3.656 5.544-4.962.911-.657 1.715-1.115 2.353-1.318.652-.207.915-.091 1.039.033.113.113.231.367.019 1.02-.207.635-.668 1.436-1.327 2.348ZM10.9 10.736l2.605 2.605c-.88.754-1.684 1.294-2.378 1.655a4.832 4.832 0 0 0-1.892-1.89c.36-.69.903-1.482 1.665-2.37Zm-3.086 1.856a4.825 4.825 0 0 0-4.33 1.328c-.525.525-.88 1.302-1.13 2.079-.256.795-.43 1.682-.541 2.507a19.055 19.055 0 0 0-.173 2.216c-.004.3.003.567.022.778.009.104.022.212.044.31.01.05.027.113.053.18.02.051.074.178.19.295.117.117.245.17.297.19.066.026.13.043.178.054.099.021.207.035.31.044.211.019.479.025.779.021.603-.008 1.39-.06 2.216-.172.825-.112 1.711-.285 2.507-.54.776-.25 1.553-.606 2.079-1.132a4.825 4.825 0 0 0 1.327-4.333c1.209-.6 2.622-1.618 4.121-3.135 1.694-1.714 3.709-3.835 5.093-5.75.688-.952 1.258-1.904 1.538-2.764.274-.842.334-1.826-.384-2.544-.72-.719-1.703-.672-2.555-.401-.865.275-1.822.843-2.776 1.53-1.92 1.384-4.036 3.407-5.733 5.125-1.5 1.518-2.53 2.896-3.132 4.114Zm1.44 2.388a3.33 3.33 0 0 1 0 4.71c-.271.27-.774.537-1.478.763-.684.22-1.477.378-2.248.482-.769.104-1.495.152-2.035.16a9.247 9.247 0 0 1-.351-.002 9.182 9.182 0 0 1-.002-.35c.007-.542.055-1.267.16-2.036.104-.771.261-1.564.481-2.249.227-.703.493-1.206.764-1.478a3.33 3.33 0 0 1 4.71 0Z"></path></svg>`
        const brushLightSVG = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><path d="M19.642 6.653c-1.31 1.812-3.251 3.86-4.945 5.575l-.091.092-2.69-2.69.098-.098c1.69-1.71 3.732-3.656 5.544-4.962.911-.657 1.715-1.115 2.353-1.318.652-.207.915-.091 1.039.033.113.113.231.367.019 1.02-.207.635-.668 1.436-1.327 2.348ZM10.9 10.736l2.605 2.605c-.88.754-1.684 1.294-2.378 1.655a4.832 4.832 0 0 0-1.892-1.89c.36-.69.903-1.482 1.665-2.37Zm-3.086 1.856a4.825 4.825 0 0 0-4.33 1.328c-.525.525-.88 1.302-1.13 2.079-.256.795-.43 1.682-.541 2.507a19.055 19.055 0 0 0-.173 2.216c-.004.3.003.567.022.778.009.104.022.212.044.31.01.05.027.113.053.18.02.051.074.178.19.295.117.117.245.17.297.19.066.026.13.043.178.054.099.021.207.035.31.044.211.019.479.025.779.021.603-.008 1.39-.06 2.216-.172.825-.112 1.711-.285 2.507-.54.776-.25 1.553-.606 2.079-1.132a4.825 4.825 0 0 0 1.327-4.333c1.209-.6 2.622-1.618 4.121-3.135 1.694-1.714 3.709-3.835 5.093-5.75.688-.952 1.258-1.904 1.538-2.764.274-.842.334-1.826-.384-2.544-.72-.719-1.703-.672-2.555-.401-.865.275-1.822.843-2.776 1.53-1.92 1.384-4.036 3.407-5.733 5.125-1.5 1.518-2.53 2.896-3.132 4.114Zm1.44 2.388a3.33 3.33 0 0 1 0 4.71c-.271.27-.774.537-1.478.763-.684.22-1.477.378-2.248.482-.769.104-1.495.152-2.035.16a9.247 9.247 0 0 1-.351-.002 9.182 9.182 0 0 1-.002-.35c.007-.542.055-1.267.16-2.036.104-.771.261-1.564.481-2.249.227-.703.493-1.206.764-1.478a3.33 3.33 0 0 1 4.71 0Z"></path></svg>`
        const bugDarkSVG = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><path fill="white" d="M7.72.22a.75.75 0 0 1 1.06 0l1.204 1.203A4.98 4.98 0 0 1 12 1c.717 0 1.4.151 2.016.423L15.22.22a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-.971.972A4.991 4.991 0 0 1 17 6v1.104a2.755 2.755 0 0 1 1.917 1.974l1.998-.999a.75.75 0 0 1 .67 1.342L19 10.714V13.5l3.25.003a.75.75 0 0 1 0 1.5L19 15.001V16c0 .568-.068 1.134-.204 1.686l.04.018 2.75 1.375a.75.75 0 1 1-.671 1.342l-2.638-1.319A6.998 6.998 0 0 1 12 23a6.998 6.998 0 0 1-6.197-3.742l-2.758 1.181a.752.752 0 0 1-1.064-.776.752.752 0 0 1 .474-.602l2.795-1.199A6.976 6.976 0 0 1 5 16v-.996H1.75a.75.75 0 0 1 0-1.5H5v-2.79L2.415 9.42a.75.75 0 0 1 .67-1.342l1.998.999A2.756 2.756 0 0 1 7 7.104V6a4.99 4.99 0 0 1 1.69-3.748l-.97-.972a.75.75 0 0 1 0-1.06ZM6.5 9.75V16a5.5 5.5 0 1 0 11 0V9.75c0-.69-.56-1.25-1.25-1.25h-8.5c-.69 0-1.25.56-1.25 1.25ZM8.5 7h7V6a3.5 3.5 0 1 0-7 0Z"></path></svg>`
        const bugLightSVG = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><path d="M7.72.22a.75.75 0 0 1 1.06 0l1.204 1.203A4.98 4.98 0 0 1 12 1c.717 0 1.4.151 2.016.423L15.22.22a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-.971.972A4.991 4.991 0 0 1 17 6v1.104a2.755 2.755 0 0 1 1.917 1.974l1.998-.999a.75.75 0 0 1 .67 1.342L19 10.714V13.5l3.25.003a.75.75 0 0 1 0 1.5L19 15.001V16c0 .568-.068 1.134-.204 1.686l.04.018 2.75 1.375a.75.75 0 1 1-.671 1.342l-2.638-1.319A6.998 6.998 0 0 1 12 23a6.998 6.998 0 0 1-6.197-3.742l-2.758 1.181a.752.752 0 0 1-1.064-.776.752.752 0 0 1 .474-.602l2.795-1.199A6.976 6.976 0 0 1 5 16v-.996H1.75a.75.75 0 0 1 0-1.5H5v-2.79L2.415 9.42a.75.75 0 0 1 .67-1.342l1.998.999A2.756 2.756 0 0 1 7 7.104V6a4.99 4.99 0 0 1 1.69-3.748l-.97-.972a.75.75 0 0 1 0-1.06ZM6.5 9.75V16a5.5 5.5 0 1 0 11 0V9.75c0-.69-.56-1.25-1.25-1.25h-8.5c-.69 0-1.25.56-1.25 1.25ZM8.5 7h7V6a3.5 3.5 0 1 0-7 0Z"></path></svg>`
        const versionDarkSVG = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><path fill="white" d="M13 7.5a1 1 0 1 1-2 0 1 1 0 0 1 2 0Zm-3 3.75a.75.75 0 0 1 .75-.75h1.5a.75.75 0 0 1 .75.75v4.25h.75a.75.75 0 0 1 0 1.5h-3a.75.75 0 0 1 0-1.5h.75V12h-.75a.75.75 0 0 1-.75-.75Z"></path><path fill="white" d="M12 1c6.075 0 11 4.925 11 11s-4.925 11-11 11S1 18.075 1 12 5.925 1 12 1ZM2.5 12a9.5 9.5 0 0 0 9.5 9.5 9.5 9.5 0 0 0 9.5-9.5A9.5 9.5 0 0 0 12 2.5 9.5 9.5 0 0 0 2.5 12Z"></path></svg>`
        const versionLightSVG = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><path d="M13 7.5a1 1 0 1 1-2 0 1 1 0 0 1 2 0Zm-3 3.75a.75.75 0 0 1 .75-.75h1.5a.75.75 0 0 1 .75.75v4.25h.75a.75.75 0 0 1 0 1.5h-3a.75.75 0 0 1 0-1.5h.75V12h-.75a.75.75 0 0 1-.75-.75Z"></path><path d="M12 1c6.075 0 11 4.925 11 11s-4.925 11-11 11S1 18.075 1 12 5.925 1 12 1ZM2.5 12a9.5 9.5 0 0 0 9.5 9.5 9.5 9.5 0 0 0 9.5-9.5A9.5 9.5 0 0 0 12 2.5 9.5 9.5 0 0 0 2.5 12Z"></path></svg>`

        // colors
        const passedBackgroundBorderColor = "#97bd61";
        const passedBackgroundColor = "rgba(151, 189, 97, 0.7)";
        const skippedBackgroundBorderColor = "#fed84f";
        const skippedBackgroundColor = "rgba(254, 216, 79, 0.7)";
        const failedBackgroundBorderColor = "#ce3e01";
        const failedBackgroundColor = "rgba(206, 62, 1, 0.7)";
        const greyBackgroundBorderColor = "#0f172a";
        const greyBackgroundColor = "rgba(33, 37, 41, 0.7)";
        const graphFontSize = 12;

        // base bar config
        const barConfig = {
            borderSkipped: false,
            borderRadius: {
                topLeft: 8,
                topRight: 8,
                bottomLeft: 8,
                bottomRight: 8,
            },
        }
        const passedConfig = {
            backgroundColor: passedBackgroundColor,
            borderColor: passedBackgroundBorderColor,
            ...barConfig,
        }
        const failedConfig = {
            backgroundColor: failedBackgroundColor,
            borderColor: failedBackgroundBorderColor,
            ...barConfig,
        }
        const skippedConfig = {
            backgroundColor: skippedBackgroundColor,
            borderColor: skippedBackgroundBorderColor,
            ...barConfig,
        }
        // base line config
        const lineConfig = {
            tension: 0.1,
            pointRadius: 4,
            pointHoverRadius: 6
        }
        // data label background rectangle config
        const dataLabelConfig = {
            color: "#eee",
            backgroundColor: function (context) {
                return "rgba(0, 0, 0, 0.6)";
            },
            borderRadius: 4,
            padding: 3,
            align: "center",
            anchor: "center",
            font: {
                size: graphFontSize,
            },
        }

        // prepare input data
        const runs = decode_and_decompress("placeholder_runs").sort((a, b) => new Date(a.run_start).getTime() - new Date(b.run_start).getTime());
        const suites = decode_and_decompress("placeholder_suites").sort((a, b) => new Date(a.run_start).getTime() - new Date(b.run_start).getTime());
        const tests = decode_and_decompress("placeholder_tests").sort((a, b) => new Date(a.run_start).getTime() - new Date(b.run_start).getTime());
        const keywords = decode_and_decompress("placeholder_keywords").sort((a, b) => new Date(a.run_start).getTime() - new Date(b.run_start).getTime());

        function decode_and_decompress(base64Str) {
            const compressedData = Uint8Array.from(atob(base64Str), c => c.charCodeAt(0));
            const decompressedData = pako.inflate(compressedData, { to: 'string' });
            return JSON.parse(decompressedData);
        }

        var message_config = '"placeholder_message_config"'
        var filteredAmount = "placeholder_amount"
        var filteredAmountDefault = 0
        const use_logs = "placeholder_use_logs"
        const server = "placeholder_server"
        if (!message_config.includes("placeholder_message_config")) { message_config = JSON.parse(message_config) }

        // filtered data vars
        var filteredRuns;
        var filteredSuites;
        var filteredTests;
        var filteredKeywords;

        // vars to keep track of certain global settings
        var overviewGraphs = [];
        var selectedRunSetting = '';
        var selectedTagSetting = '';
        var useRunTags = false;
        var useSuitePathsSuiteSection = false;
        var useSuitePathsTestSection = false;
        var ignoreSkips = false; // test most flaky graph
        var ignoreSkipsRecent = false; // test recent most flaky graph
        var onlyFailedFolders = false; // suite folder donut
        var showingRunTags = false; // used to keep track if the runtags popup is showing and determine if it should be closed when clicked outside
        var inFullscreen = false; // used to keep track if fullscreen view is being shown
        var showDateLabels = true; // used to keep track of global date/run_start label setting
        var showLegends = true; // used to keep track of global legend setting
        var showAliases = false; // used to keep track of global alias setting
        var showMilliseconds = false; // used to keep track of global millisecond setting
        var heatMapHourAll = true; // used to keep track of the heatmap setting, is it set to an hour or all
        var previousFolder = ""; // used to update the suite folder donut to the previous folder with the button
        var lastScrollY = 0; // used to scroll back to where you were previously
        var maxGraphsPerRow = 2; // used to determine how many graphs to show per row
        var animationEnabled = true; // used to determine if animations are on or off
        var animationDuration = 1500; // used to set the milliseconds it takes to animate the graphs
        var menuOverview = false; // used to set the dashboard to overview mode
        var menuCompare = false; // used to set the dashboard to compare mode
        var menuDashboard = true; // used to set the dashboard to normal mode

        // add datalabels plugin
        Chart.register(ChartDataLabels);

        // add items in hide modal
        const hideSections = [
            "Run Statistics",
            "Suite Statistics",
            "Test Statistics",
            "Keyword Statistics",
            "Compare Statistics",
        ]
        const graphMetadata = [
            {
                key: "runStatistics",
                label: "Run Statistics",
                defaultType: "percentages",
                viewOptions: ["Percentages", "Line", "Amount"],
                hasFullscreenButton: true,
                information: `This graph shows the statistics of the runs represented in multiple formats:
- Percentages: Displays the distribution of passed/failed/skipped tests per run, where 100% equals all tests combined.
- Amount: Displays the actual number of passed/failed/skipped tests per run.
- Line: Displays the same data but over a time axis, useful for spotting failure patterns on specific dates or times.`,
                html: `<div class="col canvas pb-5" id="runStatisticsCanvas">
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                        id="runStatisticsGraphPercentages">Percentage</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="runStatisticsGraphAmount">Amount</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="runStatisticsGraphLine">Timeline</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                        id="runStatisticsFullscreen">Fullscreen</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="runStatisticsClose" hidden>Close</button>
                    <button type="button" class="btn btn-outline-light btn-sm mb-3 mt-1 information"
                        id="runStatisticsInformation"></button>
                    <canvas id="runStatisticsGraph"></canvas>
                </div>`,
            },
            {
                key: "runDonut",
                label: "Run Donut",
                defaultType: "donut",
                viewOptions: ["Donut"],
                hasFullscreenButton: true,
                information: `This graph contains two donut charts:
- The first donut displays the percentage of passed, failed, and skipped tests for the most recent run..
- The second donut displays the total percentage of passed, failed, and skipped tests across all runs`,
                html: `<div class="col canvas pb-5" id="runDonutCanvas">
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="runDonutGraphDonut">Donut</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="runDonutFullscreen">Fullscreen</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="runDonutClose" hidden>Close</button>
                    <button type="button" class="btn btn-outline-light btn-sm mb-3 mt-1 information"
                        id="runDonutInformation"></button>
                    <div class="row donut-charts w-100 h-100">
                        <div class="col-md-6 w-50 h-100">
                            <canvas id="runDonutGraph" class="w-100 h-100"></canvas>
                        </div>
                        <div class="col-md-6 w-50 h-100">
                            <canvas id="runDonutTotalGraph" class="w-100 h-100"></canvas>
                        </div>
                    </div>
                </div>`,
            },
            {
                key: "runDonutTotal",
                label: "Run Donut Total",
                defaultType: "donut",
                viewOptions: ["Donut"],
                hasFullscreenButton: false,
                information: null,
            },
            {
                key: "runStats",
                label: "Run Stats",
                defaultType: "stats",
                viewOptions: ["Stats"],
                hasFullscreenButton: true,
                information: `This section provides key statistics:
- Executed: Total counts of Runs, Suites, Tests, and Keywords that have been executed.
- Unique Tests: Displays the number of distinct test cases across all runs.
- Outcomes: Total Passed, Failed, and Skipped tests, including their percentages relative to the full test set.
- Duration: Displays the cumulative runtime of all runs, the average runtime per run, and the average duration of individual tests.
- Pass Rate: Displays the average run-level pass rate, helping evaluate overall reliability over time.`,
                html: `<div class="col canvas pb-5" id="runStatsCanvas">
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="runStatsGraphStats">Stats</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="runStatsFullscreen">Fullscreen</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="runStatsClose" hidden>Close</button>
                    <button type="button" class="btn btn-outline-light btn-sm mb-3 mt-1 information"
                        id="runStatsInformation"></button>
                    <div class="w-100 h-100">
                        <div class="d-flex flex-column justify-content-between h-75 mt-5">
                            <div class="row text-center mb-4">
                                <div class="col">
                                    <div class="stat-label">Executed Runs</div>
                                    <div class="stat-value blue-text" id="totalRuns"></div>
                                </div>
                                <div class="col">
                                    <div class="stat-label">Executed Suites</div>
                                    <div class="stat-value blue-text" id="totalSuites"></div>
                                </div>
                                <div class="col">
                                    <div class="stat-label">Executed Tests</div>
                                    <div class="stat-value blue-text" id="totalTests"></div>
                                </div>
                                <div class="col">
                                    <div class="stat-label">Executed Keywords</div>
                                    <div class="stat-value blue-text" id="totalKeywords"></div>
                                </div>
                            </div>
                            <div class="row text-center mb-4">
                                <div class="col">
                                    <div class="stat-label">Unique Tests</div>
                                    <div class="stat-value white-text" id="totalUniqueTests"></div>
                                </div>
                                <div class="col">
                                    <div class="stat-label">Passed</div>
                                    <div class="stat-value green-text" id="totalPassed"></div>
                                </div>
                                <div class="col">
                                    <div class="stat-label">Failed</div>
                                    <div class="stat-value red-text" id="totalFailed"></div>
                                </div>
                                <div class="col">
                                    <div class="stat-label">Skipped</div>
                                    <div class="stat-value yellow-text" id="totalSkipped"></div>
                                </div>
                            </div>
                            <div class="row text-center">
                                <div class="col">
                                    <div class="stat-label">Total Run Time</div>
                                    <div class="stat-value white-text" id="totalRunTime"></div>
                                </div>
                                <div class="col">
                                    <div class="stat-label">Avg Run Time</div>
                                    <div class="stat-value white-text" id="averageRunTime"></div>
                                </div>
                                <div class="col">
                                    <div class="stat-label">Avg Test Time</div>
                                    <div class="stat-value white-text" id="averageTestTime"></div>
                                </div>
                                <div class="col">
                                    <div class="stat-label">Avg Run Pass Rate</div>
                                    <div class="stat-value green-text" id="averagePassRate"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>`,
            },
            {
                key: "runDuration",
                label: "Run Duration",
                defaultType: "line",
                viewOptions: ["Bar", "Line"],
                hasFullscreenButton: true,
                information: `This graph visualizes the duration of each run:
- Bar: Displays total run durations represented as vertical bars.
- Line: Displays the same data but over a time axis for clearer trend analysis.`,
                html: `<div class="col canvas pb-5" id="runDurationCanvas">
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="runDurationGraphBar">Bar</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="runDurationGraphLine">Line</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                        id="runDurationFullscreen">Fullscreen</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="runDurationClose" hidden>Close</button>
                    <button type="button" class="btn btn-outline-light btn-sm mb-3 mt-1 information"
                        id="runDurationInformation"></button>
                    <canvas id="runDurationGraph"></canvas>
                </div>`,
            },
            {
                key: "runHeatmap",
                label: "Run Heatmap",
                defaultType: "heatmap",
                viewOptions: ["Heatmap"],
                hasFullscreenButton: true,
                information: `This graph visualizes a heatmap of when tests are executed the most:
- All: Displays how many tests ran during the hours or minutes of the week days.
- Passed: Displays the same data but only passed tests.
- Failed: Displays the same data but only failed tests.
- Skipped: Displays the same data but only skipped tests.
- Hour: Displays only that hour so you get insights per minute.`,
                html: `<div class="col canvas pb-5" id="runHeatmapCanvas">
                    <div class="btn-group">
                        <label class="form-check-label mb-3" for="heatMapTestType">Status</label>
                    </div>
                    <div class="btn-group">
                        <select class="form-select form-select-sm" id="heatMapTestType" style="margin-bottom:12px">
                            <option value="All">All</option>
                            <option value="Passed">Passed</option>
                            <option value="Failed">Failed</option>
                            <option value="Skipped">Skipped</option>
                        </select>
                    </div>
                    <div class="btn-group">
                        <label class="form-check-label mb-3" for="heatMapHour">Hour</label>
                    </div>
                    <div class="btn-group">
                        <select class="form-select form-select-sm" id="heatMapHour" style="margin-bottom:12px">
                            <option value="All">All</option>
                            <option value="0">00:00</option>
                            <option value="1">01:00</option>
                            <option value="2">02:00</option>
                            <option value="3">03:00</option>
                            <option value="4">04:00</option>
                            <option value="5">05:00</option>
                            <option value="6">06:00</option>
                            <option value="7">07:00</option>
                            <option value="8">08:00</option>
                            <option value="9">09:00</option>
                            <option value="10">10:00</option>
                            <option value="11">11:00</option>
                            <option value="12">12:00</option>
                            <option value="13">13:00</option>
                            <option value="14">14:00</option>
                            <option value="15">15:00</option>
                            <option value="16">16:00</option>
                            <option value="17">17:00</option>
                            <option value="18">18:00</option>
                            <option value="19">19:00</option>
                            <option value="20">20:00</option>
                            <option value="21">21:00</option>
                            <option value="22">22:00</option>
                            <option value="23">23:00</option>
                        </select>
                    </div>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="runHeatmapGraphHeatmap">Heatmap</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="runHeatmapFullscreen">Fullscreen</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="runHeatmapClose" hidden>Close</button>
                    <button type="button" class="btn btn-outline-light btn-sm mb-3 mt-1 information"
                        id="runHeatmapInformation"></button>
                    <canvas id="runHeatmapGraph"></canvas>
                </div>`,
            },
            {
                key: "runTable",
                label: "Run Table",
                defaultType: "table",
                viewOptions: ["Table"],
                hasFullscreenButton: false,
                information: null,
                html: `<div class="col" id="runTableCanvas">
                    <table class="table table-striped" id="runTable"></table>
                </div>`,
            },
            {
                key: "suiteFolderDonut",
                label: "Suite Folder Donut",
                defaultType: "donut",
                viewOptions: ["Donut"],
                hasFullscreenButton: true,
                information: `This graph contains two donut charts:
- The first donut displays the top-level folders of the suites and the amount of tests each folder contains.
- The second donut displays the same folder structure but only for the most recent run and only includes failed tests.
- Clicking on a folder updates the chart with the subfolders/suites it contains.
- Navigating folders also updates Suite Statistics and Suite Duration.
- "Go Up" navigates to the parent folder level.
- "Only Failed Folders" filters to show only folders with failing tests.`,
                html: `<div class="col canvas pb-5" id="suiteFolderDonutCanvas">
                    <div class="btn-group me-1">
                        <label class="form-check-label mb-3" for="onlyFailedFolders">Only Failed Folders</label>
                    </div>
                    <div class="btn-group form-switch me-1">
                        <input class="form-check-input mb-3" type="checkbox" role="switch" id="onlyFailedFolders">
                    </div>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="suiteFolderDonutGoUp">Go Up</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                        id="suiteFolderDonutGraphDonut">Donut</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                        id="suiteFolderDonutFullscreen">Fullscreen</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="suiteFolderDonutClose"
                        hidden>Close</button>
                    <button type="button" class="btn btn-outline-light btn-sm mb-3 mt-1 information"
                        id="suiteFolderDonutInformation"></button>
                    <div class="row donut-charts w-100 h-100">
                        <div class="col-md-6 w-50 h-100">
                            <canvas id="suiteFolderDonutGraph" class="w-100 h-100"></canvas>
                        </div>
                        <div class="col-md-6 w-50 h-100">
                            <canvas id="suiteFolderFailDonutGraph" class="w-100 h-100"></canvas>
                        </div>
                    </div>
                </div>`,
            },
            {
                key: "suiteFolderFailDonut",
                label: "Suite Folder Fail Donut",
                defaultType: "donut",
                viewOptions: ["Donut"],
                hasFullscreenButton: false,
                information: null,
            },
            {
                key: "suiteStatistics",
                label: "Suite Statistics",
                defaultType: "percentages",
                viewOptions: ["Percentages", "Line", "Amount"],
                hasFullscreenButton: true,
                information: `This graph provides suite-level statistics in three formats:
- Percentages: Displays the passed/failed/skipped rate of test suites per run.
- Amount: Displays the actual number of passed/failed/skipped suites per run.
- Line: Displays the same data but over a time axis, useful for spotting failure patterns on specific dates or times.`,
                html: `<div class="col canvas pb-5" id="suiteStatisticsCanvas">
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                        id="suiteStatisticsGraphPercentages">Percentage</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                        id="suiteStatisticsGraphAmount">Amount</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                        id="suiteStatisticsGraphLine">Timeline</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                        id="suiteStatisticsFullscreen">Fullscreen</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="suiteStatisticsClose"
                        hidden>Close</button>
                    <button type="button" class="btn btn-outline-light btn-sm mb-3 mt-1 information"
                        id="suiteStatisticsInformation"></button>
                    <canvas id="suiteStatisticsGraph"></canvas>
                </div>`,
            },
            {
                key: "suiteDuration",
                label: "Suite Duration",
                defaultType: "line",
                viewOptions: ["Bar", "Line"],
                hasFullscreenButton: true,
                information: `This graph visualizes the duration of each suite:
- Bar: Displays total suite durations represented as vertical bars.
- Line: Displays the same data but over a time axis for clearer trend analysis.`,
                html: `<div class="col canvas pb-5" id="suiteDurationCanvas">
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="suiteDurationGraphBar">Bar</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="suiteDurationGraphLine">Line</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                        id="suiteDurationFullscreen">Fullscreen</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="suiteDurationClose" hidden>Close</button>
                    <button type="button" class="btn btn-outline-light btn-sm mb-3 mt-1 information"
                        id="suiteDurationInformation"></button>
                    <canvas id="suiteDurationGraph"></canvas>
                </div>`,
            },
            {
                key: "suiteMostFailed",
                label: "Suite Most Failed",
                defaultType: "bar",
                viewOptions: ["Bar", "Timeline"],
                hasFullscreenButton: true,
                information: `This graph highlights the test suites with the most failures:
- Bar: Displays suites ranked by number of failures represented as vertical bars.
- Timeline: Displays when failures occurred to identify clustering over time.
- The default view shows the Top 10 most failed suites; fullscreen expands this to the Top 50.`,
                html: `<div class="col canvas pb-5" id="suiteMostFailedCanvas">
                    <div id="suiteMostFailedVertical">
                        <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="suiteMostFailedGraphBar">Bar</button>
                        <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                            id="suiteMostFailedGraphTimeline">Timeline</button>
                        <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                            id="suiteMostFailedFullscreen">Fullscreen</button>
                        <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="suiteMostFailedClose"
                            hidden>Close</button>
                        <button type="button" class="btn btn-outline-light btn-sm mb-3 mt-1 information"
                            id="suiteMostFailedInformation"></button>
                        <canvas id="suiteMostFailedGraph"></canvas>
                    </div>
                </div>`,
            },
            {
                key: "suiteTable",
                label: "Suite Table",
                defaultType: "table",
                viewOptions: ["Table"],
                hasFullscreenButton: false,
                information: null,
                html: `<div class="col" id="suiteTableCanvas">
                    <table class="table table-striped" id="suiteTable"></table>
                </div>`,
            },
            {
                key: "testStatistics",
                label: "Test Statistics",
                defaultType: "timeline",
                viewOptions: ["Timeline"],
                hasFullscreenButton: true,
                information: `This graph displays the statistics of the tests in a timeline format.`,
                html: `<div class="col canvas canvas-vertical" id="testStatisticsCanvas">
                    <div id="testStatisticsVertical">
                        <div class="btn-group me-1">
                            <label class="form-check-label mb-3" for="testOnlyChanges">Only Changes</label>
                        </div>
                        <div class="btn-group form-switch me-1">
                            <input class="form-check-input mb-3" type="checkbox" role="switch" id="testOnlyChanges">
                        </div>
                        <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                            id="testStatisticsGraphTimeline">Timeline</button>
                        <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                            id="testStatisticsFullscreen">Fullscreen</button>
                        <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="testStatisticsClose"
                            hidden>Close</button>
                        <button type="button" class="btn btn-outline-light btn-sm mb-3 mt-1 information"
                            id="testStatisticsInformation"></button>
                        <canvas id="testStatisticsGraph"></canvas>
                    </div>
                </div>`,
            },
            {
                key: "testDuration",
                label: "Test Duration",
                defaultType: "line",
                viewOptions: ["Bar", "Line"],
                hasFullscreenButton: true,
                information: `This graph tracks how long individual tests take to run:
- Bar: Displays test durations represented as vertical bars.
- Line: Displays the same data but over a time axis for clearer trend analysis.`,
                html: `<div class="col canvas pb-5" id="testDurationCanvas">
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="testDurationGraphBar">Bar</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="testDurationGraphLine">Line</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                        id="testDurationFullscreen">Fullscreen</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="testDurationClose" hidden>Close</button>
                    <button type="button" class="btn btn-outline-light btn-sm mb-3 mt-1 information"
                        id="testDurationInformation"></button>
                    <canvas id="testDurationGraph"></canvas>
                </div>`,
            },
            {
                key: "testDurationDeviation",
                label: "Test Duration Deviation",
                defaultType: "bar",
                viewOptions: ["Bar"],
                hasFullscreenButton: true,
                information: `This boxplot chart displays how much test durations deviate from the average, represented as vertical bars.
It helps identify tests with inconsistent execution times, which might be flaky or worth investigating`,
                html: `<div class="col canvas pb-5" id="testDurationDeviationCanvas">
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                        id="testDurationDeviationGraphBar">Boxplot</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                        id="testDurationDeviationFullscreen">Fullscreen</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="testDurationDeviationClose"
                        hidden>Close</button>
                    <button type="button" class="btn btn-outline-light btn-sm mb-3 mt-1 information"
                        id="testDurationDeviationInformation"></button>
                    <canvas id="testDurationDeviationGraph"></canvas>
                </div>`,
            },
            {
                key: "testMessages",
                label: "Test Messages",
                defaultType: "timeline",
                viewOptions: ["Bar", "Timeline"],
                hasFullscreenButton: true,
                information: `This graph presents the most frequently occurring fail/skip test messages:
- Bar: Displays messages ranked by number of occurrences represented as vertical bars.
- Timeline: Displays when those messages occurred to reveal noisy periods or problem spikes.
- The regular view shows the Top 10 most frequent messages; fullscreen mode expands this to the Top 50.
- To generalize messages (e.g., group similar messages), use the -m/--messageconfig option in the CLI (--help or README).`,
                html: `<div class="col canvas pb-5" id="testMessagesCanvas">
                    <div id="testMessagesVertical">
                        <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="testMessagesGraphBar">Bar</button>
                        <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                            id="testMessagesGraphTimeline">Timeline</button>
                        <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                            id="testMessagesFullscreen">Fullscreen</button>
                        <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="testMessagesClose"
                            hidden>Close</button>
                        <button type="button" class="btn btn-outline-light btn-sm mb-3 mt-1 information"
                            id="testMessagesInformation"></button>
                        <canvas id="testMessagesGraph"></canvas>
                    </div>
                </div>`,
            },
            {
                key: "testMostFlaky",
                label: "Test Most Flaky",
                defaultType: "timeline",
                viewOptions: ["Bar", "Timeline"],
                hasFullscreenButton: true,
                information: `This graph identifies the flakiest tests based on status flips (passed/failed/skipped):
- Bar: Displays tests ranked by frequency of status changes represented as vertical bars.
- Timeline: Displays when the status changes occurred across runs.
- The regular view shows the Top 10 flaky tests; fullscreen mode expands the list to the Top 50.
- "Ignore Skips" filters to only count passed/failed as status flips and not skips.`,
                html: `<div class="col canvas pb-5" id="testMostFlakyCanvas">
                    <div id="testMostFlakyVertical">
                        <div class="btn-group me-1">
                            <label class="form-check-label mb-3" for="ignoreSkips">Ignore Skips</label>
                        </div>
                        <div class="btn-group form-switch me-1">
                            <input class="form-check-input mb-3" type="checkbox" role="switch" id="ignoreSkips">
                        </div>
                        <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="testMostFlakyGraphBar">Bar</button>
                        <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                            id="testMostFlakyGraphTimeline">Timeline</button>
                        <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                            id="testMostFlakyFullscreen">Fullscreen</button>
                        <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="testMostFlakyClose"
                            hidden>Close</button>
                        <button type="button" class="btn btn-outline-light btn-sm mb-3 mt-1 information"
                            id="testMostFlakyInformation"></button>
                        <canvas id="testMostFlakyGraph"></canvas>
                    </div>
                </div>`,
            },
            {
                key: "testRecentMostFlaky",
                label: "Test Recent Most Flaky",
                defaultType: "timeline",
                viewOptions: ["Bar", "Timeline"],
                hasFullscreenButton: true,
                information: `This graph identifies the most recently flaky tests based on status flips:
- Bar: Displays tests ranked by frequency of recent status changes represented as vertical bars.
- Timeline: Displays when the status changes occurred across runs.
- The most recent flaky tests are listed first.
- The regular view shows the Top 10; fullscreen mode expands the list to the Top 50.
- "Ignore Skips" filters to only count passed/failed as status flips and not skips.`,
                html: `<div class="col canvas pb-5" id="testRecentMostFlakyCanvas">
                    <div id="testRecentMostFlakyVertical">
                        <div class="btn-group me-1">
                            <label class="form-check-label mb-3" for="ignoreSkipsRecent">Ignore Skips</label>
                        </div>
                        <div class="btn-group form-switch me-1">
                            <input class="form-check-input mb-3" type="checkbox" role="switch" id="ignoreSkipsRecent">
                        </div>
                        <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                            id="testRecentMostFlakyGraphBar">Bar</button>
                        <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                            id="testRecentMostFlakyGraphTimeline">Timeline</button>
                        <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                            id="testRecentMostFlakyFullscreen">Fullscreen</button>
                        <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="testRecentMostFlakyClose"
                            hidden>Close</button>
                        <button type="button" class="btn btn-outline-light btn-sm mb-3 mt-1 information"
                            id="testRecentMostFlakyInformation"></button>
                        <canvas id="testRecentMostFlakyGraph"></canvas>
                    </div>
                </div>`,
            },
            {
                key: "testMostFailed",
                label: "Test Most Failed",
                defaultType: "timeline",
                viewOptions: ["Bar", "Timeline"],
                hasFullscreenButton: true,
                information: `This graph lists the most failed tests overall:
- Bar: Displays tests ranked by total number of failures represented as vertical bars.
- Timeline: Displays when failures occurred across runs.
- The regular view shows the Top 10 most failed tests; fullscreen mode expands the list to the Top 50.`,
                html: `<div class="col canvas pb-5" id="testMostFailedCanvas">
                    <div id="testMostFailedVertical">
                        <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="testMostFailedGraphBar">Bar</button>
                        <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                            id="testMostFailedGraphTimeline">Timeline</button>
                        <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                            id="testMostFailedFullscreen">Fullscreen</button>
                        <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="testMostFailedClose"
                            hidden>Close</button>
                        <button type="button" class="btn btn-outline-light btn-sm mb-3 mt-1 information"
                            id="testMostFailedInformation"></button>
                        <canvas id="testMostFailedGraph"></canvas>
                    </div>
                </div>`,
            },
            {
                key: "testRecentMostFailed",
                label: "Test Recent Most Failed",
                defaultType: "timeline",
                viewOptions: ["Bar", "Timeline"],
                hasFullscreenButton: true,
                information: `This graph lists the most recently failed tests:
- Bar: Displays tests ranked by number of recent failures represented as vertical bars.
- Timeline: Displays when failures occurred across runs.
- The most recently failed tests are listed first.
- The regular view shows the Top 10; fullscreen mode expands the list to the Top 50.`,
                html: `<div class="col canvas pb-5" id="testRecentMostFailedCanvas">
                    <div id="testRecentMostFailedVertical">
                        <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                            id="testRecentMostFailedGraphBar">Bar</button>
                        <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                            id="testRecentMostFailedGraphTimeline">Timeline</button>
                        <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                            id="testRecentMostFailedFullscreen">Fullscreen</button>
                        <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="testRecentMostFailedClose"
                            hidden>Close</button>
                        <button type="button" class="btn btn-outline-light btn-sm mb-3 mt-1 information"
                            id="testRecentMostFailedInformation"></button>
                        <canvas id="testRecentMostFailedGraph"></canvas>
                    </div>
                </div>`,
            },
            {
                key: "testTable",
                label: "Test Table",
                defaultType: "table",
                viewOptions: ["Table"],
                hasFullscreenButton: false,
                information: null,
                html: `<div class="col" id="testTableCanvas">
                    <table class="table table-striped" id="testTable"></table>
                </div>`,
            },
            {
                key: "keywordStatistics",
                label: "Keyword Statistics",
                defaultType: "percentages",
                viewOptions: ["Percentages", "Line", "Amount"],
                hasFullscreenButton: true,
                information: `This graph presents keyword execution results in multiple formats:
- Percentages: Displays the distribution of passed/failed/skipped statuses for each keyword per run.
- Amount: Displays raw counts of each status per run.
- Line: Displays the same data but over a time axis.`,
                html: `<div class="col canvas pb-5" id="keywordStatisticsCanvas">
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                        id="keywordStatisticsGraphPercentages">Percentage</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                        id="keywordStatisticsGraphAmount">Amount</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                        id="keywordStatisticsGraphLine">Timeline</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                        id="keywordStatisticsFullscreen">Fullscreen</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="keywordStatisticsClose"
                        hidden>Close</button>
                    <button type="button" class="btn btn-outline-light btn-sm mb-3 mt-1 information"
                        id="keywordStatisticsInformation"></button>
                    <canvas id="keywordStatisticsGraph"></canvas>
                </div>`,
            },
            {
                key: "keywordTimesRun",
                label: "Keyword Times Run",
                defaultType: "line",
                viewOptions: ["Bar", "Line"],
                hasFullscreenButton: true,
                information: `This graph shows how frequently each keyword was executed:
- Bar: Displays times run per keyword represented as vertical bars.
- Line: Displays the same data but over a time axis.`,
                html: `<div class="col canvas pb-5" id="keywordTimesRunCanvas">
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="keywordTimesRunGraphBar">Bar</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="keywordTimesRunGraphLine">Line</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                        id="keywordTimesRunFullscreen">Fullscreen</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="keywordTimesRunClose"
                        hidden>Close</button>
                    <button type="button" class="btn btn-outline-light btn-sm mb-3 mt-1 information"
                        id="keywordTimesRunInformation"></button>
                    <canvas id="keywordTimesRunGraph"></canvas>
                </div>`,
            },
            {
                key: "keywordTotalDuration",
                label: "Keyword Total Duration",
                defaultType: "line",
                viewOptions: ["Bar", "Line"],
                hasFullscreenButton: true,
                information: `This graph visualizes total execution time of keywords:
- Bar: Displays the cumulative time each keyword ran during each run represented as vertical bars.
- Line: Displays the same data but over a time axis.`,
                html: `<div class="col canvas pb-5" id="keywordTotalDurationCanvas">
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                        id="keywordTotalDurationGraphBar">Bar</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                        id="keywordTotalDurationGraphLine">Line</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                        id="keywordTotalDurationFullscreen">Fullscreen</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="keywordTotalDurationClose"
                        hidden>Close</button>
                    <button type="button" class="btn btn-outline-light btn-sm mb-3 mt-1 information"
                        id="keywordTotalDurationInformation"></button>
                    <canvas id="keywordTotalDurationGraph"></canvas>
                </div>`,
            },
            {
                key: "keywordAverageDuration",
                label: "Keyword Average Duration",
                defaultType: "line",
                viewOptions: ["Bar", "Line"],
                hasFullscreenButton: true,
                information: `This graph shows the average execution time per keyword:
- Bar: Displays the average duration for each keyword represented as vertical bars.
- Line: Displays the same data but over a time axis.`,
                html: `<div class="col canvas pb-5" id="keywordAverageDurationCanvas">
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                        id="keywordAverageDurationGraphBar">Bar</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                        id="keywordAverageDurationGraphLine">Line</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                        id="keywordAverageDurationFullscreen">Fullscreen</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="keywordAverageDurationClose"
                        hidden>Close</button>
                    <button type="button" class="btn btn-outline-light btn-sm mb-3 mt-1 information"
                        id="keywordAverageDurationInformation"></button>
                    <canvas id="keywordAverageDurationGraph"></canvas>
                </div>`,
            },
            {
                key: "keywordMinDuration",
                label: "Keyword Min Duration",
                defaultType: "line",
                viewOptions: ["Bar", "Line"],
                hasFullscreenButton: true,
                information: `This graph shows the fastest observed execution time for each keyword per run:
- Bar: Displays minimum durations represented as vertical bars.
- Line: Displays the same data but over a time axis.`,
                html: `<div class="col canvas pb-5" id="keywordMinDurationCanvas">
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="keywordMinDurationGraphBar">Bar</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                        id="keywordMinDurationGraphLine">Line</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                        id="keywordMinDurationFullscreen">Fullscreen</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="keywordMinDurationClose"
                        hidden>Close</button>
                    <button type="button" class="btn btn-outline-light btn-sm mb-3 mt-1 information"
                        id="keywordMinDurationInformation"></button>
                    <canvas id="keywordMinDurationGraph"></canvas>
                </div>`,
            },
            {
                key: "keywordMaxDuration",
                label: "Keyword Max Duration",
                defaultType: "line",
                viewOptions: ["Bar", "Line"],
                hasFullscreenButton: true,
                information: `This graph shows the slowest observed execution time for each keyword per run:
- Bar: Displays maximum durations represented as vertical bars.
- Line: Displays the same data but over a time axis.`,
                html: `<div class="col canvas pb-5" id="keywordMaxDurationCanvas">
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="keywordMaxDurationGraphBar">Bar</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                        id="keywordMaxDurationGraphLine">Line</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                        id="keywordMaxDurationFullscreen">Fullscreen</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="keywordMaxDurationClose"
                        hidden>Close</button>
                    <button type="button" class="btn btn-outline-light btn-sm mb-3 mt-1 information"
                        id="keywordMaxDurationInformation"></button>
                    <canvas id="keywordMaxDurationGraph"></canvas>
                </div>`,
            },
            {
                key: "keywordMostFailed",
                label: "Keyword Most Failed",
                defaultType: "timeline",
                viewOptions: ["Bar", "Timeline"],
                hasFullscreenButton: true,
                information: `This graph lists the most failed keywords overall:
- Bar: Displays keywords ranked by total number of failures represented as vertical bars.
- Timeline: Displays when failures occurred across runs.
- The regular view shows the Top 10 most failed keywords; fullscreen mode expands the list to the Top 50.`,
                html: `<div class="col canvas pb-5" id="keywordMostFailedCanvas">
                    <div id="keywordMostFailedVertical">
                        <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                            id="keywordMostFailedGraphBar">Bar</button>
                        <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                            id="keywordMostFailedGraphTimeline">Timeline</button>
                        <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                            id="keywordMostFailedFullscreen">Fullscreen</button>
                        <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="keywordMostFailedClose"
                            hidden>Close</button>
                        <button type="button" class="btn btn-outline-light btn-sm mb-3 mt-1 information"
                            id="keywordMostFailedInformation"></button>
                        <canvas id="keywordMostFailedGraph"></canvas>
                    </div>
                </div>`,
            },
            {
                key: "keywordTable",
                label: "Keyword Table",
                defaultType: "table",
                viewOptions: ["Table"],
                hasFullscreenButton: false,
                information: null,
                html: `<div class="col" id="keywordTableCanvas">
                    <table class="table table-striped" id="keywordTable"></table>
                </div>`,
            },
            {
                key: "compareStatistics",
                label: "Compare Statistics",
                defaultType: "bar",
                viewOptions: ["Bar"],
                hasFullscreenButton: true,
                information: `This graph displays the overall statistics of the selected runs.`,
                html: `<div class="col canvas pb-5" id="compareStatisticsCanvas">
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="compareStatisticsGraphBar">Bar</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                        id="compareStatisticsFullscreen">Fullscreen</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="compareStatisticsClose"
                        hidden>Close</button>
                    <button type="button" class="btn btn-outline-light btn-sm mb-3 mt-1 information"
                        id="compareStatisticsInformation"></button>
                    <canvas id="compareStatisticsGraph"></canvas>
                </div>`,
            },
            {
                key: "compareTests",
                label: "Compare Tests",
                defaultType: "timeline",
                viewOptions: ["Timeline"],
                hasFullscreenButton: true,
                information: `This graph displays the statistics of the tests in a timeline format.`,
                html: `<div class="col canvas canvas-vertical" id="compareTestsCanvas">
                    <div id="compareTestsVertical">
                        <div class="btn-group me-1">
                            <label class="form-check-label mb-3" for="compareOnlyChanges">Only Changes</label>
                        </div>
                        <div class="btn-group form-switch me-1">
                            <input class="form-check-input mb-3" type="checkbox" role="switch" id="compareOnlyChanges">
                        </div>
                        <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                            id="compareTestsGraphTimeline">Timeline</button>
                        <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                            id="compareTestsFullscreen">Fullscreen</button>
                        <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="compareTestsClose"
                            hidden>Close</button>
                        <button type="button" class="btn btn-outline-light btn-sm mb-3 mt-1 information"
                            id="compareTestsInformation"></button>
                        <canvas id="compareTestsGraph"></canvas>
                    </div>
                </div>`,
            },
            {
                key: "compareSuiteDuration",
                label: "Compare Suite Duration",
                defaultType: "radar",
                viewOptions: ["Radar"],
                hasFullscreenButton: true,
                information: `This graph displays the duration per suite in a radar format.`,
                html: `<div class="col canvas pb-5" id="compareSuiteDurationCanvas">
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="compareSuiteDurationGraphRadar">Radar</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1"
                        id="compareSuiteDurationFullscreen">Fullscreen</button>
                    <button class="btn btn-outline-light btn-sm mb-3 mt-1" id="compareSuiteDurationClose"
                        hidden>Close</button>
                    <button type="button" class="btn btn-outline-light btn-sm mb-3 mt-1 information"
                        id="compareSuiteDurationInformation"></button>
                    <canvas id="compareSuiteDurationGraph"></canvas>
                </div>`,
            },
        ];

        // hideGraphs (contains all graphs that can be hidden or shown)
        const hideGraphs = graphMetadata
            .map(graph => graph.label)
            .filter(label => label !== "Run Donut Total" && label !== "Suite Folder Fail Donut");
        // fullscreenButtons (contains all graphs that have a fullscreen/close button)
        const fullscreenButtons = graphMetadata
            .filter(graph => graph.hasFullscreenButton)
            .map(graph => graph.key);
        // defaultGraphTypes (stored in localstorge like percentage, bar etc.)
        const defaultGraphTypes = {};
        graphMetadata.forEach(graph => {
            defaultGraphTypes[`${graph.key}GraphType`] = graph.defaultType;
        });
        // graphChangeButtons (adds the eventlisteners to the buttons ike percentage, bar, etc.)
        const excludeKeys = ["runDonutTotal", "suiteFolderFailDonut"];
        const graphChangeButtons = {};
        graphMetadata.forEach(graph => {
            if (!excludeKeys.includes(graph.key) && graph.type !== "Table") {
                const snakeKey = camelcase_to_underscore(graph.key);
                graphChangeButtons[snakeKey] = graph.viewOptions.join(',');
            }
        });
        // informationTitles (contains the text for the information popups for the graphs)
        const informationTitles = {};
        graphMetadata.forEach(graph => {
            if (graph.information) {
                informationTitles[`${graph.key}Information`] = graph.information;
            }
        });
        // graphVars
        const graphVars = graphMetadata.map(g => g.defaultType === "table" ? g.key : `${g.key}Graph`);
        graphVars.forEach(name => {
            window[name] = undefined;
        });

        // All possible button types
        const buttonTypes = ["Bar", "Line", "Timeline", "Percentages", "Amount", "Donut", "Stats", "Heatmap", "Radar"];

        // Run compare filter Id's
        const compareRunIds = ['compareRun1', 'compareRun2', 'compareRun3', 'compareRun4']

        /////////////////////////////
        // GENERIC SETUP FUNCTIONS //
        /////////////////////////////

        // function to update the theme when the button is clicked
        function toggle_theme() {
            if (document.documentElement.classList.contains("dark-mode")) {
                localStorage.setItem("theme", "light");
            } else {
                localStorage.setItem("theme", "dark");
            }
            setup_theme()
            setup_dasbhoard_graphs()
        }

        // theme function based on browser/machine color scheme
        function setup_theme() {
            Chart.defaults.font.size = graphFontSize;
            const html = document.documentElement;
            const toggle = document.getElementById("toggleTheme");

            function swap_button_classes(from1, to1, from2, to2) {
                // bootstrap buttons theme swap (outline and regular)
                document.querySelectorAll(from1).forEach(btn => {
                    btn.classList.remove(from1.replace('.', ''));
                    btn.classList.add(to1);
                });
                document.querySelectorAll(from2).forEach(btn => {
                    btn.classList.remove(from2.replace('.', ''));
                    btn.classList.add(to2);
                });
            }

            function set_light_mode() {
                // bootstrap dark-mode attribute
                document.getElementsByTagName("html")[0].setAttribute("data-bs-theme", "light");
                // bootstrap default color
                html.style.setProperty("--bs-body-bg", "#fff");
                // bootstrap buttons light -> dark
                swap_button_classes(".btn-outline-light", "btn-outline-dark", ".btn-light", "btn-dark");
                // chartjs default graph settings
                Chart.defaults.color = "#666";
                Chart.defaults.borderColor = "rgba(0,0,0,0.1)";
                Chart.defaults.backgroundColor = "rgba(0,0,0,0.1)";
                Chart.defaults.elements.line.borderColor = "rgba(0,0,0,0.1)";
                // menu icons
                document.getElementById('github').innerHTML = githubLightSVG;
                document.getElementById('settings').innerHTML = settingsLightSVG;
                document.getElementById('database').innerHTML = databaseLightSVG;
                document.getElementById('filters').innerHTML = filterLightSVG;
                document.getElementById('rflogo').innerHTML = rflogoLightSVG;
                document.getElementById('toggleTheme').innerHTML = moonSVG;
                document.getElementById('customizeView').innerHTML = brushLightSVG;
                document.getElementById('bug').innerHTML = bugLightSVG;
                document.getElementById('versionInformation').innerHTML = versionLightSVG;
                // menu theme
                document.getElementById('navigation').classList.remove('navbar-dark')
                document.getElementById('navigation').classList.add('navbar-light')
                // set toggle in correct state if not already, needed on first load
                if (toggle.checked) toggle.checked = false;
            }

            function set_dark_mode() {
                // bootstrap dark-mode attribute
                document.getElementsByTagName("html")[0].setAttribute("data-bs-theme", "dark");
                // bootstrap background color
                html.style.setProperty("--bs-body-bg", "rgba(30, 41, 59, 0.9)");
                // bootstrap buttons dark -> light
                swap_button_classes(".btn-outline-dark", "btn-outline-light", ".btn-dark", "btn-light");
                // chartjs default graph settings
                Chart.defaults.color = "#eee";
                Chart.defaults.borderColor = "rgba(255,255,255,0.1)";
                Chart.defaults.backgroundColor = "rgba(255,255,0,0.1)";
                Chart.defaults.elements.line.borderColor = "rgba(255,255,0,0.4)";
                // menu icons
                document.getElementById('github').innerHTML = githubDarkSVG;
                document.getElementById('settings').innerHTML = settingsDarkSVG;
                document.getElementById('database').innerHTML = databaseDarkSVG;
                document.getElementById('filters').innerHTML = filterDarkSVG;
                document.getElementById('rflogo').innerHTML = rflogoDarkSVG;
                document.getElementById('toggleTheme').innerHTML = sunSVG;
                document.getElementById('customizeView').innerHTML = brushDarkSVG;
                document.getElementById('bug').innerHTML = bugDarkSVG;
                document.getElementById('versionInformation').innerHTML = versionDarkSVG;
                // menu theme
                document.getElementById('navigation').classList.remove('navbar-light')
                document.getElementById('navigation').classList.add('navbar-dark')
                // set toggle in correct state if not already, needed on first load
                if (!toggle.checked) toggle.checked = true;
            }

            // detect theme preference
            const theme = localStorage.getItem("theme");
            const isDark = html.classList.contains("dark-mode");

            if (theme === "light") {
                if (isDark) html.classList.remove("dark-mode");
                set_light_mode();
            } else if (theme === "dark") {
                if (!isDark) html.classList.add("dark-mode");
                set_dark_mode();
            } else {
                // No theme in localStorage, fall back to system preference
                if (window.matchMedia("(prefers-color-scheme: dark)").matches) {
                    html.classList.add("dark-mode");
                    set_dark_mode();
                } else {
                    html.classList.remove("dark-mode");
                    set_light_mode();
                }
            }
        }

        // set default values
        function setup_stats() {
            document.getElementById("stats").innerHTML = `<table class='table table-striped'>
                <tr><td>Runs</td><td>${runs.length}</td></tr>
                <tr><td>Suites</td><td>${suites.length}</td></tr>
                <tr><td>Tests</td><td>${tests.length}</td></tr>
                <tr><td>Keywords</td><td>${keywords.length}</td></tr>
            </table>`

            filteredAmountDefault = filteredAmount
            document.getElementById("amount").value = filteredAmount
            if (server) {
                document.getElementById("openDashboard").hidden = false
            }
        }

        // function to setup all collapse buttons and icons
        function setup_collapsables() {
            // initialize all collapsables by adding the eventlisteners to the buttons
            const collapsables = document.querySelectorAll(".collapse-icon")
            for (let collapsable of collapsables) {
                update_collapse_button(collapsable);
                collapsable.addEventListener("click", () => {
                    update_collapse_button(collapsable);
                });
            }
            // function that handles the setting of the correct icon when expanding/collapsing sections
            function update_collapse_button(element) {
                if (element.className.includes("collapsed")) {
                    if (element.id.includes("Details")) {
                        element.innerHTML = arrowRight;
                    } else {
                        element.innerHTML = arrowRightSmall;
                    }
                } else {
                    if (element.id.includes("Details")) {
                        element.innerHTML = arrowDown;
                    } else {
                        element.innerHTML = arrowDownSmall;
                    }
                }
            }
        }

        // function to update the section (menu) buttons with the correct eventlisteners
        // also sets up the automatic highlighting of the section that is most visible in the top
        // 20-50% percent of the screen
        function setup_section_buttons() {
            const sectionButtons = [
                document.getElementById("runStatisticsSectionNav"),
                document.getElementById("suiteStatisticsSectionNav"),
                document.getElementById("testStatisticsSectionNav"),
                document.getElementById("keywordStatisticsSectionNav"),
            ];
            const sectionMap = {
                runStatisticsSection: sectionButtons[0],
                suiteStatisticsSection: sectionButtons[1],
                testStatisticsSection: sectionButtons[2],
                keywordStatisticsSection: sectionButtons[3],
            };

            sectionButtons.forEach(btn => btn.hidden = false); // unhide all
            sectionButtons.forEach(btn => btn.classList.remove('active')); // unhide all
            const sectionHide = JSON.parse(localStorage.getItem("sectionHide")); // get hidden sections
            sectionHide.forEach(hiddenSection => sectionMap[`${space_to_camelcase(hiddenSection)}Section`].hidden = true) // hide section menu buttons that should be hidden

            // fix button rounding after hiding the correct ones
            const buttons = Array.from(document.querySelectorAll(`#sectionIndicator .btn`))
                .filter(btn => !btn.hidden);

            buttons.forEach(btn => {
                btn.classList.remove('rounded-start-sm', 'rounded-end-sm');
            });
            if (buttons.length > 0) {
                buttons[0].classList.add('rounded-start-sm');
                buttons[buttons.length - 1].classList.add('rounded-end-sm');
            }

            const sections = Object.keys(sectionMap).map(id => document.getElementById(id));
            function update_active_section() {
                const viewportHeight = window.innerHeight;
                const viewportTop = viewportHeight * 0.2;
                const viewportBottom = viewportHeight * 0.5;
                let bestMatch = null;
                let bestMatchAmount = 0;
                sections.forEach(section => {
                    if (!section) return; // safety check
                    const rect = section.getBoundingClientRect();
                    // Calculate overlap in the 20%-50% viewport vertical range
                    const top = Math.max(rect.top, viewportTop);
                    const bottom = Math.min(rect.bottom, viewportBottom);
                    const overlap = bottom - top;
                    if (overlap > bestMatchAmount) {
                        bestMatch = section;
                        bestMatchAmount = overlap;
                    }
                });

                // Highlight the matching button
                sectionButtons.forEach(btn => btn.classList.remove("active"));
                if (bestMatch && sectionMap[bestMatch.id]) {
                    sectionMap[bestMatch.id].classList.add("active");
                }
            }

            window.addEventListener("scroll", update_active_section);
            // Initial call to set active on load
            update_active_section();

            sectionButtons.forEach(btn => {
                btn.addEventListener("click", () => {
                    const target = document.getElementById(btn.id.slice(0, -3));
                    if (target) {
                        const stickyTop = document.getElementById("navigation");
                        const stickyHeight = stickyTop ? stickyTop.offsetHeight : 0;
                        const targetTop = target.getBoundingClientRect().top + window.pageYOffset;
                        const top = targetTop < 200 ? 0 : targetTop - stickyHeight - 8; // exception for the section at the top, scroll to 0
                        window.scrollTo({
                            top: top,
                            behavior: "auto"
                        });
                    }
                });
            });
        }

        // function to fill the information icons with the correct data
        function setup_information_icons() {
            const informationButtons = document.querySelectorAll(".information")
            for (let button of informationButtons) {
                button.innerHTML = informationSVG;
                const id = button.id;
                var title = informationTitles[id];
                if (id == 'overviewStatisticsInformation') continue;
                if (id == 'versionInformation') continue;
                button.setAttribute('data-title', title)
            }
        }

        // function to add a spinner for slow loads
        function setup_spinner(hide) {
            if (hide) {
                $("#loading").fadeOut(100)
                $("#overviewStatisticsSection").fadeIn()
                $("#runStatisticsSection").fadeIn()
                $("#suiteStatisticsSection").fadeIn()
                $("#testStatisticsSection").fadeIn()
                $("#keywordStatisticsSection").fadeIn()
                $("#compareStatisticsSection").fadeIn()
            } else {
                $("#overviewStatisticsSection").hide()
                $("#runStatisticsSection").hide()
                $("#suiteStatisticsSection").hide()
                $("#testStatisticsSection").hide()
                $("#keywordStatisticsSection").hide()
                $("#compareStatisticsSection").hide()
                $("#loading").show();
            }
        }

        // function to convert to camelcase
        function space_to_camelcase(string) {
            return string.replace(/(?:^\w|[A-Z]|\b\w)/g, function (word, index) {
                return index === 0 ? word.toLowerCase() : word.toUpperCase();
            }).replace(/\s+/g, "");
        }

        // function to convert to camelcase from underscores
        function underscore_to_camelcase(str) {
            return str.replace(/_(.)/g, (match, group) => group.toUpperCase());
        }

        // function to convert camelcose to underscores
        function camelcase_to_underscore(str) {
            return str
                .replace(/([A-Z]+)/g, "_$1")     // Prefix all capital groups with _
                .replace(/^_/, "")               // Remove leading underscore if it appears
                .toLowerCase();                  // Convert everything to lowercase
        }

        // function to convert a date object to the desired string format
        function format_date_to_string(date) {
            const pad = (n) => n.toString().padStart(2, "0");
            const year = date.getFullYear();
            const month = pad(date.getMonth() + 1); // Months are 0-indexed
            const day = pad(date.getDate());
            const hours = pad(date.getHours());
            const minutes = pad(date.getMinutes());
            const seconds = pad(date.getSeconds());
            return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
        }

        // function to transform an output.xml path to a log.html path
        function transform_file_path(filePath) {
            const normalizedPath = filePath.replace(/\\/g, "/");
            const pathSegments = normalizedPath.split("/");
            const filename = pathSegments.pop();
            const updatedFilename = filename.replace(/output/g, "log").replace(/\.xml$/i, ".html");
            const updatedPath = [...pathSegments, updatedFilename].join("/");
            return filePath.includes("\\") ? updatedPath.replace(/\//g, "\\") : updatedPath;
        }

        // function used to combine paths to open the correct log file, used in combination with a file server
        function combine_paths(baseUrlStr, relativePath) {
            const baseUrl = new URL(baseUrlStr);
            const baseParts = baseUrl.pathname.split("/").filter(Boolean);
            const relParts = relativePath.replaceAll("\\", "/").split("/").filter(Boolean);
            // Find the first matching folder name from the relative path in the base path
            let match = null;
            for (let i = 0; i < relParts.length; i++) {
                const folder = relParts[i];
                const baseMatchIndex = baseParts.lastIndexOf(folder);
                if (baseMatchIndex !== -1) {
                    match = { baseIndex: baseMatchIndex, relIndex: i };
                    break;
                }
            }

            let combinedParts;
            if (match) {
                const baseSlice = baseParts.slice(0, match.baseIndex);
                const relSlice = relParts.slice(match.relIndex);
                combinedParts = [...baseSlice, ...relSlice];
            } else {
                combinedParts = relParts;
            }

            // Resolve "." and ".."
            const resolvedParts = [];
            for (const part of combinedParts) {
                if (part === ".") continue;
                if (part === "..") {
                    if (resolvedParts.length > 0) resolvedParts.pop();
                } else {
                    resolvedParts.push(part);
                }
            }

            return baseUrl.origin + "/" + resolvedParts.join("/");
        }

        // function to update the localstorage and graphs for the suitepath switches
        function update_switch_local_storage(id, state, firstLoad = false) {
            const storageState = JSON.parse(localStorage.getItem(id));
            if (firstLoad) {
                if (storageState) {
                    window[id] = storageState;
                    document.getElementById(id).checked = true;
                }
            } else {
                localStorage.setItem(id, JSON.stringify(state));
            }
        }

        // function to get a higher folder path based on the full_path or partial full_path provided
        function get_next_folder_level(fullPath, currentPath) {
            const fullParts = fullPath.split(".");
            const currentParts = currentPath.split(".");
            if (
                currentParts.length < fullParts.length &&
                fullParts.slice(0, currentParts.length).join(".") === currentPath
            ) {
                return fullParts.slice(0, currentParts.length + 1).join(".");
            }
            return currentPath;
        }

        //////////////////////////////
        // CUSTOMIZE VIEW FUNCTIONS //
        //////////////////////////////

        // function to update the arrows in the customize modal
        function setup_customize_view_arrow_eventlisteners() {
            // function to move the items from showing to hidden
            function move_items(fromId, toId) {
                const fromBox = document.getElementById(fromId);
                const toBox = document.getElementById(toId);
                const selectedItems = fromBox.querySelectorAll(".active");
                const fromStorage = JSON.parse(localStorage.getItem(fromId));
                const toStorage = JSON.parse(localStorage.getItem(toId));

                for (let item of selectedItems) {
                    const val = item.children[0].innerText;
                    if (toId.includes("Hide")) {
                        if (!toStorage.includes(val)) toStorage.push(val);
                        const identifier = val.split(" ")[0];
                        if (toId.includes("section")) disable_graphs_in_customize_view(true, identifier);
                    } else {
                        const index = fromStorage.indexOf(val);
                        if (index !== -1) fromStorage.splice(index, 1);
                        const identifier = val.split(" ")[0];
                        if (toId.includes("section")) disable_graphs_in_customize_view(false, identifier);
                    }
                }
                localStorage.setItem(fromId, JSON.stringify(fromStorage));
                localStorage.setItem(toId, JSON.stringify(toStorage));
                selectedItems.forEach(item => {
                    item.classList.remove("active");
                    if (toId === "graphShow") {
                        const section = item.children[0].innerText.split(" ")[0];
                        const listItems = document.getElementById("graphShow").querySelectorAll(".hideItem");
                        let lastMatchingItem = Array.from(listItems).reverse().find(li => {
                            return li.children[0].innerText.startsWith(section);
                        }) || listItems[listItems.length - 1];
                        lastMatchingItem?.after(item);
                    } else {
                        toBox.appendChild(item);
                    }
                });
            }

            // Map the arrow actions and associated operations
            const arrowMappings = {
                "sectionRight": { from: "sectionShow", to: "sectionHide", content: arrowRight },
                "sectionLeft": { from: "sectionHide", to: "sectionShow", content: arrowLeft },
                "graphRight": { from: "graphShow", to: "graphHide", content: arrowRight },
                "graphLeft": { from: "graphHide", to: "graphShow", content: arrowLeft }
            };

            // Initialize arrows with their respective functionality and content
            for (let arrow in arrowMappings) {
                const { from, to, content } = arrowMappings[arrow];
                // Update button content based on direction
                update_arrow_button(arrow, content);
                // Add event listener to each arrow button
                document.getElementById(arrow).addEventListener("click", () => {
                    move_items(from, to);
                });
            }

            // Function to update arrow button content
            function update_arrow_button(id, content) {
                document.getElementById(id).innerHTML = content;
            }
        }

        // function to handle the setting of the localstorge for customized view
        function setup_customize_view_local_storage() {
            const adminDefaults = {
                sectionHide: "placeholder_admin_section_hide",
                sectionShow: "placeholder_admin_section_show",
                graphHide: "placeholder_admin_graph_hide",
                graphShow: "placeholder_admin_graph_show"
            };

            const keys = Object.keys(adminDefaults);

            // Helper: Convert legacy "'item1','item2'" string into array
            function migrate_legacy_string(value) {
                if (typeof value === "string") {
                    return value.split(",")
                        .map(v => v.trim().replace(/^'+|'+$/g, "")) // strip surrounding single quotes
                        .filter(v => v !== "");
                }
                return [];
            }

            // Handle migration or init of all keys
            keys.forEach(key => {
                let raw = localStorage.getItem(key);

                if (raw === null) {
                    // Not present at all  store empty array
                    localStorage.setItem(key, JSON.stringify([]));
                } else {
                    try {
                        // Try parsing as JSON array (new format)
                        const parsed = JSON.parse(raw);
                        if (!Array.isArray(parsed)) throw new Error("Not an array");
                    } catch (error) {
                        // Legacy format  migrate to array
                        const migrated = migrate_legacy_string(raw);
                        localStorage.setItem(key, JSON.stringify(migrated));
                    }
                }
            });

            // Apply admin defaults only if all are still empty arrays
            const allEmpty = keys.every(key => {
                const val = JSON.parse(localStorage.getItem(key));
                return Array.isArray(val) && val.length === 0;
            });

            // Actually set the defaults, either admin or normal
            if (allEmpty) {
                if (
                    !adminDefaults.sectionHide.includes("placeholder_admin") &&
                    (
                        adminDefaults.sectionShow.length > 0 ||
                        adminDefaults.graphShow.length > 0 ||
                        adminDefaults.sectionHide.length > 0 ||
                        adminDefaults.graphHide.length > 0
                    )
                ) {
                    // the admin defaults are set
                    keys.forEach(key => {
                        localStorage.setItem(key, JSON.stringify(adminDefaults[key]));
                    });
                } else {
                    // there is no admin defaults so use the regular defaults
                    localStorage.setItem("sectionShow", JSON.stringify(hideSections))
                    localStorage.setItem("graphShow", JSON.stringify(hideGraphs))
                }
            }

            var storedTypes = localStorage.getItem("graphTypes");
            if (!storedTypes) {
                localStorage.setItem("graphTypes", JSON.stringify(defaultGraphTypes));
                storedTypes = defaultGraphTypes;
            } else {
                storedTypes = JSON.parse(storedTypes);
                // Below exception is created to handle problems when switching between old versions without graphs
                // to newer versions with additional graphs. The view is completely reset to add all graphs again.
                const storedKeys = Object.keys(storedTypes);
                const defaultKeys = Object.keys(defaultGraphTypes);
                const mismatch = storedKeys.length !== defaultKeys.length ||
                    defaultKeys.some(key => !(key in storedTypes));
                if (mismatch) {
                    for (const key in defaultGraphTypes) {
                        if (!(key in storedTypes)) {
                            storedTypes[key] = defaultGraphTypes[key];
                        }
                    }
                    localStorage.setItem("sectionHide", JSON.stringify([]));
                    localStorage.setItem("graphHide", JSON.stringify([]));
                    localStorage.setItem("sectionShow", JSON.stringify(hideSections));
                    localStorage.setItem("graphShow", JSON.stringify(hideGraphs));
                    localStorage.setItem("graphTypes", JSON.stringify(defaultGraphTypes));
                }
            }
        }

        // function to setup the highlighting when rendering the dashboard
        function setup_button_highlighting() {
            var storedTypes = JSON.parse(localStorage.getItem("graphTypes"));
            for (const key in storedTypes) {
                window[key] = storedTypes[key];
                update_button_selection(key.replace("GraphType", ""), storedTypes[key]);
            }
        }

        // function to update the localstorage of the graphtypes
        function update_graph_type(graph, type) {
            const storedTypes = JSON.parse(localStorage.getItem("graphTypes") || "{}");
            storedTypes[graph] = type;
            localStorage.setItem("graphTypes", JSON.stringify(storedTypes));
            window[graph] = type;
        }

        // function to change which button is highlighted styling wise
        function update_button_selection(camelButtonName, graphType) {
            buttonTypes.forEach(button => {
                const buttonId = `${camelButtonName}Graph${button}`;
                const element = document.getElementById(buttonId);
                if (element) {
                    const isDark = document.documentElement.classList.contains("dark-mode");
                    const outlineClass = isDark ? "btn-outline-light" : "btn-outline-dark";
                    const isActive = button.toLowerCase() === graphType;
                    element.classList.toggle("active", isActive);
                    element.classList.remove("btn-outline-light", "btn-outline-dark");
                    element.classList.add(outlineClass);
                }
            });
        }

        // create the modal with the correct layout based on localstorage
        function setup_customize_view_content() {
            const graphShow = JSON.parse(localStorage.getItem("graphShow"));
            const graphHide = JSON.parse(localStorage.getItem("graphHide"));
            const sectionShow = JSON.parse(localStorage.getItem("sectionShow"));
            const sectionHide = JSON.parse(localStorage.getItem("sectionHide"));

            let graphShowItems = "", graphHideItems = "";
            let sectionShowItems = "", sectionHideItems = "";

            const hideItem = `<li class="hideItem list-group-item list-group-item-action d-flex {type}">
                <div class="hideItemText">{value}</div>
                <button class="btn btn-sm moveUp"></button>
                <button class="btn btn-sm moveDown"></button>
                </li>`

            for (let graph of [...graphShow, ...graphHide]) {
                const element = hideItem.replaceAll("{value}", graph).replaceAll("{type}", "graph");
                if (graphHide.includes(graph)) {
                    graphHideItems += element;
                } else {
                    graphShowItems += element;
                }
            }
            document.getElementById("graphShow").innerHTML = graphShowItems;
            document.getElementById("graphHide").innerHTML = graphHideItems;

            for (let section of [...sectionShow, ...sectionHide]) {
                const element = hideItem.replaceAll("{value}", section).replaceAll("{type}", "section");
                if (sectionHide.includes(section)) {
                    const identifier = section.split(" ")[0];
                    disable_graphs_in_customize_view(true, identifier);
                    sectionHideItems += element;
                } else {
                    sectionShowItems += element;
                }
            }
            document.getElementById("sectionShow").innerHTML = sectionShowItems;
            document.getElementById("sectionHide").innerHTML = sectionHideItems;

            document.querySelectorAll(".graph .moveUp, .section .moveUp").forEach(item => {
                item.innerHTML = arrowUpVerySmall;
                item.addEventListener("click", function (event) {
                    const before = $(this).parent().prev();
                    if (before.length) $(this).parent().insertBefore(before);
                    event.stopPropagation();
                });
            });

            document.querySelectorAll(".graph .moveDown, .section .moveDown").forEach(item => {
                item.innerHTML = arrowDownVerySmall;
                item.addEventListener("click", function (event) {
                    const after = $(this).parent().next();
                    if (after.length) $(this).parent().insertAfter(after);
                    event.stopPropagation();
                });
            });

            document.querySelectorAll(".hideItem").forEach(item => {
                item.addEventListener("click", function () {
                    this.classList.toggle("active");
                });
            });
        }

        // function to add/remove disabled to the graphs in the customize view popup
        function disable_graphs_in_customize_view(disable, identifier) {
            const relatedGraphs1 = document.getElementById("graphShow").querySelectorAll(".hideItemText")
            const relatedGraphs2 = document.getElementById("graphHide").querySelectorAll(".hideItemText")
            const relatedGraphs = [...relatedGraphs1, ...relatedGraphs2]
            for (const graph of relatedGraphs) {
                if (graph.innerText.startsWith(identifier)) {
                    if (disable) {
                        graph.parentElement.classList.add("disabled");
                    } else {
                        graph.parentElement.classList.remove("disabled");
                    }
                }
            }
        }

        // function to sync current order to localStorage
        function update_customize_view_local_storage() {
            const sectionOrder = Array.from(document.getElementById("sectionShow").querySelectorAll(".hideItem"))
                .map(item => item.children[0].innerText);
            const graphOrder = Array.from(document.getElementById("graphShow").querySelectorAll(".hideItem"))
                .map(item => item.children[0].innerText);
            localStorage.setItem("sectionShow", JSON.stringify(sectionOrder));
            localStorage.setItem("graphShow", JSON.stringify(graphOrder));
        }

        /////////////////////////////
        // EVENTLISTENER FUNCTIONS //
        /////////////////////////////

        // function to create customized view eventlisteners
        function setup_settings_eventlisteners() {
            // function to catch the closing of the modal by not clicking a button
            $("#customizeModal").on("hidden.bs.modal", function () {
                update_customize_view_local_storage();
                setup_data_and_graphs();
            });
            // function to catch the closing of the filter modal
            $("#filtersModal").on("hidden.bs.modal", function () {
                setup_data_and_graphs();
            });
            // function to catch the closing of the settings modal
            $("#settingsModal").on("hidden.bs.modal", function () {
                setup_data_and_graphs();
            });
            // function to create setting toggle handlers
            function create_toggle_handler({ key, elementId, globalVarName, isCheckbox = true, isNumber = false }) {
                return function (load = false) {
                    let storage = JSON.parse(localStorage.getItem(key));
                    const element = document.getElementById(elementId);

                    if (load) {
                        if (isNumber) {
                            if (storage) window[globalVarName] = parseInt(storage);
                            element.value = window[globalVarName];
                        } else {
                            if (typeof storage === "boolean") window[globalVarName] = storage;
                            element.checked = window[globalVarName];
                        }
                    } else {
                        if (isNumber) {
                            window[globalVarName] = parseInt(element.value);
                        } else {
                            window[globalVarName] = !window[globalVarName];
                            element.checked = window[globalVarName];
                        }
                        localStorage.setItem(key, JSON.stringify(window[globalVarName]));
                    }
                };
            }

            const toggle_labels = create_toggle_handler({
                key: "showDateLabels",
                elementId: "toggleLabels",
                globalVarName: "showDateLabels"
            });

            const toggle_legends = create_toggle_handler({
                key: "showLegends",
                elementId: "toggleLegends",
                globalVarName: "showLegends"
            });

            const toggle_aliases = create_toggle_handler({
                key: "showAliases",
                elementId: "toggleAliases",
                globalVarName: "showAliases"
            });

            const toggle_milliseconds = create_toggle_handler({
                key: "showMilliseconds",
                elementId: "toggleMilliseconds",
                globalVarName: "showMilliseconds"
            });

            const toggle_graph_limit = create_toggle_handler({
                key: "maxGraphsPerRow",
                elementId: "toggleMaxGraphsPerRow",
                globalVarName: "maxGraphsPerRow",
                isCheckbox: false,
                isNumber: true
            });

            const toggle_animations = create_toggle_handler({
                key: "animationEnabled",
                elementId: "toggleAnimations",
                globalVarName: "animationEnabled"
            });

            const toggle_animation_duration = create_toggle_handler({
                key: "animationDuration",
                elementId: "toggleAnimationDuration",
                globalVarName: "animationDuration",
                isCheckbox: false,
                isNumber: true
            });

            // Initial load
            toggle_labels(true);
            toggle_legends(true);
            toggle_aliases(true);
            toggle_milliseconds(true);
            toggle_graph_limit(true);
            toggle_animations(true);
            toggle_animation_duration(true);

            // Add event listeners
            document.getElementById("toggleLabels").addEventListener("click", () => toggle_labels());
            document.getElementById("toggleLegends").addEventListener("click", () => toggle_legends());
            document.getElementById("toggleAliases").addEventListener("click", () => toggle_aliases());
            document.getElementById("toggleMilliseconds").addEventListener("click", () => toggle_milliseconds());
            document.getElementById("toggleMaxGraphsPerRow").addEventListener("change", () => toggle_graph_limit());
            document.getElementById("toggleAnimations").addEventListener("click", () => toggle_animations());
            document.getElementById("toggleAnimationDuration").addEventListener("change", () => toggle_animation_duration());
            document.getElementById("toggleTheme").addEventListener("click", () => toggle_theme());

            // remove the entire customized view configuration
            document.getElementById("resetGraphConfig").addEventListener("click", function () {
                localStorage.setItem("sectionHide", JSON.stringify([]));
                localStorage.setItem("graphHide", JSON.stringify([]));
                localStorage.setItem("sectionShow", JSON.stringify(hideSections));
                localStorage.setItem("graphShow", JSON.stringify(hideGraphs));
                setup_customize_view_content();
            });
        }

        function update_menu(item) {
            localStorage.setItem('menu', item);
            menuOverview = item === 'menuOverview';
            menuDashboard = item === 'menuDashboard';
            menuCompare = item === 'menuCompare';
            ['menuOverview', 'menuDashboard', 'menuCompare'].forEach(id => {
                document.getElementById(id).classList.toggle('active', id === item);
            });
            setup_data_and_graphs(true);
        }

        // function to setup the menu eventlisteners
        function setup_menu_eventlisteners() {
            document.getElementById('menuOverview').addEventListener('click', () => update_menu('menuOverview'))
            document.getElementById('menuDashboard').addEventListener('click', () => update_menu('menuDashboard'))
            document.getElementById('menuCompare').addEventListener('click', () => update_menu('menuCompare'))

            update_menu(localStorage.getItem('menu') || 'menuDashboard');
        }

        // function to setup eventlisteners for filter buttons
        function setup_eventlisteners_filter_buttons() {
            // has to be added after the creation of the sections and graphs
            document.getElementById("suiteFolderDonutGoUp").addEventListener("click", function () {
                function remove_last_folder(path) {
                    const parts = path.split(".");
                    parts.pop();
                    return parts.length > 0 ? parts.join('.') : "";
                }
                const folder = remove_last_folder(previousFolder)
                if (previousFolder == "" && folder == "") { return }
                create_suite_folder_donut_graph(folder)
            });
            // eventlisteners for fullscreen buttons
            for (let fullscreenButton of fullscreenButtons) {
                document.getElementById(`${fullscreenButton}Fullscreen`).addEventListener("click", () => {
                    lastScrollY = window.scrollY
                    inFullscreen = !inFullscreen;
                    $("#navigation").hide();
                    document.getElementById(`${fullscreenButton}Canvas`).classList.add("fullscreen");
                    document.getElementById(`${fullscreenButton}Close`).hidden = false;
                    document.getElementById(`${fullscreenButton}Fullscreen`).hidden = true;
                    document.body.classList.add("lock-scroll");
                    window[`create_${camelcase_to_underscore(fullscreenButton)}_graph`]();
                    if (fullscreenButton == "runDonut") {
                        create_run_donut_total_graph();
                    }
                    if (fullscreenButton == "suiteFolderDonut") {
                        create_suite_folder_fail_donut_graph();
                    }
                });
                document.getElementById(`${fullscreenButton}Close`).addEventListener("click", () => {
                    inFullscreen = !inFullscreen;
                    $("#navigation").show();
                    document.getElementById(`${fullscreenButton}Canvas`).classList.remove("fullscreen");
                    document.getElementById(`${fullscreenButton}Close`).hidden = true;
                    document.getElementById(`${fullscreenButton}Fullscreen`).hidden = false;
                    document.body.classList.remove("lock-scroll");
                    window[`create_${camelcase_to_underscore(fullscreenButton)}_graph`]();
                    if (fullscreenButton == "runDonut") {
                        create_run_donut_total_graph();
                    }
                    if (fullscreenButton == "suiteFolderDonut") {
                        create_suite_folder_fail_donut_graph();
                    }
                    window.scrollTo({
                        top: lastScrollY,
                        behavior: "auto"
                    });
                });
            }
        }

        // function to setup eventlisteners for changing the graph view buttons
        function setup_eventlisteners_graph_view_buttons() {
            // ignore skip button eventlisteners
            document.getElementById("ignoreSkips").addEventListener("change", () => {
                ignoreSkips = !ignoreSkips;
                create_test_most_flaky_graph();
            });
            document.getElementById("ignoreSkipsRecent").addEventListener("change", () => {
                ignoreSkipsRecent = !ignoreSkipsRecent;
                create_test_recent_most_flaky_graph();
            });
            document.getElementById("onlyFailedFolders").addEventListener("change", () => {
                onlyFailedFolders = !onlyFailedFolders;
                create_suite_folder_donut_graph("");
            });
            document.getElementById("heatMapTestType").addEventListener("change", () => {
                create_run_heatmap_graph();
            });
            document.getElementById("heatMapHour").addEventListener("change", () => {
                heatMapHourAll = document.getElementById("heatMapHour").value == "All" ? true : false;
                create_run_heatmap_graph();
            });
            document.getElementById("testOnlyChanges").addEventListener("change", () => {
                create_test_statistics_graph();
            });
            document.getElementById("compareOnlyChanges").addEventListener("change", () => {
                create_compare_tests_graph();
            });


            function handle_graph_change_type_button_click(graphChangeButton, graphType, camelButtonName) {
                // Dynamically trigger the graph creation function
                update_graph_type(`${camelButtonName}GraphType`, graphType)
                window[`create_${graphChangeButton}_graph`]();
                if (graphChangeButton == 'run_donut') { create_run_donut_total_graph(); }
                if (graphChangeButton == 'suite_folder_donut') { create_suite_folder_fail_donut_graph(); }
                // Update the UI to enable/disable buttons accordingly
                update_button_selection(camelButtonName, graphType)
            }

            function add_graph_eventlisteners(graphChangeButton, buttonTypes) {
                const camelButtonName = underscore_to_camelcase(graphChangeButton);
                const graphTypes = buttonTypes.split(",");
                graphTypes.forEach((graphType, index) => {
                    const buttonId = `${camelButtonName}Graph${graphType}`;
                    if (document.getElementById(buttonId)) {
                        document.getElementById(buttonId).addEventListener("click", () => {
                            handle_graph_change_type_button_click(graphChangeButton, graphType.toLowerCase(), camelButtonName);
                        });
                    }
                });
            }

            // Iterate over the graphChangeButtons object to attach event listeners
            Object.entries(graphChangeButtons).forEach(([graphChangeButton, buttonTypes]) => {
                add_graph_eventlisteners(graphChangeButton, buttonTypes);
            });
        }

        // function to handle the eventlisteners for all filter options in the sections
        function setup_eventlisteners_section_filter_buttons() {
            update_switch_local_storage("useRunTags", useRunTags, true);
            document.getElementById("useRunTags").addEventListener("click", function () {
                useRunTags = !useRunTags
                update_switch_local_storage("useRunTags", useRunTags);
                create_overview_statistics_graphs();
            });
            document.getElementById("overviewDurationPercentage").addEventListener("change", function () {
                create_overview_statistics_graphs();
            });
            function show_checkboxes() {
                const checkboxes = document.getElementById("checkboxes");
                showingRunTags = !showingRunTags;
                checkboxes.style.display = showingRunTags ? "block" : "none";
            }
            document.getElementById("selectRunTags").addEventListener("click", show_checkboxes);
            document.getElementById("resetFilters").addEventListener("click", function () {
                document.getElementById("runs").value = "All";
                const tagElements = document.getElementById("runTag").getElementsByTagName("input");
                for (const input of tagElements) {
                    input.checked = false;
                    if (input.id == "All") input.checked = true;
                }
                document.getElementById("amount").value = filteredAmountDefault;
                document.getElementById("metadata").value = "All";
                setup_lowest_highest_dates(runs);
            });
            document.getElementById("suiteSelectSuites").addEventListener("change", () => {
                create_suite_duration_graph();
                create_suite_statistics_graph();
            });
            document.getElementById("useSuitePathsSuiteSection").addEventListener("change", () => {
                useSuitePathsSuiteSection = !useSuitePathsSuiteSection;
                update_switch_local_storage("useSuitePathsSuiteSection", useSuitePathsSuiteSection);
                setup_suites_in_suite_select();
                create_suite_statistics_graph();
                create_suite_duration_graph();
                create_suite_most_failed_graph();
            });
            // update the local storage for the suite path buttons on first load
            update_switch_local_storage("useSuitePathsSuiteSection", useSuitePathsSuiteSection, true);
            document.getElementById("resetSuiteFolder").addEventListener("click", () => {
                create_suite_folder_donut_graph("");
            });
            document.getElementById("suiteSelectTests").addEventListener("change", () => {
                setup_testtags_in_select();
                setup_tests_in_select();
                create_test_statistics_graph();
                create_test_duration_graph();
                create_test_duration_deviation_graph();
            });
            document.getElementById("useSuitePathsTestSection").addEventListener("change", () => {
                useSuitePathsTestSection = !useSuitePathsTestSection;
                update_switch_local_storage("useSuitePathsTestSection", useSuitePathsTestSection);
                setup_suites_in_test_select();
                create_test_statistics_graph();
                create_test_duration_graph();
                create_test_duration_deviation_graph();
                create_test_messages_graph();
                create_test_most_flaky_graph();
                create_test_recent_most_flaky_graph();
                create_test_most_failed_graph();
                create_test_recent_most_failed_graph();
            });
            // update the local storage for the suite path buttons on first load
            update_switch_local_storage("useSuitePathsTestSection", useSuitePathsTestSection, true);
            document.getElementById("testTagsSelect").addEventListener("change", () => {
                setup_tests_in_select();
                create_test_statistics_graph();
                create_test_duration_graph();
                create_test_duration_deviation_graph();
            });
            document.getElementById("testSelect").addEventListener("change", () => {
                create_test_statistics_graph();
                create_test_duration_graph();
                create_test_duration_deviation_graph();
            });
            document.getElementById("keywordSelect").addEventListener("change", () => {
                create_keyword_statistics_graph();
                create_keyword_times_run_graph();
                create_keyword_total_duration_graph();
                create_keyword_average_duration_graph();
                create_keyword_min_duration_graph();
                create_keyword_max_duration_graph();
            });
            const checkboxesElement = document.getElementById("checkboxes");
            const runTagsSelectElement = document.getElementById("selectRunTags");
            // listen for click events on body to hide the run checkboxes when clicking outside of the select/checkboxes elements
            document.body.addEventListener("click", function (event) {
                if (showingRunTags == true && !checkboxesElement.contains(event.target) && !runTagsSelectElement.contains(event.target)) {
                    show_checkboxes()
                }
            });
            // compare filters
            compareRunIds.forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.addEventListener('change', () => {
                        create_compare_statistics_graph();
                        create_compare_tests_graph();
                        create_compare_suite_duration_graph();
                    });
                }
            });
        }

        /////////////////////////////////////
        // FILTER BUTTON CONTENT FUNCTIONS //
        /////////////////////////////////////

        // function to setup run amount filter maximum
        function setup_run_amount_filter() {
            document.getElementById("amount").setAttribute("max", runs.length)
        }

        // function that initializes the from date/time and to date/time selection boxes in the filters
        function setup_lowest_highest_dates() {
            var dates = [];
            for (run of runs) {
                dates.push(new Date(run.run_start));
            }
            if (dates.length == 0) {
                document.getElementById("fromDate").value = "1900-01-01";
                document.getElementById("fromTime").value = "00:00";
                document.getElementById("toDate").value = "9999-12-31";
                document.getElementById("toTime").value = "23:59";
                return
            }
            var lowest = new Date(Math.min.apply(null, dates));
            var highest = new Date(Math.max.apply(null, dates));
            var tzoffset = new Date().getTimezoneOffset() * 60000;
            lowest = new Date(new Date(lowest - tzoffset).getTime() + -1 * 60000); // this is to account for seconds in the initial filter value
            highest = new Date(new Date(highest - tzoffset).getTime() + 1 * 60000); // this is to account for seconds in the initial filter value
            lowest.setTime(lowest.getTime() - 1 * 60 * 60 * 1000) // minus 1 hour to account for possible daylight saving time switches of 1 hour!
            highest.setTime(highest.getTime() + 1 * 60 * 60 * 1000) // plus 1 hour to account for possible daylight saving time switches of 1 hour!
            document.getElementById("fromDate").value = lowest.toISOString().split("T")[0];
            document.getElementById("fromTime").value = lowest.toISOString().split("T")[1].substring(0, 5);
            document.getElementById("toDate").value = highest.toISOString().split("T")[0];
            document.getElementById("toTime").value = highest.toISOString().split("T")[1].substring(0, 5);
        }

        // function to setup metadata filter if there is metadata in the data
        function setup_metadata_filter() {
            var metadataItems = new Set();
            for (const run of runs) {
                if (!run.metadata) continue;
                const jsonStr = run.metadata.replace(/'/g, '"');
                const parsed = JSON.parse(jsonStr);
                parsed.forEach(item => metadataItems.add(item));
            }
            metadataItems = Array.from(metadataItems).sort((a, b) => a.localeCompare(b, undefined, { sensitivity: 'base' }));
            const metadataFilter = document.getElementById("metadataFilter");
            if (metadataItems.length > 0) {
                metadataFilter.hidden = false;
                const optionsHtml = metadataItems
                    .map(label => `<option value="${label}">${label}</option>`)
                    .join("");
                const metadataSelect = document.getElementById("metadata");
                metadataSelect.innerHTML = `<option value="All">All</option>` + optionsHtml;
            } else {
                metadataFilter.hidden = true;
            }
        }

        // function to update the available runs to select in the filters
        function setup_runs_in_select_filter_buttons() {
            const runOptions = new Set();
            runs.forEach(run => runOptions.add(run.name));
            const optionsHtml = Array.from(runOptions)
                .map(runName => `<option value="${runName}">${runName}</option>`)
                .join("");
            const runsSelect = document.getElementById("runs");
            runsSelect.innerHTML = `<option value="All">All</option>` + optionsHtml;
        }

        // function to update the available runtags to select in the filters
        function setup_runtags_in_select_filter_buttons() {
            const tags = new Set();
            runs.forEach(run => {
                run.tags.split(",").forEach(tag => {
                    if (tag) { // Avoid adding empty tags
                        tags.add(tag);
                    }
                });
            });
            const andOrTags = `
                <li class="list-group-item d-flex small">
                    <div class="btn-group form-switch">
                        <input class="form-check-input" type="checkbox" role="switch" id="useOrTags" />
                    </div>
                    <div class="btn-group">
                        <label class="form-check-label" for="useOrTags">Use OR (default AND)</label>
                    </div>
                </li>
            `;
            const listItemTemplate = (value) => `
                <li class="list-group-item list-group-item-action d-flex small">
                    <input class="form-check-input me-1" type="checkbox" value="" id="${value}">
                    <label class="form-check-label ms-2" for="${value}">${value}</label>
                </li>
            `;
            const listItems = [listItemTemplate("All")].concat(
                Array.from(tags).map(tag => listItemTemplate(tag))
            ).join("");
            const tagsSelect = document.getElementById("runTag");
            tagsSelect.innerHTML = andOrTags + listItems;
            document.getElementById("All").checked = true;
            if (tags.size > 0) {
                document.getElementById("runTagFilter").hidden = false
            } else {
                document.getElementById("runTagFilter").hidden = true
            }
        }

        // function to update the available runs in the selects
        function setup_runs_in_compare_selects() {
            const selects = compareRunIds.map(id => document.getElementById(id));
            const items = filteredRuns.map(run => showAliases ? run.run_alias : run.run_start);
            selects.forEach(select => select.innerHTML = "")
            selects.forEach(select => {
                select.options.add(new Option("None", "None"));
                items.forEach(item => select.options.add(new Option(item, item)));
            });
            selects[0].selectedIndex = selects[0].options.length - 1;
            selects[1].selectedIndex = selects[1].options.length - 2;
        }

        // function to update the available suites to select in the suite filters
        function setup_suites_in_suite_select() {
            const suiteSelectSuites = document.getElementById("suiteSelectSuites");
            const suiteFolder = document.getElementById("suiteFolder").innerText;
            suiteSelectSuites.innerHTML = "";
            var suiteNames = new Set()
            for (const suite of filteredSuites) {
                if (suiteFolder != "All" && !(suite.full_name.startsWith(suiteFolder + ".") || suite.full_name == suiteFolder)) {
                    continue
                }
                if (useSuitePathsSuiteSection) {
                    suiteNames.add(suite.full_name);
                } else {
                    suiteNames.add(suite.name);
                }
            }
            suiteNames = [...suiteNames].sort()
            suiteSelectSuites.options.add(new Option("All", "All"));
            suiteNames.forEach(suiteName => {
                suiteSelectSuites.options.add(new Option(suiteName, suiteName));
            });
            suiteSelectSuites.selectedIndex = 1;
        }

        // function to update the available suites to select in the test filters
        function setup_suites_in_test_select() {
            const suiteSelectTests = document.getElementById("suiteSelectTests");
            suiteSelectTests.innerHTML = "";
            const suiteNames = useSuitePathsTestSection
                ? [...new Set(filteredSuites.map(suite => suite.full_name))].sort()
                : [...new Set(filteredSuites.map(suite => suite.name))].sort();
            suiteSelectTests.options.add(new Option("All", "All"));
            suiteNames.forEach(suiteName => {
                suiteSelectTests.options.add(new Option(suiteName, suiteName));
            });
            suiteSelectTests.selectedIndex = 1;
        }

        // function to update the available tests to select in the filters
        // applies to the test filter on the test statistics level
        function setup_tests_in_select() {
            const suiteSelectTests = document.getElementById("suiteSelectTests").value;
            const testTagsSelect = document.getElementById("testTagsSelect").value;
            const testSelect = document.getElementById("testSelect");
            testSelect.innerHTML = "";
            const testNames = filteredTests.reduce((names, test) => {
                const isInSuite = useSuitePathsTestSection
                    ? test.full_name.includes(`${suiteSelectTests}.${test.name}`) || suiteSelectTests === "All"
                    : test.full_name.includes(`.${suiteSelectTests}.${test.name}`) || suiteSelectTests === "All"
                const hasTag = testTagsSelect === "All" || test.tags.includes(testTagsSelect);

                if (isInSuite && hasTag && !names.includes(test.name)) {
                    names.push(test.name);
                }

                return names;
            }, []);
            testSelect.options.add(new Option("All", "All"));
            testNames.forEach(testName => testSelect.options.add(new Option(testName, testName)));
        }

        // function to update the available testtags to select in the filters
        // applies to the testtag filter on the test statistics level
        function setup_testtags_in_select() {
            const suiteSelectTests = document.getElementById("suiteSelectTests").value;
            const testTagsSelect = document.getElementById("testTagsSelect");
            testTagsSelect.innerHTML = "";
            const testTags = [...new Set(filteredTests.reduce((tags, test) => {
                if (useSuitePathsTestSection) {
                    if (test.full_name.includes(`${suiteSelectTests}.${test.name}`) || suiteSelectTests === "All") {
                        test.tags.replace(/\[|\]/g, "").split(",").forEach(tag => tags.push(tag.trim()));
                    }
                } else {
                    if (test.full_name.includes(`.${suiteSelectTests}.${test.name}`) || suiteSelectTests === "All") {
                        test.tags.replace(/\[|\]/g, "").split(",").forEach(tag => tags.push(tag.trim()));
                    }
                }
                return tags;
            }, []))].filter(Boolean);
            testTagsSelect.options.add(new Option("All", "All"));
            testTags.forEach(tag => testTagsSelect.options.add(new Option(tag, tag)));
        }

        // function to update the available keywords to select in the filters
        // applies to the keyword filter on the keyword statistics level
        function setup_keywords_in_select() {
            const keywordSelect = document.getElementById("keywordSelect");
            keywordSelect.innerHTML = "";
            const keywordNames = [...new Set(filteredKeywords.map(keyword => keyword.name))].sort();
            keywordNames.forEach(keywordName => keywordSelect.options.add(new Option(keywordName, keywordName)));
            keywordSelect.selectedIndex = keywordNames.length - 1;
        }

        ///////////////////////////
        // DATA FILTER FUNCTIONS //
        ///////////////////////////

        // function to remove milliseconds if needed
        function remove_milliseconds(data) {
            if (showMilliseconds) { return data; }

            return data.map(obj => ({
                ...obj,
                run_start: obj.run_start.slice(0, 19)
            }));
        }

        // function to filter run data based on the runs (aka run name) filter
        function filter_runs(runs) {
            if (selectedRunSetting != '') {
                document.getElementById("runs").value = selectedRunSetting
                selectedRunSetting = ''
            }
            const selectedRun = document.getElementById("runs").value;
            if (selectedRun === "All") {
                var selectedRuns = runs
            } else {
                var selectedRuns = Object.values(runs).filter(run => run.name === selectedRun)
            }
            return selectedRuns;
        }

        // function to filter run data based on the run tags filter
        function filter_runtags(runs) {
            const tagElements = document.getElementById("runTag").getElementsByTagName("input");
            const useOrTags = document.getElementById("useOrTags").checked;

            if (selectedTagSetting != '') {
                for (const input of tagElements) {
                    input.checked = false;
                    if (input.id === selectedTagSetting) {
                        input.checked = true;
                    }
                }
                useOrTags.checked = false;
                selectedTagSetting = ''
            }

            const selectedTags = Array.from(tagElements)
                .filter(tagElement => tagElement.checked)
                .map(tagElement => tagElement.id);
            if (selectedTags.includes("All")) { // If "All" is selected, return all runs
                return runs;
            }
            if (selectedTags.length === 0) { // If no tags are selected, return an empty list
                return [];
            }
            return runs.filter(run => {
                const runTags = run.tags.split(",");
                if (!useOrTags) { // Use AND logic: the run must contain all selected tags
                    return selectedTags.every(selectedTag => runTags.includes(selectedTag));
                }
                // Use OR logic: the run must contain at least one selected tag
                return selectedTags.some(selectedTag => runTags.includes(selectedTag));
            });
        }

        // function to filter the run data based on the selected date range
        function filter_dates(runs) {
            const fromDate = document.getElementById("fromDate").value;
            const fromTime = document.getElementById("fromTime").value;
            const toDate = document.getElementById("toDate").value;
            const toTime = document.getElementById("toTime").value;
            if (!fromDate || !fromTime || !toDate || !toTime) { // Return all runs if any date/time values are missing
                return runs;
            }
            const fromDateTime = new Date(`${fromDate} ${fromTime}:00`);
            const toDateTime = new Date(`${toDate} ${toTime}:00`);
            if (fromDateTime > toDateTime) { // Check for valid date range
                alert("Filter error: The selected from date + time is later than your selected to date + time. Date filter has not been applied!");
                return runs;  // Return all runs if invalid range
            }
            return runs.filter(run => {
                const runStart = new Date(run.run_start);
                return runStart >= fromDateTime && runStart <= toDateTime;
            });
        }

        // function to filter the amount of runs based on the filter
        function filter_amount(filteredRuns) {
            var selectedAmount = document.getElementById("amount").value;
            // Handle weird selectedAmountValues:
            if (selectedAmount == "") {
                $("#amount").val(10).trigger("change.amount");
                selectedAmount = document.getElementById("amount").value;
            }
            if (selectedAmount > runs.length) {
                $("#amount").val(runs.length).trigger("change.amount");
                selectedAmount = document.getElementById("amount").value;
            }
            if (selectedAmount < 0) {
                $("#amount").val(0).trigger("change.amount");
                selectedAmount = document.getElementById("amount").value;
            }
            if (selectedAmount.includes(",")) {
                $("#amount").val(selectedAmount.split(",")[0]).trigger("change.amount");
                selectedAmount = document.getElementById("amount").value;
            }
            if (selectedAmount.includes(".")) {
                $("#amount").val(selectedAmount.split(".")[0]).trigger("change.amount");
                selectedAmount = document.getElementById("amount").value;
            }
            filteredAmount = filteredRuns.length
            if (selectedAmount == 0) { return [] }
            filteredRuns = filteredRuns.slice(- selectedAmount)
            return filteredRuns
        }

        // function to filter the runs based on the selected metadata key:value pair
        function filter_metadata(filteredRuns) {
            const selectedMetadata = document.getElementById("metadata").value;
            if (selectedMetadata == '' || selectedMetadata == 'All') return filteredRuns;
            var filteredData = []
            for (const run of filteredRuns) {
                if (run.metadata.includes(selectedMetadata)) {
                    filteredData.push(run)
                }
            }
            return filteredData
        }

        // function to filter suites/tests/keywords based on the already filtered runs
        function filter_data(data) {
            var validRunStarts = [];
            for (value of filteredRuns) {
                validRunStarts.push(value.run_start);
            }
            var filteredData = [];
            for (value of data) {
                if (validRunStarts.includes(value.run_start)) {
                    filteredData.push(value);
                }
            }
            return filteredData;
        }

        //////////////////////////////////////
        // GRAPH & TABLE CREATION FUNCTIONS //
        //////////////////////////////////////

        // function to create overview statistics blocks in the overview section
        function create_overview_statistics_graphs() {
            for (const g of overviewGraphs) window[g].destroy();
            overviewGraphs = [];

            const useRunTags = document.getElementById("useRunTags").checked;
            const data = {};
            for (const run of runs) {
                var name = '';
                if (useRunTags) {
                    const tags = run.tags.split(",")
                    var foundTag = false;
                    for (const tag of tags) {
                        if (tag.startsWith('project_')) {
                            name = tag;
                            foundTag = true;
                            break
                        }
                    }
                    if (!foundTag) name = run.name;
                } else {
                    name = run.name;
                }

                if (!data[name]) {
                    data[name] = { stats: [], duration: [], passed_runs: [] };
                }
                data[name].duration.push(run.elapsed_s);
                data[name].stats = [run.passed, run.failed, run.skipped, run.elapsed_s, run.path];
                data[name].passed_runs.push(run.failed === 0 ? 1 : 0);
            }
            const avg = arr => arr.reduce((a, b) => a + parseFloat(b), 0) / arr.length;
            const compare_to_average = (duration, avg, percent) => {
                const t = parseFloat(percent) / 100;
                return duration < avg * (1 - t) ? 'text-passed' :
                    duration > avg * (1 + t) ? 'text-failed' : '';
            };

            const overviewCard = (name, stats, duration, status, amount, compares, passed_runs, log_path, log_name, svg) => `
            <div class="col-4 overview-card" id="${name}Card">
                <div class="card border-3 border-${status}">
                    <div class="card-body">
                        <div class="row">
                            <div class="col text-center"><h5 class="card-title mb-0">${name}</h5></div>
                            <div class="col-auto"><h5>#${amount}</h5></div>
                        </div>
                        <div class="row">
                            <div class="col-4 overview-canvas">
                                <canvas id="${name}Graph"></canvas>
                            </div>
                            <div class="col-3 d-flex align-items-center">
                                <div>
                                    <div class="green-text">Passed: ${stats[0]}</div>
                                    <div class="red-text">Failed: ${stats[1]}</div>
                                    <div class="yellow-text">Skipped: ${stats[2]}</div>
                                </div>
                            </div>
                            <div class="col-5 d-flex align-items-center" style="overflow:auto;">
                                <div>
                                    <div class="${compares}">${svg} <i>${Math.round(duration)}s</i></div>
                                    <div>Passed Runs: ${passed_runs}%</div>
                                    <a href="${log_path}" target="_blank" onclick="event.stopPropagation()">${log_name}</a>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>`;

            let overviewHTML = '';
            const overviewDurationPercentage = document.getElementById('overviewDurationPercentage').value;
            const keys = Object.keys(data).sort();
            const svg = document.getElementsByTagName("html")[0].getAttribute("data-bs-theme") == "dark" ? clockDarkSVG : clockLightSVG;
            document.getElementById("overviewTitle").innerHTML = `Overview Statistics <h6>showing ${Object.keys(runs).length} runs in ${keys.length} projects</h6`;
            keys.forEach((key, i) => {
                const d = data[key];
                const [passed, failed, skipped, duration, rawPath] = d.stats;
                const path = rawPath.replace('output', 'log').replace('.xml', '.html');
                const amount = d.duration.length;
                if (amount > 1) d.duration.pop(); // remove current run for averaging
                const average = avg(d.duration);
                const compares = compare_to_average(duration, average, overviewDurationPercentage);
                const passedRuns = (d.passed_runs.reduce((a, b) => a + b, 0) / d.passed_runs.length * 100).toFixed(2);
                const status = failed > 0 ? 'failed' : skipped > 0 ? 'skipped' : 'passed';
                const log_path = use_logs ? path : '';
                const log_name = use_logs ? 'log.html' : '';

                if (i % 3 === 0) overviewHTML += '<div class="row">';
                overviewHTML += overviewCard(key, d.stats, duration, status, amount, compares, passedRuns, log_path, log_name, svg);
                if (i % 3 === 2 || i === keys.length - 1) overviewHTML += '</div>';
            });

            document.getElementById('overviewData').innerHTML = overviewHTML;

            for (const key of keys) {
                document.getElementById(`${key}Card`).addEventListener('click', () => {
                    // reset any previous run name or run tag
                    document.getElementById("runs").value = "All";
                    const tagElements = document.getElementById("runTag").getElementsByTagName("input");
                    for (const input of tagElements) {
                        input.checked = false;
                        if (input.id == "All") input.checked = true;
                    }
                    // set the correct value based on prefix
                    if (key.startsWith('project_')) {
                        selectedTagSetting = key;
                    } else {
                        selectedRunSetting = key;
                    }
                    update_menu('menuDashboard')
                });
                const el = document.getElementById(`${key}Graph`);
                const [passed, failed, skipped] = data[key].stats;
                const chartData = {
                    labels: [],
                    datasets: [{
                        data: [],
                        backgroundColor: [],
                        borderColor: [],
                        hoverOffset: 4
                    }]
                };
                const pushIf = (label, value, bg, border) => {
                    if (value > 0) {
                        chartData.labels.push(label);
                        chartData.datasets[0].data.push(value);
                        chartData.datasets[0].backgroundColor.push(bg);
                        chartData.datasets[0].borderColor.push(border);
                    }
                };
                pushIf('passed', passed, passedBackgroundColor, passedBackgroundBorderColor);
                pushIf('failed', failed, failedBackgroundColor, failedBackgroundBorderColor);
                pushIf('skipped', skipped, skippedBackgroundColor, skippedBackgroundBorderColor);

                const config = get_graph_config('donut', chartData, 'Last Run Status');
                delete config.options.plugins.datalabels;
                config.options.plugins.legend.display = false;
                window[`${key}Graph`] = new Chart(el, config);
                overviewGraphs.push(`${key}Graph`);
            }
        }

        // function to create run statistics graph in the run section
        function create_run_statistics_graph() {
            if (runStatisticsGraph) {
                runStatisticsGraph.destroy();
            }
            const data = get_statistics_graph_data("run", runStatisticsGraphType, filteredRuns);
            const graphData = data[0]
            var config;
            if (runStatisticsGraphType == "line") {
                config = get_graph_config("line", graphData, "Amount Of Tests", "Date", "Amount", false);
            } else if (runStatisticsGraphType == "amount") {
                config = get_graph_config("bar", graphData, "Run Statistics", "Run", "Amount Of Tests");
            } else if (runStatisticsGraphType == "percentages") {
                config = get_graph_config("bar", graphData, "Run Statistics", "Run", "Percentage");
            }
            if (!showDateLabels) { config.options.scales.x.ticks.display = false }
            runStatisticsGraph = new Chart("runStatisticsGraph", config);
            runStatisticsGraph.canvas.addEventListener("click", (event) => {
                open_log_from_label(runStatisticsGraph, event)
            });
        }

        // function to create run donut graph in the run section
        function create_run_donut_graph() {
            if (runDonutGraph) {
                runDonutGraph.destroy();
            }
            const data = get_donut_graph_data("run", filteredRuns);
            const graphData = data[0]
            const callbackData = data[1]
            var config = get_graph_config("donut", graphData, `Last Run Status: ${callbackData}`);
            config.options.onClick = (event, chartElement) => {
                if (chartElement.length) {
                    open_log_file(event, chartElement, callbackData)
                }
            };
            runDonutGraph = new Chart("runDonutGraph", config);
        }

        // function to create run donut graph in the run section
        function create_run_donut_total_graph() {
            if (runDonutTotalGraph) {
                runDonutTotalGraph.destroy();
            }
            const data = get_donut_total_graph_data("run", filteredRuns);
            const graphData = data[0]
            const callbackData = data[1]
            var config = get_graph_config("donut", graphData, `Total Status`);
            delete config.options.onClick;
            runDonutTotalGraph = new Chart("runDonutTotalGraph", config);
        }

        // function to create the run stats section in the run section
        function create_run_stats_graph() {
            const data = get_stats_data(filteredRuns, filteredSuites, filteredTests, filteredKeywords);
            document.getElementById('totalRuns').innerText = data.totalRuns
            document.getElementById('totalSuites').innerText = data.totalSuites
            document.getElementById('totalTests').innerText = data.totalTests
            document.getElementById('totalKeywords').innerText = data.totalKeywords
            document.getElementById('totalUniqueTests').innerText = data.totalUniqueTests
            document.getElementById('totalPassed').innerText = data.totalPassed
            document.getElementById('totalFailed').innerText = data.totalFailed
            document.getElementById('totalSkipped').innerText = data.totalSkipped
            document.getElementById('totalRunTime').innerText = data.totalRunTime
            document.getElementById('averageRunTime').innerText = data.averageRunTime
            document.getElementById('averageTestTime').innerText = data.averageTestTime
            document.getElementById('averagePassRate').innerText = data.averagePassRate
        }

        // function to create run duration graph in the run section
        function create_run_duration_graph() {
            if (runDurationGraph) {
                runDurationGraph.destroy();
            }
            var graphData = get_duration_graph_data("run", runDurationGraphType, "elapsed_s", filteredRuns);
            var config;
            if (runDurationGraphType == "bar") {
                const limit = inFullscreen ? 100 : 30;
                config = get_graph_config("bar", graphData, `Run Duration Max ${limit} Bars`, "Run", "Duration");
            } else if (runDurationGraphType == "line") {
                config = get_graph_config("line", graphData, "Run Duration", "Date", "Duration");
            }
            if (!showDateLabels) { config.options.scales.x.ticks.display = false }
            runDurationGraph = new Chart("runDurationGraph", config);
            runDurationGraph.canvas.addEventListener("click", (event) => {
                open_log_from_label(runDurationGraph, event)
            });
        }

        // function to create the run heatmap
        function create_run_heatmap_graph() {
            if (runHeatmapGraph) {
                runHeatmapGraph.destroy();
            }
            const data = get_heatmap_graph_data(filteredTests);
            const graphData = data[0]
            const callbackData = data[1]
            var config = get_graph_config("heatmap", graphData, `Heatmap Graph`, "Hour", "Day");
            delete config.options.onClick;
            config.options.plugins.tooltip = {
                callbacks: {
                    title: () => null,
                    label: ctx => {
                        const { x, y, v } = ctx.raw;
                        if (heatMapHourAll) {
                            return `Day: ${callbackData[Math.floor(y - 0.5)]}, Hour: ${Math.floor(x - 0.5)}, Amount: ${v}`;
                        } else {
                            return `Day: ${callbackData[Math.floor(y - 0.5)]}, Minute: ${Math.floor(x - 0.5)}, Amount: ${v}`;
                        }
                    }
                }
            }
            config.options.scales.y.ticks = {
                stepSize: 1,
                callback: val => callbackData[val] || ''
            }
            runHeatmapGraph = new Chart("runHeatmapGraph", config);
        }

        // function to create run table in the run section
        function create_run_table() {
            if (runTable) {
                runTable.destroy();
            }
            data = [];
            for (run of filteredRuns) {
                data.push([
                    run.run_start,
                    run.full_name,
                    run.name,
                    run.total,
                    run.passed,
                    run.failed,
                    run.skipped,
                    run.elapsed_s,
                    run.start_time,
                    run.tags,
                    run.run_alias,
                    run.metadata,
                ]);
            }
            runTable = new DataTable("#runTable", {
                layout: {
                    topStart: "info",
                    bottomStart: null,
                },
                columns: [
                    { title: "run" },
                    { title: "full_name" },
                    { title: "name" },
                    { title: "total" },
                    { title: "passed" },
                    { title: "failed" },
                    { title: "skipped" },
                    { title: "elapsed_s" },
                    { title: "start_time" },
                    { title: "tags" },
                    { title: "alias" },
                    { title: "metadata" },
                ],
                data: data,
            });
        }

        // function to create suite folder donut
        function create_suite_folder_donut_graph(folder) {
            const suiteFolder = document.getElementById("suiteFolder")
            suiteFolder.innerText = folder == "" || folder == undefined ? "All" : folder;
            if (folder || folder == "") { // not first load so update the graphs accordingly as well
                setup_suites_in_suite_select();
                create_suite_folder_fail_donut_graph();
                create_suite_statistics_graph();
                create_suite_duration_graph();
            }
            if (suiteFolderDonutGraph) {
                suiteFolderDonutGraph.destroy();
            }
            const data = get_donut_folder_graph_data("suite", filteredSuites, folder);
            const graphData = data[0]
            const callbackData = data[1]
            const labels = graphData.labels
            var config = get_graph_config("donut", graphData, `All Folder Statistics`);
            config.options.plugins.tooltip.callbacks = {
                label: function (context) {
                    const label = labels[context.dataIndex]
                    const passed = callbackData[label].passed
                    const failed = callbackData[label].failed
                    const skipped = callbackData[label].skipped
                    return [`Total: ${context.raw}`, `Passed: ${passed}`, `Failed: ${failed}`, `Skipped: ${skipped}`];
                },
                title: function (tooltipItem) {
                    return tooltipItem.label;
                }
            }
            config.options.onClick = (event) => {
                if (event.chart.tooltip.title) {
                    setTimeout(() => {
                        create_suite_folder_donut_graph(event.chart.tooltip.title[0]);
                    }, 0);
                }
            };
            suiteFolderDonutGraph = new Chart("suiteFolderDonutGraph", config);
        }

        // function to create suite last failed donut
        function create_suite_folder_fail_donut_graph() {
            if (suiteFolderFailDonutGraph) {
                suiteFolderFailDonutGraph.destroy();
            }
            const data = get_donut_folder_fail_graph_data("suite", filteredSuites);
            const graphData = data[0]
            const callbackData = data[1]
            const labels = graphData.labels
            if (graphData.labels.length == 0) {
                graphData.labels = ["No Failed Folders In Last Run"]
                graphData.datasets = [{
                    data: [1],
                    backgroundColor: ["grey"],
                }]
            }
            var config = get_graph_config("donut", graphData, `Last Run Failed Folders`);
            config.options.plugins.tooltip.callbacks = {
                label: function (context) {
                    if (context.label == "No Failed Folders In Last Run") { return null }
                    const label = labels[context.dataIndex]
                    const passed = callbackData[label].passed
                    const failed = callbackData[label].failed
                    const skipped = callbackData[label].skipped
                    return [`Passed: ${passed}`, `Failed: ${failed}`, `Skipped: ${skipped}`];
                },
                title: function (tooltipItem) {
                    return tooltipItem.label;
                }
            }
            config.options.plugins.datalabels = {
                ...dataLabelConfig,
                formatter: function (value, context) {
                    if (value === 0) return null;
                    const total = graphData.datasets[0].data.reduce((a, b) => a + b, 0);
                    const percentage = Math.round((value / total) * 100);
                    if (percentage <= 5) return null;
                    const label = graphData.labels[context.dataIndex].split(".").pop();
                    return `${label}: ${value} (${percentage}%)`;
                }
            };
            config.options.onClick = (event) => {
                if (event.chart.tooltip.title) {
                    setTimeout(() => {
                        create_suite_folder_donut_graph(event.chart.tooltip.title[0]);
                    }, 0);
                }
            };
            suiteFolderFailDonutGraph = new Chart("suiteFolderFailDonutGraph", config);
        }

        // function to create suite statistics graph in the suite section
        function create_suite_statistics_graph() {
            if (suiteStatisticsGraph) {
                suiteStatisticsGraph.destroy();
            }
            const data = get_statistics_graph_data("suite", suiteStatisticsGraphType, filteredSuites);
            const graphData = data[0]
            const callbackData = data[1]
            var config;
            if (suiteStatisticsGraphType == "line") {
                config = get_graph_config("line", graphData, "Amount Of Tests", "Date", "amount", false);
                config.options.plugins.tooltip = {
                    callbacks: {
                        title: function (tooltipItem) {
                            return `${tooltipItem[0].label}: ${callbackData[tooltipItem[0].dataIndex]}`
                        }
                    }
                }
            } else if (suiteStatisticsGraphType == "amount") {
                config = get_graph_config("bar", graphData, "Suite Statistics", "Run", "Amount Of Tests");
                const filter = config.options.plugins.tooltip.filter
                config.options.plugins.tooltip = {
                    filter,
                    callbacks: {
                        title: function (tooltipItem) {
                            return `${tooltipItem[0].label}: ${callbackData[tooltipItem[0].dataIndex]}`
                        }
                    }
                }
            } else if (suiteStatisticsGraphType == "percentages") {
                config = get_graph_config("bar", graphData, "Suite Statistics", "Run", "Percentage");
                const filter = config.options.plugins.tooltip.filter
                config.options.plugins.tooltip = {
                    filter,
                    callbacks: {
                        title: function (tooltipItem) {
                            return `${tooltipItem[0].label}: ${callbackData[tooltipItem[0].dataIndex]}`
                        }
                    }
                }
            }
            if (!showDateLabels) { config.options.scales.x.ticks.display = false }
            suiteStatisticsGraph = new Chart("suiteStatisticsGraph", config);
            suiteStatisticsGraph.canvas.addEventListener("click", (event) => {
                open_log_from_label(suiteStatisticsGraph, event)
            });
        }

        // function to create suite duration graph in the suite section
        function create_suite_duration_graph() {
            if (suiteDurationGraph) {
                suiteDurationGraph.destroy();
            }
            const graphData = get_duration_graph_data("suite", suiteDurationGraphType, "elapsed_s", filteredSuites);
            var config;
            if (suiteDurationGraphType == "bar") {
                const limit = inFullscreen ? 100 : 30;
                config = get_graph_config("bar", graphData, `Suite Duration Max ${limit} Bars`, "Run", "Duration");
            } else if (suiteDurationGraphType == "line") {
                config = get_graph_config("line", graphData, "Suite Duration", "Date", "Duration");
            }
            if (!showDateLabels) { config.options.scales.x.ticks.display = false }
            suiteDurationGraph = new Chart("suiteDurationGraph", config);
            suiteDurationGraph.canvas.addEventListener("click", (event) => {
                open_log_from_label(suiteDurationGraph, event)
            });
        }

        // function to create suite most failed graph in the suite section
        function create_suite_most_failed_graph() {
            if (suiteMostFailedGraph) {
                suiteMostFailedGraph.destroy();
            }
            const data = get_most_failed_data("suite", suiteMostFailedGraphType, filteredSuites, false);
            const graphData = data[0];
            const callbackData = data[1];
            var config;
            const limit = inFullscreen ? 50 : 10;
            if (suiteMostFailedGraphType == "bar") {
                config = get_graph_config("bar", graphData, `Top ${limit} Most Failed Suites`, "Suite", "Fails");
                config.options.plugins.legend = { display: false };
                config.options.plugins.tooltip = {
                    callbacks: {
                        label: function (tooltipItem) {
                            return callbackData[tooltipItem.label];
                        },
                    },
                };
                delete config.options.onClick
            } else if (suiteMostFailedGraphType == "timeline") {
                config = get_graph_config("timeline", graphData, `Top ${limit} Most Failed Suites`, "Run", "Suite");
                config.options.plugins.tooltip = {
                    callbacks: {
                        label: function (context) {
                            return callbackData[context.raw.x[0]];
                        },
                    },
                };
                config.options.scales.x = {
                    ticks: {
                        minRotation: 45,
                        maxRotation: 45,
                        stepSize: 1,
                        callback: function (value, index, ticks) {
                            return callbackData[this.getLabelForValue(value)];
                        },
                    },
                    title: {
                        display: true,
                        text: "Run",
                    },
                };
                config.options.onClick = (event, chartElement) => {
                    if (chartElement.length) {
                        open_log_file(event, chartElement, callbackData)
                    }
                };
                if (!showDateLabels) { config.options.scales.x.ticks.display = false }
            }
            update_height("suiteMostFailedVertical", config.data.labels.length, config.options.plugins.title.text, suiteMostFailedGraphType);
            suiteMostFailedGraph = new Chart("suiteMostFailedGraph", config);
            suiteMostFailedGraph.canvas.addEventListener("click", (event) => {
                open_log_from_label(suiteMostFailedGraph, event)
            });
        }

        // function to create suite table in the suite section
        function create_suite_table() {
            if (suiteTable) {
                suiteTable.destroy();
            }
            data = [];
            for (suite of filteredSuites) {
                data.push([
                    suite.run_start,
                    suite.full_name,
                    suite.name,
                    suite.total,
                    suite.passed,
                    suite.failed,
                    suite.skipped,
                    suite.elapsed_s,
                    suite.start_time,
                    suite.run_alias,
                    suite.id,
                ]);
            }
            suiteTable = new DataTable("#suiteTable", {
                layout: {
                    topStart: "info",
                    bottomStart: null,
                },
                columns: [
                    { title: "run" },
                    { title: "full_name" },
                    { title: "name" },
                    { title: "total" },
                    { title: "passed" },
                    { title: "failed" },
                    { title: "skipped" },
                    { title: "elapsed_s" },
                    { title: "start_time" },
                    { title: "alias" },
                    { title: "id" },
                ],
                data: data,
            });
        }

        // function to create test statistics graph in the test section
        function create_test_statistics_graph() {
            if (testStatisticsGraph) {
                testStatisticsGraph.destroy();
            }
            const data = get_test_statistics_data(filteredTests);
            const graphData = data[0]
            const runStarts = data[1]
            var config = get_graph_config("timeline", graphData, "Test Statistics", "Run", "Test");
            config.options.plugins.tooltip = {
                callbacks: {
                    label: function (context) {
                        return runStarts[context.raw.x[0]];
                    },
                },
            };
            config.options.scales.x = {
                ticks: {
                    minRotation: 45,
                    maxRotation: 45,
                    stepSize: 1,
                    callback: function (value, index, ticks) {
                        return runStarts[this.getLabelForValue(value)];
                    },
                },
                title: {
                    display: true,
                    text: "Run",
                },
            };
            config.options.onClick = (event, chartElement) => {
                if (chartElement.length) {
                    open_log_file(event, chartElement, runStarts)
                }
            };
            if (!showDateLabels) { config.options.scales.x.ticks.display = false }
            update_height("testStatisticsVertical", config.data.labels.length, config.options.plugins.title.text, "timeline");
            testStatisticsGraph = new Chart("testStatisticsGraph", config);
            testStatisticsGraph.canvas.addEventListener("click", (event) => {
                open_log_from_label(testStatisticsGraph, event)
            });
        }

        // function to create test duration graph in the test section
        function create_test_duration_graph() {
            if (testDurationGraph) {
                testDurationGraph.destroy();
            }
            var graphData = get_duration_graph_data("test", testDurationGraphType, "elapsed_s", filteredTests);
            var config;
            if (testDurationGraphType == "bar") {
                const limit = inFullscreen ? 100 : 30;
                config = get_graph_config("bar", graphData, `Test Duration Max ${limit} Bars`, "Run", "Duration");
            } else if (testDurationGraphType == "line") {
                config = get_graph_config("line", graphData, "Test Duration", "Date", "Duration");
            }
            if (!showDateLabels) { config.options.scales.x.ticks.display = false }
            testDurationGraph = new Chart("testDurationGraph", config);
            testDurationGraph.canvas.addEventListener("click", (event) => {
                open_log_from_label(testDurationGraph, event)
            });
        }

        // function to create test messages graph in the test section
        function create_test_messages_graph() {
            if (testMessagesGraph) {
                testMessagesGraph.destroy();
            }
            const data = get_messages_data("test", testMessagesGraphType, filteredTests);
            const graphData = data[0];
            const callbackData = data[1];
            var config;
            const limit = inFullscreen ? 50 : 10;
            if (testMessagesGraphType == "bar") {
                config = get_graph_config("bar", graphData, `Top ${limit} Fail Messages`, "Message", "Times");
                config.options.plugins.legend = { display: false };
                config.options.plugins.tooltip = {
                    callbacks: {
                        label: function (tooltipItem) {
                            return callbackData[tooltipItem.label];
                        },
                    },
                };
                config.options.scales.x = {
                    ticks: {
                        minRotation: 45,
                        maxRotation: 45,
                        callback: function (value, index) {
                            return this.getLabelForValue(value).slice(0, 40);
                        },
                    },
                    title: {
                        display: true,
                        text: "Message",
                    },
                };
                delete config.options.onClick
            } else if (testMessagesGraphType == "timeline") {
                config = get_graph_config("timeline", graphData, `Top ${limit} Fail Messages`, "Run", "Message");
                config.options.plugins.tooltip = {
                    callbacks: {
                        label: function (context) {
                            return callbackData[context.raw.x[0]];
                        },
                    },
                };
                config.options.scales.x = {
                    ticks: {
                        minRotation: 45,
                        maxRotation: 45,
                        stepSize: 1,
                        callback: function (value, index, ticks) {
                            return callbackData[this.getLabelForValue(value)];
                        },
                    },
                    title: {
                        display: true,
                        text: "Run",
                    },
                };
                config.options.onClick = (event, chartElement) => {
                    if (chartElement.length) {
                        open_log_file(event, chartElement, callbackData)
                    }
                };
                config.options.scales.y.ticks = {
                    callback: function (value, index, ticks) {
                        return this.getLabelForValue(value).slice(0, 40);
                    },
                };
                if (!showDateLabels) { config.options.scales.x.ticks.display = false }
            }
            update_height("testMessagesVertical", config.data.labels.length, config.options.plugins.title.text, testMessagesGraphType);
            testMessagesGraph = new Chart("testMessagesGraph", config);
            testMessagesGraph.canvas.addEventListener("click", (event) => {
                open_log_from_label(testMessagesGraph, event)
            });
        }

        // function to create test duration deviation graph in test section
        function create_test_duration_deviation_graph() {
            if (testDurationDeviationGraph) {
                testDurationDeviationGraph.destroy();
            }
            const graphData = get_duration_deviation_data("test", testDurationDeviationGraphType, filteredTests)
            const config = get_graph_config("boxplot", graphData, "Duration Deviation", "Test", "Duration");
            delete config.options.onClick
            testDurationDeviationGraph = new Chart("testDurationDeviationGraph", config);
            testDurationDeviationGraph.canvas.addEventListener("click", (event) => {
                open_log_from_label(testDurationDeviationGraph, event)
            });
        }

        // function to create test most flaky graph in test section
        function create_test_most_flaky_graph() {
            if (testMostFlakyGraph) {
                testMostFlakyGraph.destroy();
            }
            const data = get_most_flaky_data("test", testMostFlakyGraphType, filteredTests, ignoreSkips, false);
            const graphData = data[0]
            const callbackData = data[1];
            var config;
            const limit = inFullscreen ? 50 : 10;
            if (testMostFlakyGraphType == "bar") {
                config = get_graph_config("bar", graphData, `Top ${limit} Most Flaky Tests Most Status Flips`, "Test", "Status Flips");
                config.options.plugins.legend = false
                delete config.options.onClick
            } else if (testMostFlakyGraphType == "timeline") {
                config = get_graph_config("timeline", graphData, `Top ${limit} Most Flaky Tests Most Status Flips`, "Run", "Test");
                config.options.plugins.tooltip = {
                    callbacks: {
                        label: function (context) {
                            return callbackData[context.raw.x[0]];
                        },
                    },
                };
                config.options.scales.x = {
                    ticks: {
                        minRotation: 45,
                        maxRotation: 45,
                        stepSize: 1,
                        callback: function (value, index, ticks) {
                            return callbackData[this.getLabelForValue(value)];
                        },
                    },
                    title: {
                        display: true,
                        text: "Run",
                    },
                };
                config.options.onClick = (event, chartElement) => {
                    if (chartElement.length) {
                        open_log_file(event, chartElement, callbackData)
                    }
                };
                if (!showDateLabels) { config.options.scales.x.ticks.display = false }
            }
            update_height("testMostFlakyVertical", config.data.labels.length, config.options.plugins.title.text, testMostFlakyGraphType);
            testMostFlakyGraph = new Chart("testMostFlakyGraph", config);
            testMostFlakyGraph.canvas.addEventListener("click", (event) => {
                open_log_from_label(testMostFlakyGraph, event)
            });
        }

        // function to create test recent most flaky graph in test section
        function create_test_recent_most_flaky_graph() {
            if (testRecentMostFlakyGraph) {
                testRecentMostFlakyGraph.destroy();
            }
            const data = get_most_flaky_data("test", testRecentMostFlakyGraphType, filteredTests, ignoreSkipsRecent, true);
            const graphData = data[0];
            const callbackData = data[1];
            var config;
            const limit = inFullscreen ? 50 : 10;
            if (testRecentMostFlakyGraphType == "bar") {
                config = get_graph_config("bar", graphData, `Top ${limit} Recent Most Flaky Tests Most Status Flips`, "Test", "Status Flips");
                config.options.plugins.legend = false
                delete config.options.onClick
            } else if (testRecentMostFlakyGraphType == "timeline") {
                config = get_graph_config("timeline", graphData, `Top ${limit} Recent Most Flaky Tests Most Status Flips`, "Run", "Test");
                config.options.plugins.tooltip = {
                    callbacks: {
                        label: function (context) {
                            return callbackData[context.raw.x[0]];
                        },
                    },
                };
                config.options.scales.x = {
                    ticks: {
                        minRotation: 45,
                        maxRotation: 45,
                        stepSize: 1,
                        callback: function (value, index, ticks) {
                            return callbackData[this.getLabelForValue(value)];
                        },
                    },
                    title: {
                        display: true,
                        text: "Run",
                    },
                };
                config.options.onClick = (event, chartElement) => {
                    if (chartElement.length) {
                        open_log_file(event, chartElement, callbackData)
                    }
                };
                if (!showDateLabels) { config.options.scales.x.ticks.display = false }
            }
            update_height("testRecentMostFlakyVertical", config.data.labels.length, config.options.plugins.title.text, testRecentMostFlakyGraphType);
            testRecentMostFlakyGraph = new Chart("testRecentMostFlakyGraph", config);
            testRecentMostFlakyGraph.canvas.addEventListener("click", (event) => {
                open_log_from_label(testRecentMostFlakyGraph, event)
            });
        }

        // function to create test most failed graph in the test section
        function create_test_most_failed_graph() {
            if (testMostFailedGraph) {
                testMostFailedGraph.destroy();
            }
            const data = get_most_failed_data("test", testMostFailedGraphType, filteredTests, false);
            const graphData = data[0]
            const callbackData = data[1];
            var config;
            const limit = inFullscreen ? 50 : 10;
            if (testMostFailedGraphType == "bar") {
                config = get_graph_config("bar", graphData, `Top ${limit} Most Failed Tests`, "Test", "Fails");
                config.options.plugins.legend = { display: false };
                config.options.plugins.tooltip = {
                    callbacks: {
                        label: function (tooltipItem) {
                            return callbackData[tooltipItem.label];
                        },
                    },
                };
                delete config.options.onClick
            } else if (testMostFailedGraphType == "timeline") {
                config = get_graph_config("timeline", graphData, `Top ${limit} Most Failed Tests`, "Run", "Test");
                config.options.plugins.tooltip = {
                    callbacks: {
                        label: function (context) {
                            return callbackData[context.raw.x[0]];
                        },
                    },
                };
                config.options.scales.x = {
                    ticks: {
                        minRotation: 45,
                        maxRotation: 45,
                        stepSize: 1,
                        callback: function (value, index, ticks) {
                            return callbackData[this.getLabelForValue(value)];
                        },
                    },
                    title: {
                        display: true,
                        text: "Run",
                    },
                };
                config.options.onClick = (event, chartElement) => {
                    if (chartElement.length) {
                        open_log_file(event, chartElement, callbackData)
                    }
                };
                if (!showDateLabels) { config.options.scales.x.ticks.display = false }
            }
            update_height("testMostFailedVertical", config.data.labels.length, config.options.plugins.title.text, testMostFailedGraphType);
            testMostFailedGraph = new Chart("testMostFailedGraph", config);
            testMostFailedGraph.canvas.addEventListener("click", (event) => {
                open_log_from_label(testMostFailedGraph, event)
            });
        }

        // function to create test recent most failed graph in the test section
        function create_test_recent_most_failed_graph() {
            if (testRecentMostFailedGraph) {
                testRecentMostFailedGraph.destroy();
            }
            const data = get_most_failed_data("test", testRecentMostFailedGraphType, filteredTests, true);
            const graphData = data[0]
            const callbackData = data[1];
            var config;
            const limit = inFullscreen ? 50 : 10;
            if (testRecentMostFailedGraphType == "bar") {
                config = get_graph_config("bar", graphData, `Top ${limit} Recent Most Failed Tests`, "Test", "Fails");
                config.options.plugins.legend = { display: false };
                config.options.plugins.tooltip = {
                    callbacks: {
                        label: function (tooltipItem) {
                            return callbackData[tooltipItem.label];
                        },
                    },
                };
                delete config.options.onClick
            } else if (testRecentMostFailedGraphType == "timeline") {
                config = get_graph_config("timeline", graphData, `Top ${limit} Recent Most Failed Tests`, "Run", "Test");
                config.options.plugins.tooltip = {
                    callbacks: {
                        label: function (context) {
                            return callbackData[context.raw.x[0]];
                        },
                    },
                };
                config.options.scales.x = {
                    ticks: {
                        minRotation: 45,
                        maxRotation: 45,
                        stepSize: 1,
                        callback: function (value, index, ticks) {
                            return callbackData[this.getLabelForValue(value)];
                        },
                    },
                    title: {
                        display: true,
                        text: "Run",
                    },
                };
                config.options.onClick = (event, chartElement) => {
                    if (chartElement.length) {
                        open_log_file(event, chartElement, callbackData)
                    }
                };
                if (!showDateLabels) { config.options.scales.x.ticks.display = false }
            }
            update_height("testRecentMostFailedVertical", config.data.labels.length, config.options.plugins.title.text, testRecentMostFailedGraphType);
            testRecentMostFailedGraph = new Chart("testRecentMostFailedGraph", config);
            testRecentMostFailedGraph.canvas.addEventListener("click", (event) => {
                open_log_from_label(testRecentMostFailedGraph, event)
            });
        }

        // function to create test table in the test section
        function create_test_table() {
            if (testTable) {
                testTable.destroy();
            }
            data = [];
            for (test of filteredTests) {
                data.push([
                    test.run_start,
                    test.full_name,
                    test.name,
                    test.passed,
                    test.failed,
                    test.skipped,
                    test.elapsed_s,
                    test.start_time,
                    test.message,
                    test.tags,
                    test.run_alias,
                    test.id
                ]);
            }
            testTable = new DataTable("#testTable", {
                layout: {
                    topStart: "info",
                    bottomStart: null,
                },
                columns: [
                    { title: "run" },
                    { title: "full_name" },
                    { title: "name" },
                    { title: "passed" },
                    { title: "failed" },
                    { title: "skipped" },
                    { title: "elapsed_s" },
                    { title: "start_time" },
                    { title: "message" },
                    { title: "tags" },
                    { title: "alias" },
                    { title: "id" },
                ],
                data: data,
            });
        }

        // function to keyword statistics graph in the keyword section
        function create_keyword_statistics_graph() {
            if (keywordStatisticsGraph) {
                keywordStatisticsGraph.destroy();
            }
            const data = get_statistics_graph_data("keyword", keywordStatisticsGraphType, filteredKeywords);
            const graphData = data[0]
            var config;
            if (keywordStatisticsGraphType == "line") {
                config = get_graph_config("line", graphData, "Keyword Statistics", "Date", "Amount", false);
            } else if (keywordStatisticsGraphType == "amount") {
                config = get_graph_config("bar", graphData, "Keyword Statistics", "Run", "Amount");
            } else if (keywordStatisticsGraphType == "percentages") {
                config = get_graph_config("bar", graphData, "Keyword Statistics", "Run", "Percentage");
            }
            if (!showDateLabels) { config.options.scales.x.ticks.display = false }
            keywordStatisticsGraph = new Chart("keywordStatisticsGraph", config);
            keywordStatisticsGraph.canvas.addEventListener("click", (event) => {
                open_log_from_label(keywordStatisticsGraph, event)
            });
        }

        // function to keyword times run graph in the keyword section
        function create_keyword_times_run_graph() {
            if (keywordTimesRunGraph) {
                keywordTimesRunGraph.destroy();
            }
            const graphData = get_duration_graph_data("keyword", keywordTimesRunGraphType, "times_run", filteredKeywords);
            var config;
            if (keywordTimesRunGraphType == "bar") {
                const limit = inFullscreen ? 100 : 30;
                config = get_graph_config("bar", graphData, `Times Run Max ${limit} Bars`, "Run", "Duration");
            } else if (keywordTimesRunGraphType == "line") {
                config = get_graph_config("line", graphData, "Times Run", "Date", "Duration");
            }
            if (!showDateLabels) { config.options.scales.x.ticks.display = false }
            keywordTimesRunGraph = new Chart("keywordTimesRunGraph", config);
            keywordTimesRunGraph.canvas.addEventListener("click", (event) => {
                open_log_from_label(keywordTimesRunGraph, event)
            });
        }

        // function to keyword total time graph in the keyword section
        function create_keyword_total_duration_graph() {
            if (keywordTotalDurationGraph) {
                keywordTotalDurationGraph.destroy();
            }
            const graphData = get_duration_graph_data("keyword", keywordTotalDurationGraphType, "total_time_s", filteredKeywords);
            var config;
            if (keywordTotalDurationGraphType == "bar") {
                const limit = inFullscreen ? 100 : 30;
                config = get_graph_config("bar", graphData, `Total Duration Max ${limit} Bars`, "Run", "Duration");
            } else if (keywordTotalDurationGraphType == "line") {
                config = get_graph_config("line", graphData, "Total Duration", "Date", "Duration");
            }
            if (!showDateLabels) { config.options.scales.x.ticks.display = false }
            keywordTotalDurationGraph = new Chart("keywordTotalDurationGraph", config);
            keywordTotalDurationGraph.canvas.addEventListener("click", (event) => {
                open_log_from_label(keywordTotalDurationGraph, event)
            });
        }

        // function to keyword average time graph in the keyword section
        function create_keyword_average_duration_graph() {
            if (keywordAverageDurationGraph) {
                keywordAverageDurationGraph.destroy();
            }
            const graphData = get_duration_graph_data("keyword", keywordAverageDurationGraphType, "average_time_s", filteredKeywords);
            var config;
            if (keywordAverageDurationGraphType == "bar") {
                const limit = inFullscreen ? 100 : 30;
                config = get_graph_config("bar", graphData, `Average Duration Max ${limit} Bars`, "Run", "Duration");
            } else if (keywordAverageDurationGraphType == "line") {
                config = get_graph_config("line", graphData, "Average Duration", "Date", "Duration");
            }
            if (!showDateLabels) { config.options.scales.x.ticks.display = false }
            keywordAverageDurationGraph = new Chart("keywordAverageDurationGraph", config);
            keywordAverageDurationGraph.canvas.addEventListener("click", (event) => {
                open_log_from_label(keywordAverageDurationGraph, event)
            });
        }

        // function to keyword min time graph in the keyword section
        function create_keyword_min_duration_graph() {
            if (keywordMinDurationGraph) {
                keywordMinDurationGraph.destroy();
            }
            const graphData = get_duration_graph_data("keyword", keywordMinDurationGraphType, "min_time_s", filteredKeywords);
            var config;
            if (keywordMinDurationGraphType == "bar") {
                const limit = inFullscreen ? 100 : 30;
                config = get_graph_config("bar", graphData, `Min Duration Max ${limit} Bars`, "Run", "Duration");
            } else if (keywordMinDurationGraphType == "line") {
                config = get_graph_config("line", graphData, "Min Duration", "Date", "Duration");
            }
            if (!showDateLabels) { config.options.scales.x.ticks.display = false }
            keywordMinDurationGraph = new Chart("keywordMinDurationGraph", config);
            keywordMinDurationGraph.canvas.addEventListener("click", (event) => {
                open_log_from_label(keywordMinDurationGraph, event)
            });
        }

        // function to keyword max time graph in the keyword section
        function create_keyword_max_duration_graph() {
            if (keywordMaxDurationGraph) {
                keywordMaxDurationGraph.destroy();
            }
            const graphData = get_duration_graph_data("keyword", keywordMaxDurationGraphType, "max_time_s", filteredKeywords);
            var config;
            if (keywordMaxDurationGraphType == "bar") {
                const limit = inFullscreen ? 100 : 30;
                config = get_graph_config("bar", graphData, `Max Duration Max ${limit} Bars`, "Run", "Duration");
            } else if (keywordMaxDurationGraphType == "line") {
                config = get_graph_config("line", graphData, "Max Duration", "Date", "Duration");
            }
            if (!showDateLabels) { config.options.scales.x.ticks.display = false }
            keywordMaxDurationGraph = new Chart("keywordMaxDurationGraph", config);
            keywordMaxDurationGraph.canvas.addEventListener("click", (event) => {
                open_log_from_label(keywordMaxDurationGraph, event)
            });
        }

        // function to create test most failed graph in the test section
        function create_keyword_most_failed_graph() {
            if (keywordMostFailedGraph) {
                keywordMostFailedGraph.destroy();
            }
            const data = get_most_failed_data("keyword", keywordMostFailedGraphType, filteredKeywords, false);
            const graphData = data[0]
            const callbackData = data[1];
            var config;
            const limit = inFullscreen ? 50 : 10;
            if (keywordMostFailedGraphType == "bar") {
                config = get_graph_config("bar", graphData, `Top ${limit} Most Failed Keywords`, "Keyword", "Fails");
                config.options.plugins.legend = { display: false };
                config.options.plugins.tooltip = {
                    callbacks: {
                        label: function (tooltipItem) {
                            return callbackData[tooltipItem.label];
                        },
                    },
                };
                delete config.options.onClick
            } else if (keywordMostFailedGraphType == "timeline") {
                config = get_graph_config("timeline", graphData, `Top ${limit} Most Failed Keywords`, "Run", "Keyword");
                config.options.plugins.tooltip = {
                    callbacks: {
                        label: function (context) {
                            return callbackData[context.raw.x[0]];
                        },
                    },
                };
                config.options.scales.x = {
                    ticks: {
                        minRotation: 45,
                        maxRotation: 45,
                        stepSize: 1,
                        callback: function (value, index, ticks) {
                            return callbackData[this.getLabelForValue(value)];
                        },
                    },
                    title: {
                        display: true,
                        text: "Run",
                    },
                };
                config.options.onClick = (event, chartElement) => {
                    if (chartElement.length) {
                        open_log_file(event, chartElement, callbackData)
                    }
                };
                if (!showDateLabels) { config.options.scales.x.ticks.display = false }
            }
            update_height("keywordMostFailedVertical", config.data.labels.length, config.options.plugins.title.text, keywordMostFailedGraphType);
            keywordMostFailedGraph = new Chart("keywordMostFailedGraph", config);
            keywordMostFailedGraph.canvas.addEventListener("click", (event) => {
                open_log_from_label(keywordMostFailedGraph, event)
            });
        }

        // function to create keyword table in the keyword section
        function create_keyword_table() {
            if (keywordTable) {
                keywordTable.destroy();
            }
            data = [];
            for (keyword of filteredKeywords) {
                data.push([
                    keyword.run_start,
                    keyword.name,
                    keyword.passed,
                    keyword.failed,
                    keyword.skipped,
                    keyword.times_run,
                    keyword.total_time_s,
                    keyword.average_time_s,
                    keyword.min_time_s,
                    keyword.max_time_s,
                    keyword.run_alias,
                ]);
            }
            keywordTable = new DataTable("#keywordTable", {
                layout: {
                    topStart: "info",
                    bottomStart: null,
                },
                columns: [
                    { title: "run" },
                    { title: "name" },
                    { title: "passed" },
                    { title: "failed" },
                    { title: "skipped" },
                    { title: "times_run" },
                    { title: "total_execution_time" },
                    { title: "average_execution_time" },
                    { title: "min_execution_time" },
                    { title: "max_execution_time" },
                    { title: "alias" },
                ],
                data: data,
            });
        }

        // function to create the compare statistics in the compare section
        function create_compare_statistics_graph() {
            if (compareStatisticsGraph) {
                compareStatisticsGraph.destroy();
            }
            const graphData = get_compare_statistics_graph_data(filteredRuns);
            const config = get_graph_config("bar", graphData, `Run Statistics`, "Run", "Amount");
            config.options.scales.y.stacked = false;
            compareStatisticsGraph = new Chart("compareStatisticsGraph", config);
            compareStatisticsGraph.canvas.addEventListener("click", (event) => {
                open_log_from_label(compareStatisticsGraph, event)
            });
        }

        // function to create the compare statistics in the compare section
        function create_compare_tests_graph() {
            if (compareTestsGraph) {
                compareTestsGraph.destroy();
            }
            const data = get_test_statistics_data(filteredTests);
            const graphData = data[0]
            const runStarts = data[1]
            var config = get_graph_config("timeline", graphData, "Test Statistics", "Run", "Test");
            config.options.plugins.tooltip = {
                callbacks: {
                    label: function (context) {
                        return runStarts[context.raw.x[0]];
                    },
                },
            };
            config.options.scales.x = {
                ticks: {
                    minRotation: 45,
                    maxRotation: 45,
                    stepSize: 1,
                    callback: function (value, index, ticks) {
                        return runStarts[this.getLabelForValue(value)];
                    },
                },
                title: {
                    display: true,
                    text: "Run",
                },
            };
            config.options.onClick = (event, chartElement) => {
                if (chartElement.length) {
                    open_log_file(event, chartElement, runStarts)
                }
            };
            if (!showDateLabels) { config.options.scales.x.ticks.display = false }
            update_height("compareTestsVertical", config.data.labels.length, config.options.plugins.title.text, "timeline");
            compareTestsGraph = new Chart("compareTestsGraph", config);
            compareTestsGraph.canvas.addEventListener("click", (event) => {
                open_log_from_label(compareTestsGraph, event)
            });
        }

         // function to create the compare statistics in the compare section
        function create_compare_suite_duration_graph() {
            if (compareSuiteDurationGraph) {
                compareSuiteDurationGraph.destroy();
            }
            const graphData = get_compare_suite_duration_data(filteredSuites);
            const config = get_graph_config("radar", graphData, "Suite Duration");
            delete config.options.onClick;
            compareSuiteDurationGraph = new Chart("compareSuiteDurationGraph", config);
        }

        ///////////////////////////////////
        // GRAPH DATA & CONFIG FUNCTIONS //
        ///////////////////////////////////

        // function to open the log when clicking on the labels
        function open_log_from_label(chart, click) {
            if (!use_logs) { return }
            let resetCoordinates = chart.canvas.getBoundingClientRect();
            const xCoor = click.clientX - resetCoordinates.left;
            const yCoor = click.clientY - resetCoordinates.top;
            const { data, scales: { x: { top, bottom, left, height, width, ticks } } } = chart;
            const right = width / ticks.length;

            for (let i = 0; i < ticks.length; i++) {
                if (xCoor >= left + (right * i) && xCoor <= left + right + (right * i) && yCoor >= top && yCoor <= bottom) {
                    var run
                    const identifier = chart.config._config.options.indexAxis === "y" ? Object.values(ticks).map(item => item.label) : data.labels // exception for timelines
                    if (showAliases) {
                        run = runs.find(run => run.run_alias === identifier[i])
                    } else {
                        run = runs.find(run => run.run_start === identifier[i])
                    }
                    if (run) {
                        const path = transform_file_path(run.path)
                        if (path == "") {
                            alert("Log file error: this output didn't have a path in the database so the log file cannot be found!");
                            return
                        }
                        var fileUrl = ""
                        if (server) { // server url
                            fileUrl = `/log?path=${path}`
                        } else if (window.location.href.includes("file:///")) { // local machine url
                            fileUrl = `file:///${path}`
                        } else { // remote machine file server
                            fileUrl = combine_paths(window.location.href, path)
                        }
                        const win = window.open(fileUrl, "_blank")
                    }
                }
            }
        }

        // function to add the suite or test id to the log path url
        function update_log_path_with_id(path, graphId, chartElement, event) {
            if (graphId.includes("run") || graphId.includes("keyword")) {
                return transform_file_path(path)
            } // can"t select a run or keyword in the suite/log log.html
            const graphType = event.chart.config._config.type
            var name = ""
            var id = ""
            var runStart = runs.find(run => run.path === path).run_start
            if (graphId.includes("suite")) {
                if (graphId == "suiteStatisticsGraph") {
                    name = event.chart.tooltip.title[0].split(": ").pop()
                } else if (graphId == "suiteDurationGraph") {
                    name = event.chart.tooltip.body[0].lines[0].split(": ")[0]
                } else if (graphId == "suiteMostFailedGraph") {
                    name = chartElement[0].element.$context.raw.y
                }
                id = suites.find(suite => suite.name === name && suite.run_start === runStart)
            } else { // it contains a test
                if (graphId == "testStatisticsGraph" || graphId == "testMostFlakyGraph" || graphId == "testRecentMostFlakyGraph" || graphId == "testMostFailedGraph" || graphId == "testRecentMostFailedGraph") {
                    name = chartElement[0].element.$context.raw.y
                } else if (graphId == "testDurationGraph") {
                    if (graphType == "bar") {
                        name = event.chart.tooltip.dataPoints[0].dataset.label
                    } else {
                        const datasetIndex = chartElement[0].datasetIndex
                        name = event.chart.legend.legendItems[datasetIndex].text
                    }
                } else { // this exception is for the Test Messages graph as you can"t tell which test it relates to (might be more than 1!)
                    return transform_file_path(path)
                }
                id = tests.find(test => test.name === name && test.run_start === runStart)
            }
            if (id == undefined) {
                return transform_file_path(path)
            }
            return `${transform_file_path(path)}#${id.id}`
        }

        // function to open the log files through the graphs
        function open_log_file(event, chartElement, callbackData = undefined) {
            if (!use_logs) { return }
            const graphType = event.chart.config._config.type
            const graphId = event.chart.canvas.id
            var runStart = ""
            if (graphType == "doughnut") {
                runStart = callbackData
            } else if (callbackData) {
                const index = chartElement[0].element.$context.raw.x[0]
                runStart = callbackData[index]
            } else if (graphType == "line" && !graphId.includes("Statistics")) {
                runStart = format_date_to_string(new Date(chartElement[0].element.$context.raw.x))
            } else {
                const index = chartElement[0].index
                runStart = event.chart.data.labels[index]
            }
            var output = runs.find(run => run.run_start.slice(0, 19) === runStart.slice(0, 19))
            var path = output ? output.path : runs.find(run => run.run_alias === runStart).path
            if (path == "") {
                alert("Log file error: this output didn't have a path in the database so the log file cannot be found!");
                return
            }
            path = update_log_path_with_id(path, graphId, chartElement, event)
            var fileUrl = ""
            if (server) { // server url
                fileUrl = `/log?path=${path}`
            } else if (window.location.href.includes("file:///")) { // local machine url
                fileUrl = `file:///${path}`
            } else { // remote machine file server
                fileUrl = combine_paths(window.location.href, path)
            }
            const win = window.open(fileUrl, "_blank")
        }

        // function to retrieve the required graph config for chartjs, based on the different type of graphs
        // Generate a Chart.js config object based on the graph type and data
        function get_graph_config(graphType, graphData, graphTitle, xTitle, yTitle, dataSets = true) {
            if (dataSets && graphType === "line") {
                graphData = { datasets: graphData };
            }

            const baseConfig = {
                onClick: (event, chartElement) => {
                    if (chartElement.length) open_log_file(event, chartElement);
                },
                normalized: true,
                responsive: true,
                maintainAspectRatio: false,
                animation: animationEnabled
                    ? {
                        delay: (ctx) => {
                            const dataLength = ctx.chart.data.datasets.reduce(
                                (a, b) => (b.data.length > a.data.length ? b : a)
                            ).data.length;
                            return ctx.dataIndex * (animationDuration / dataLength);
                        },
                    }
                    : false,
                plugins: {
                    title: {
                        display: true,
                        text: graphTitle,
                    },
                    datalabels: {
                        display: false,
                    },
                },
            };

            const commonScales = {
                x: {
                    title: { display: true, text: xTitle },
                    ticks: {
                        minRotation: 45,
                        maxRotation: 45,
                        callback(value) {
                            return this.getLabelForValue(value).slice(0, 40);
                        },
                    },
                },
                y: {
                    title: { display: true, text: yTitle },
                    beginAtZero: true,
                    grace: "5%",
                    ticks: {
                        callback(value) {
                            return this.getLabelForValue(value).slice(0, 40);
                        },
                    },
                },
            };

            const configMap = {
                line: () => ({
                    type: "line",
                    data: graphData,
                    options: {
                        ...baseConfig,
                        scales: {
                            ...commonScales,
                            x: {
                                ...commonScales.x,
                                type: "time",
                                time: { tooltipFormat: "dd.MM.yyyy HH:mm:ss" },
                                ticks: {
                                    ...commonScales.x.ticks,
                                    maxTicksLimit: 10,
                                },
                            },
                        },
                    },
                }),
                bar: () => ({
                    type: "bar",
                    data: graphData,
                    options: {
                        ...baseConfig,
                        scales: {
                            ...commonScales,
                            y: { ...commonScales.y, stacked: true },
                        },
                        interaction: { mode: "x" },
                        plugins: {
                            ...baseConfig.plugins,
                            tooltip: {
                                filter: (item) => item.dataset.data[item.dataIndex] > 0,
                            },
                            datalabels: {
                                color: "#000",
                                align: "center",
                                anchor: "center",
                                formatter: (val) => (val > 0 ? val : null),
                            },
                        },
                    },
                }),
                timeline: () => ({
                    type: "bar",
                    data: graphData,
                    options: {
                        ...baseConfig,
                        indexAxis: "y",
                        scales: {
                            ...commonScales,
                            y: { ...commonScales.y, stacked: true },
                        },
                        plugins: {
                            ...baseConfig.plugins,
                            legend: { display: false },
                        },
                    },
                }),
                boxplot: () => ({
                    type: "boxplot",
                    data: graphData,
                    options: {
                        ...baseConfig,
                        scales: {
                            ...commonScales,
                            x: {
                                ...commonScales.x,
                                ticks: commonScales.x.ticks,
                            },
                        },
                        plugins: {
                            ...baseConfig.plugins,
                            tooltip: { enabled: true },
                            legend: { display: false },
                        },
                    },
                }),
                donut: () => ({
                    type: "doughnut",
                    data: graphData,
                    options: {
                        ...baseConfig,
                        animation: animationEnabled ? { duration: animationDuration } : false,
                        radius: "90%",
                        plugins: {
                            ...baseConfig.plugins,
                            tooltip: {
                                callbacks: {
                                    title: function (tooltipItem) {
                                        const label = tooltipItem[0].label;
                                        const value = tooltipItem[0].formattedValue;
                                        const datalabelModel = tooltipItem[0].element?.$datalabels?.[0]?._model;
                                        return datalabelModel?.lines?.[0] || `${label}: ${value}`;
                                    },
                                },
                            },
                            legend: {
                                display: true,
                                labels: {
                                    generateLabels(chart) {
                                        const dataset = chart.data.datasets[0];
                                        const meta = chart.getDatasetMeta(0);
                                        const labels = chart.data.labels;

                                        return labels.map((label, i) => {
                                            const style = meta.controller.getStyle(i);
                                            const hidden = !chart.isDatasetVisible(0) || meta.data[i].hidden;

                                            return {
                                                text: label.split(".").pop(),
                                                fillStyle: style.backgroundColor,
                                                strokeStyle: style.borderColor,
                                                lineWidth: style.borderWidth,
                                                lineCap: style.borderCapStyle || "butt",
                                                lineDash: style.borderDash || [],
                                                lineDashOffset: style.borderDashOffset || 0,
                                                pointStyle: style.pointStyle || "circle",
                                                rotation: style.rotation || 0,
                                                hidden,
                                                index: i,
                                                datasetIndex: 0,
                                                fontColor: Chart.defaults.color,
                                            };
                                        });
                                    },
                                },
                            },
                            datalabels: {
                                ...dataLabelConfig,
                                align: "center",
                                anchor: "center",
                                formatter(value, context) {
                                    if (value === 0) return null;
                                    const total = graphData.datasets[0].data.reduce((a, b) => a + b, 0);
                                    const percentage = Math.round((value / total) * 100);
                                    if (percentage <= 5) return null;
                                    const label = graphData.labels[context.dataIndex].split(".").pop();
                                    return `${label}: ${value} (${percentage}%)`;
                                },
                            },
                        },
                    },
                }),
                heatmap: () => ({
                    type: "matrix",
                    data: graphData,
                    options: {
                        ...baseConfig,
                        scales: {
                            x: {
                                type: "linear",
                                position: "bottom",
                                min: 0,
                                max: heatMapHourAll ? 24 : 60,
                                offset: false,
                                grid: { display: true, drawTicks: true, tickLength: 8 },
                                ticks: {
                                    minRotation: 45,
                                    maxRotation: 45,
                                    stepSize: 1,
                                    callback: (val) => {
                                        if (heatMapHourAll) return `${val}:00`;
                                        const hour = document.getElementById("heatMapHour").value;
                                        return `${("0" + hour).slice(-2)}:${("0" + val).slice(-2)}`;
                                    },
                                },
                                title: {
                                    display: true,
                                    text: heatMapHourAll ? "Hour" : "Minute",
                                },
                            },
                            y: {
                                type: "linear",
                                reverse: true,
                                min: 0,
                                max: 7,
                                offset: false,
                                grid: { display: true, drawTicks: true, tickLength: 8 },
                                title: { display: true, text: "Day" },
                            },
                        },
                        plugins: {
                            ...baseConfig.plugins,
                            legend: { display: false },
                        },
                    },
                }),
                radar: () => ({
                    type: "radar",
                    data: graphData,
                    options: {
                        ...baseConfig,
                        elements: {
                            line: {
                                borderWidth: 3
                            },
                        },
                        plugins: {
                            ...baseConfig.plugins,
                            tooltip: { enabled: true },
                            legend: { display: true },
                        },
                        scales: {
                            r: {
                                angleLines: {
                                    display: true
                                },
                                grid: {
                                    display: true
                                },
                                pointLabels: {
                                    display: true
                                },
                                ticks: {
                                    display: false
                                }
                            }
                        }
                    },
                }),
            };

            const config = configMap[graphType]?.();
            // Global legend toggle
            if (!showLegends) {
                config.options.plugins.legend = config.options.plugins.legend || {};
                config.options.plugins.legend.display = false;
            }
            return config;
        }

        // helper function to more easily use the logic of filtering suite graph data based on the selected filters
        // returns true if the value should be excluded, false if it should be included
        function exclude_from_suite_data(dataType, value) {
            if (dataType !== "suite") return false;
            const suiteSelectSuites = document.getElementById("suiteSelectSuites").value;
            const suiteSelectSuitesOptions = [...document.getElementById("suiteSelectSuites").options].map(o => o.value);
            const suiteFolder = document.getElementById("suiteFolder").innerText;
            const isFolderAll = suiteFolder === "All";
            const isSuiteAll = suiteSelectSuites === "All";
            const usingSuitePaths = useSuitePathsSuiteSection;

            const folderMatches = (val) => val.full_name === suiteFolder || val.full_name.startsWith(`${suiteFolder}.`);
            const suiteNameMatches = (val) => suiteSelectSuitesOptions.includes(val.name);
            const fullNameMatches = (val) => suiteSelectSuitesOptions.includes(val.full_name);

            if (isFolderAll && isSuiteAll) {
                // All folders, all suites: include all
                return false;
            }
            if (isFolderAll && !isSuiteAll) {
                // All folders, specific suite
                return usingSuitePaths
                    ? value.full_name !== suiteSelectSuites
                    : value.name !== suiteSelectSuites;
            }
            if (!isFolderAll && isSuiteAll) {
                // Specific folder, all suites
                if (!folderMatches(value)) return true;

                return usingSuitePaths
                    ? !fullNameMatches(value)
                    : !suiteNameMatches(value);
            }
            // Specific folder, specific suite
            if (!folderMatches(value)) return true;
            return usingSuitePaths
                ? value.full_name !== suiteSelectSuites
                : value.name !== suiteSelectSuites;
        }

        // function to prepare the data in the correct format for statistics graphs
        function get_statistics_graph_data(dataType, graphType, filteredData) {
            const keywordSelect = document.getElementById("keywordSelect").value;
            const passed = [], failed = [], skipped = [], labels = [], aliases = [], names = [];
            const calculate_percentage = (value, total) => Math.round((value / total) * 100);
            const process_value = (value) => {
                const total = value.passed + value.failed + value.skipped;
                const passedPercentage = calculate_percentage(value.passed, total);
                const failedPercentage = calculate_percentage(value.failed, total);
                const skippedPercentage = calculate_percentage(value.skipped, total);
                passed.push(passedPercentage);
                failed.push(failedPercentage);
                skipped.push(skippedPercentage);
                labels.push(value.run_start);
                aliases.push(value.run_alias);
                names.push(value.name)
            };
            for (const value of filteredData) {
                if (exclude_from_suite_data(dataType, value)) { continue }
                if (dataType === "keyword" && value.name !== keywordSelect) continue;
                // Process percentage-based data
                if (graphType === "percentages") {
                    if (dataType === "keyword") {
                        if (value.name === keywordSelect) {
                            process_value(value);
                        }
                    } else {
                        process_value(value);
                    }
                } else {
                    passed.push(value.passed);
                    failed.push(value.failed);
                    skipped.push(value.skipped);
                    labels.push(value.run_start);
                    aliases.push(value.run_alias);
                    names.push(value.name)
                }
            }
            const finalLabels = graphType !== "line" ? (showAliases ? aliases : labels) : labels;
            const styling = graphType !== "line" ? barConfig : lineConfig;
            const create_data_set = (label, data, backgroundColor, borderColor) => ({
                label,
                data,
                backgroundColor,
                borderColor,
                ...styling,
                stack: graphType === "percentages" || "amount" ? "Stack 0" : undefined,
            });
            const statisticsData = {
                labels: finalLabels,
                datasets: [
                    create_data_set("Failed", failed, failedBackgroundColor, failedBackgroundBorderColor),
                    create_data_set("Skipped", skipped, skippedBackgroundColor, skippedBackgroundBorderColor),
                    create_data_set("Passed", passed, passedBackgroundColor, passedBackgroundBorderColor),
                ],
            };
            return [statisticsData, names];
        }

        function get_test_statistics_data(filteredTests) {
            const suiteSelectTests = document.getElementById("suiteSelectTests").value;
            const testSelect = document.getElementById("testSelect").value;
            const testTagsSelect = document.getElementById("testTagsSelect").value;
            const testOnlyChanges = document.getElementById("testOnlyChanges").checked;
            const compareOnlyChanges = document.getElementById("compareOnlyChanges").checked;
            const selectedRuns = [...new Set(
                compareRunIds
                    .map(id => document.getElementById(id).value)
                    .filter(val => val !== "None")
            )];
            var [labels, runStarts, datasets] = [[], [], []];
            for (test of filteredTests) {
                if (!menuCompare) {
                    if (useSuitePathsTestSection) {
                        if (suiteSelectTests != "All" && test.full_name != `${suiteSelectTests}.${test.name}`) {
                            continue;
                        }
                    } else {
                        if (suiteSelectTests != "All" && !test.full_name.includes(`.${suiteSelectTests}.${test.name}`) && test.full_name != `${suiteSelectTests}.${test.name}`) {
                            continue;
                        }
                    }
                    if (testSelect != "All" && test.name != testSelect) {
                        continue;
                    }
                    if (testTagsSelect != "All" && !test.tags.replace(/\[|\]/g, "").split(",").includes(testTagsSelect)) {
                        continue
                    }
                } else {
                    if (!(selectedRuns.includes(test.run_start) || selectedRuns.includes(test.run_alias))) continue;
                }
                if (!labels.includes(test.name)) {
                    labels.push(test.name);
                }
                if (showAliases) {
                    if (!runStarts.includes(test.run_alias)) {
                        runStarts.push(test.run_alias);
                    }
                    var runAxis = runStarts.indexOf(test.run_alias)
                } else {
                    if (!runStarts.includes(test.run_start)) {
                        runStarts.push(test.run_start);
                    }
                    var runAxis = runStarts.indexOf(test.run_start)
                }
                if (test.passed == 1) {
                    datasets.push({
                        label: test.name,
                        data: [{ x: [runAxis, runAxis + 1], y: test.name }],
                        ...passedConfig,
                    });
                } else if (test.failed == 1) {
                    datasets.push({
                        label: test.name,
                        data: [{ x: [runAxis, runAxis + 1], y: test.name }],
                        ...failedConfig,
                    });
                } else if (test.skipped == 1) {
                    datasets.push({
                        label: test.name,
                        data: [{ x: [runAxis, runAxis + 1], y: test.name }],
                        ...skippedConfig,
                    });
                }
            }
            datasets = convert_timeline_data(datasets)
            if (testOnlyChanges || compareOnlyChanges) {
                const unique = {}
                for (const dataset of datasets) {
                    if (unique[dataset.label]) {
                        unique[dataset.label] = unique[dataset.label] + 1
                    } else {
                        unique[dataset.label] = 1
                    }
                }
                const labelsToRemove = []
                for (const label of Object.keys(unique)) {
                    if (unique[label] == 1) {
                        labelsToRemove.push(label)
                    }
                }
                datasets = datasets.filter(dataset => !labelsToRemove.includes(dataset.label))
                labels = labels.filter(label => !labelsToRemove.includes(label))
            }
            const graphData = {
                labels: labels,
                datasets: datasets,
            };
            return [graphData, runStarts]
        }

        // function to prepare the data in the correct format for last run donut graphs
        function get_donut_graph_data(dataType, filteredData) {
            const latest = filteredData[Object.keys(filteredData)[Object.keys(filteredData).length - 1]]
            var labels = [];
            var datasets = [];
            var backgroundColors = [];
            var backgroundBorderColors = [];
            if (latest) {
                if (latest.passed > 0) {
                    labels.push("Passed")
                    datasets.push(latest.passed)
                    backgroundColors.push(passedBackgroundColor)
                    backgroundBorderColors.push(passedBackgroundBorderColor)
                }
                if (latest.failed > 0) {
                    labels.push("Failed")
                    datasets.push(latest.failed)
                    backgroundColors.push(failedBackgroundColor)
                    backgroundBorderColors.push(failedBackgroundBorderColor)
                }
                if (latest.skipped > 0) {
                    labels.push("Skipped")
                    datasets.push(latest.skipped)
                    backgroundColors.push(skippedBackgroundColor)
                    backgroundBorderColors.push(skippedBackgroundBorderColor)
                }
            }
            const graphData = {
                labels: labels,
                datasets: [{
                    data: datasets,
                    backgroundColor: backgroundColors,
                    borderColor: backgroundBorderColors,
                    hoverOffset: 4
                }]
            };
            const callBackData = latest ? showAliases ? latest.run_alias : latest.run_start : ""
            return [graphData, callBackData]
        }

        // function to prepare the data in the correct format for duration graphs
        function get_donut_total_graph_data(dataType, filteredData) {
            let passed = 0, failed = 0, skipped = 0;
            const labels = [], backgroundColors = [], backgroundBorderColors = [];
            for (const value of filteredData) {
                if (value.passed > 0) {
                    if (!labels.includes("Passed")) { labels.push("Passed") };
                    if (!backgroundColors.includes(passedBackgroundColor)) { backgroundColors.push(passedBackgroundColor) };
                    if (!backgroundBorderColors.includes(passedBackgroundBorderColor)) { backgroundBorderColors.push(passedBackgroundBorderColor) };
                    passed = passed + value.passed;
                }
                if (value.failed > 0) {
                    if (!labels.includes("Failed")) { labels.push("Failed") };
                    if (!backgroundColors.includes(failedBackgroundColor)) { backgroundColors.push(failedBackgroundColor) };
                    if (!backgroundBorderColors.includes(failedBackgroundBorderColor)) { backgroundBorderColors.push(failedBackgroundBorderColor) };
                    failed = failed + value.failed;
                }
                if (value.skipped > 0) {
                    if (!labels.includes("Skipped")) { labels.push("Skipped") };
                    if (!backgroundColors.includes(skippedBackgroundColor)) { backgroundColors.push(skippedBackgroundColor) };
                    if (!backgroundBorderColors.includes(skippedBackgroundBorderColor)) { backgroundBorderColors.push(skippedBackgroundBorderColor) };
                    skipped = skipped + value.skipped;
                }
            }
            const graphData = {
                labels: labels,
                datasets: [{
                    data: [passed, failed, skipped],
                    backgroundColor: backgroundColors,
                    borderColor: backgroundBorderColors,
                    hoverOffset: 4
                }]
            };
            const callBackData = labels
            return [graphData, callBackData]
        }

        // function to prepare the data in the correct format for the last failed folders donut
        function get_donut_folder_fail_graph_data(dataType, filteredData) {
            var lastRunStart = filteredData[Object.keys(filteredData)[Object.keys(filteredData).length - 1]]
            if (lastRunStart) {
                lastRunStart = lastRunStart.run_start
            }
            const suiteFolder = document.getElementById("suiteFolder").innerText;
            var labels = new Set()
            const callbackData = {}
            const data = []
            for (const value of filteredData) {
                if (value.run_start != lastRunStart) { continue }
                if (value.failed == 0) { continue }
                if (suiteFolder == "All") {
                    const label = value.full_name.split(".")[0]
                    labels.add(label)
                    if (!callbackData[label]) {
                        callbackData[label] = {
                            total: value.total,
                            passed: value.passed,
                            skipped: value.skipped,
                            failed: value.failed
                        };
                    } else {
                        callbackData[label].total += value.total;
                        callbackData[label].passed += value.passed;
                        callbackData[label].skipped += value.skipped;
                        callbackData[label].failed += value.failed;
                    }
                } else {
                    if (!value.full_name.startsWith(suiteFolder + ".") && value.full_name != suiteFolder) { continue }
                    const label = get_next_folder_level(suiteFolder, value.full_name)
                    labels.add(label)
                    if (!callbackData[label]) {
                        callbackData[label] = {
                            total: value.total,
                            passed: value.passed,
                            skipped: value.skipped,
                            failed: value.failed
                        };
                    } else {
                        callbackData[label].total += value.total;
                        callbackData[label].passed += value.passed;
                        callbackData[label].skipped += value.skipped;
                        callbackData[label].failed += value.failed;
                    }
                }
            }
            labels = [...labels]
            for (const label of labels) {
                data.push(callbackData[label].failed)
            }
            const redShades = [
                "#ce3e01", // base fail color
                "#b13601", // darker burnt orange
                "#992f01", // deep red-orange
                "#7f2600"  // very dark, almost brown-red
            ];
            function assignColors(intoCount) {
                const result = [];
                const colorCount = redShades.length;
                let index = 0;
                for (let i = 0; i < intoCount; i++) {
                    result.push(redShades[index]);
                    index = (index + 1) % colorCount;
                    if (i > 0 && result[i] === result[i - 1]) { // Ensure no same color next to each other
                        index = (index + 1) % colorCount;
                        result[i] = redShades[index];
                    }
                }
                return result;
            }
            const backgroundColor = assignColors(labels.length);
            const graphData = {
                labels: labels,
                datasets: [{
                    data: data,
                    backgroundColor: backgroundColor,
                    hoverOffset: 4
                }]
            };
            return [graphData, callbackData];
        }

        // function to prepare the data in the correct format for folder donuts
        function get_donut_folder_graph_data(dataType, filteredData, folder) {
            var labels = new Set()
            const callbackData = {}
            const data = []
            for (const value of filteredData) {
                if (!folder) {
                    const label = value.full_name.split(".")[0]
                    labels.add(label)
                    if (!callbackData[label]) {
                        callbackData[label] = {
                            total: value.total,
                            passed: value.passed,
                            skipped: value.skipped,
                            failed: value.failed
                        };
                    } else {
                        callbackData[label].total += value.total;
                        callbackData[label].passed += value.passed;
                        callbackData[label].skipped += value.skipped;
                        callbackData[label].failed += value.failed;
                    }
                } else {
                    if (!value.full_name.startsWith(folder + ".") && value.full_name != folder) { continue }
                    const label = get_next_folder_level(folder, value.full_name)
                    labels.add(label)
                    if (!callbackData[label]) {
                        callbackData[label] = {
                            total: value.total,
                            passed: value.passed,
                            skipped: value.skipped,
                            failed: value.failed
                        };
                    } else {
                        callbackData[label].total += value.total;
                        callbackData[label].passed += value.passed;
                        callbackData[label].skipped += value.skipped;
                        callbackData[label].failed += value.failed;
                    }
                }
            }
            previousFolder = folder ? folder : "";
            labels = [...labels]
            finalLabels = []
            for (const label of labels) {
                if (onlyFailedFolders) {
                    if (callbackData[label].failed > 0) {
                        finalLabels.push(label)
                        data.push(callbackData[label].failed)
                    }
                } else {
                    finalLabels.push(label)
                    data.push(callbackData[label].total)
                }
            }
            var graphData
            if (onlyFailedFolders) {
                const redShades = [
                    "#ce3e01", // base fail color
                    "#b13601", // darker burnt orange
                    "#992f01", // deep red-orange
                    "#7f2600"  // very dark, almost brown-red
                ];
                function assignColors(intoCount) {
                    const result = [];
                    const colorCount = redShades.length;
                    let index = 0;
                    for (let i = 0; i < intoCount; i++) {
                        result.push(redShades[index]);
                        index = (index + 1) % colorCount;
                        if (i > 0 && result[i] === result[i - 1]) { // Ensure no same color next to each other
                            index = (index + 1) % colorCount;
                            result[i] = redShades[index];
                        }
                    }
                    return result;
                }
                const backgroundColor = assignColors(finalLabels.length);
                graphData = {
                    labels: finalLabels,
                    datasets: [{
                        data: data,
                        backgroundColor: backgroundColor,
                        hoverOffset: 4
                    }]
                };
            } else {
                graphData = {
                    labels: finalLabels,
                    datasets: [{
                        data: data,
                        hoverOffset: 4
                    }]
                };
            }
            return [graphData, callbackData]
        }

        function get_heatmap_graph_data(filteredData) {
            const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
            const type = document.getElementById("heatMapTestType").value; // All, Passed, Failed, Skipped
            const hour = document.getElementById("heatMapHour").value;
            const counts = new Map();
            for (const value of filteredData) {
                if (type !== "All") {
                    const key = type.toLowerCase(); // 'passed', 'failed', 'skipped'
                    if (value[key] != 1) continue;
                }
                const date = new Date(value.start_time);
                if (hour === "All") {
                    const x = date.getHours() + 0.5;
                    const y = date.getDay() + 0.5;
                    const key = `${x},${y}`;
                    counts.set(key, (counts.get(key) || 0) + 1);
                } else {
                    if (date.getHours() != parseInt(hour)) continue;
                    const x = date.getMinutes() + 0.5;
                    const y = date.getDay() + 0.5;
                    const key = `${x},${y}`;
                    counts.set(key, (counts.get(key) || 0) + 1);
                }

            }
            const data = Array.from(counts.entries()).map(([key, count]) => {
                const [x, y] = key.split(',').map(Number);
                return { x, y, v: count };
            });
            const baseColors = {
                All: [0, 123, 255], // Blue
                Passed: [151, 189, 97], // Green
                Skipped: [254, 216, 79], // Yellow
                Failed: [206, 62, 1], // Red
            };
            const colorRGB = baseColors[type] || baseColors['All'];
            if (data.length == 0) { return [[], []] }
            const graphData = {
                datasets: [{
                    label: 'Test Execution Heatmap',
                    data: data,
                    backgroundColor(ctx) {
                        const v = ctx.dataset.data[ctx.dataIndex].v;
                        const maxV = Math.max(...ctx.dataset.data.map(d => d.v));
                        let alpha = v / maxV;
                        alpha = Math.max(alpha, 0.2);
                        return `rgba(${colorRGB[0]}, ${colorRGB[1]}, ${colorRGB[2]}, ${alpha})`;
                    },
                    width: ({ chart }) => (chart.chartArea?.width || 0) / (heatMapHourAll ? 24 : 60) - 1,
                    height: ({ chart }) => (chart.chartArea?.height || 0) / 7 - 1,
                    ...barConfig,
                }]
            };
            return [graphData, days];
        }

        // function to prepare the data in the correct format for duration graphs
        function get_duration_graph_data(dataType, graphType, objectDataAttribute, filteredData) {
            const suiteSelectSuites = document.getElementById("suiteSelectSuites").value;
            const suiteSelectTests = document.getElementById("suiteSelectTests").value;
            const testSelect = document.getElementById("testSelect").value;
            const testTagsSelect = document.getElementById("testTagsSelect").value;
            const keywordSelect = document.getElementById("keywordSelect").value;
            const should_include = (value) => {
                if (dataType === "keyword" && value.name !== keywordSelect) return false;
                if (exclude_from_suite_data(dataType, value)) return false;
                if (useSuitePathsTestSection) {
                    if (dataType === "test" && suiteSelectTests !== "All" && value.full_name !== `${suiteSelectTests}.${value.name}`) return false;
                } else {
                    if (dataType === "test" && suiteSelectTests !== "All" && !value.full_name.includes(`.${suiteSelectTests}.${value.name}`) && value.full_name !== `${suiteSelectTests}.${value.name}`) return false;
                }
                if (dataType === "test" && testSelect !== "All" && value.name !== testSelect) return false;
                if (dataType === "test" && testTagsSelect !== "All" && !value.tags.replace(/\[|\]/g, "").split(",").includes(testTagsSelect)) return false;
                return true;
            };
            const limit = inFullscreen ? 100 : 30;
            if (graphType === "bar") {
                const labels = [];
                const data = new Map();
                const aliases = [];
                for (const value of filteredData) {
                    if (!should_include(value)) continue;
                    labels.push(value.run_start);
                    aliases.push(value.run_alias);
                    const roundedValue = Math.round(value[objectDataAttribute] * 100) / 100;
                    for (const [key, arr] of data.entries()) {
                        arr.push(key === value.name ? roundedValue : 0); // Append to each dataset
                    }
                    if (!data.has(value.name)) {
                        const arr = Array(labels.length - 1).fill(0); // Fill up to current length
                        arr.push(roundedValue);
                        data.set(value.name, arr);
                    }
                    if (labels.length > limit) break;
                }
                if (showAliases) {
                    labels.length = 0;
                    labels.push(...aliases);
                }
                const graphData = {
                    labels,
                    datasets: Array.from(data.entries()).map(([label, dataset]) => ({
                        label: label.slice(0, 40),
                        data: dataset,
                        stack: "Stack 0",
                        ...barConfig,
                    })),
                };
                return graphData;
            }
            else if (graphType === "line") {
                const labels = [];
                const sets = new Map();
                for (const value of filteredData) {
                    if (!should_include(value)) continue;
                    const name = value.name;
                    const run_start = new Date(value.run_start);
                    const roundedValue = Math.round(value[objectDataAttribute] * 100) / 100;
                    if (!sets.has(name)) {
                        labels.push(name);
                        sets.set(name, [{ x: run_start, y: roundedValue }]);
                    } else {
                        sets.get(name).push({ x: run_start, y: roundedValue });
                    }
                }
                const datasets = Array.from(sets.entries()).map(([key, values]) => ({
                    label: key.slice(0, 40),
                    fill: false,
                    data: values,
                    ...lineConfig,
                }));
                return datasets;
            }
        }

        // function to prepare the data for the run stats canvas
        function get_stats_data(filteredRuns, filteredSuites, filteredTests, filteredKeywords) {
            const data = {
                totalRuns: Object.keys(filteredRuns).length,
                totalSuites: Object.keys(filteredSuites).length,
                totalTests: Object.keys(filteredTests).length,
                totalKeywords: filteredKeywords.reduce((sum, k) => sum + parseInt(k.times_run), 0),
            };
            const testStats = {
                total: 0,
                passed: 0,
                failed: 0,
                skipped: 0,
                duration: 0,
                names: new Set(),
            };
            for (const test of filteredTests) {
                testStats.total++;
                testStats.names.add(test.name);
                if (test.passed == 1) testStats.passed++;
                if (test.failed == 1) testStats.failed++;
                if (test.skipped == 1) testStats.skipped++;
                testStats.duration += parseFloat(test.elapsed_s);
            }
            data.totalUniqueTests = testStats.names.size;
            data.totalPassed = `${testStats.passed} (${Math.round(testStats.passed / testStats.total * 100)}%)`;
            data.totalFailed = `${testStats.failed} (${Math.round(testStats.failed / testStats.total * 100)}%)`;
            data.totalSkipped = `${testStats.skipped} (${Math.round(testStats.skipped / testStats.total * 100)}%)`;
            let totalRunDuration = 0;
            const passRates = filteredRuns.map(run => {
                totalRunDuration += parseFloat(run.elapsed_s);
                return Math.round((run.passed / run.total) * 100);
            });
            data.totalRunTime = `${Math.round(totalRunDuration)} (s)`;
            data.averageRunTime = `${Math.round(totalRunDuration / data.totalRuns)} (s)`;
            data.averageTestTime = `${Math.round(testStats.duration / testStats.total * 100) / 100} (s)`;
            data.averagePassRate = `${Math.round(passRates.reduce((a, b) => a + b, 0) / passRates.length)}%`;
            return data;
        }

        // function to prepare the data in the correct format for the duration deviation graph
        function get_duration_deviation_data(dataType, graphType, filteredData) {
            const suiteSelectTests = document.getElementById("suiteSelectTests").value;
            const testSelect = document.getElementById("testSelect").value;
            const testTagsSelect = document.getElementById("testTagsSelect").value;
            const data = new Map();
            for (const value of filteredData) {
                if (dataType === "test") {
                    if (useSuitePathsTestSection) {
                        if (suiteSelectTests !== "All" && value.full_name !== `${suiteSelectTests}.${value.name}`) {
                            continue;
                        }
                    } else {
                        if (suiteSelectTests !== "All" && !value.full_name.includes(`.${suiteSelectTests}.${value.name}`) && value.full_name !== `${suiteSelectTests}.${value.name}`) {
                            continue;
                        }
                    }
                    if (testSelect !== "All" && value.name !== testSelect) {
                        continue;
                    }
                    if (testTagsSelect !== "All" && !value.tags.replace(/\[|\]/g, "").split(",").includes(testTagsSelect)) {
                        continue;
                    }
                }
                if (data.has(value.name)) {
                    data.get(value.name).push(value.elapsed_s);
                } else {
                    data.set(value.name, [value.elapsed_s]);
                }
            }
            const labels = [];
            const datasets = [];
            for (const [testName, elapsedTimes] of data.entries()) {
                labels.push(testName);
                datasets.push(elapsedTimes);
            }
            return {
                labels,
                datasets: [{
                    itemRadius: 3,
                    data: datasets
                }],
            };
        }

        // function to prepare the data in the correct format for (recent) most flaky test graph
        function get_most_flaky_data(dataType, graphType, filteredData, ignore, recent) {
            var data = {};
            for (value of filteredData) {
                if (data[value.name]) {
                    data[value.name]["run_starts"].push(value.run_start)
                    var current_status
                    if (value.passed == 1) { current_status = "passed" }
                    else if (value.failed == 1) {
                        current_status = "failed"
                        data[value.name]["failed_run_starts"].push(value.run_start)
                    }
                    else if (!ignore) {
                        if (value.skipped == 1) {
                            current_status = "skipped"
                            data[value.name]["failed_run_starts"].push(value.run_start)
                        }
                    }
                    if (current_status != data[value.name]["previous_status"]) {
                        data[value.name]["flips"] += 1
                        data[value.name]["previous_status"] = current_status
                    }
                } else {
                    var previous_status
                    data[value.name] = {
                        "run_starts": [value.run_start],
                        "flips": 0,
                        "failed_run_starts": []
                    }
                    if (value.passed == 1) { previous_status = "passed" }
                    else if (value.failed == 1) {
                        previous_status = "failed"
                        data[value.name]["failed_run_starts"].push(value.run_start)
                    }
                    else if (!ignore) {
                        if (value.skipped == 1) {
                            previous_status = "skipped"
                            data[value.name]["failed_run_starts"].push(value.run_start)
                        }
                    }
                    data[value.name]["previous_status"] = previous_status
                }
            }
            var sortedData = [];
            for (var test in data) {
                if (data[test].flips > 0) {
                    sortedData.push([test, data[test]]);
                }
            }
            sortedData.sort(function (a, b) {
                return b[1].flips - a[1].flips;
            });
            if (recent) { // do extra filtering to get most recent flaky tests at the top
                sortedData.sort(function (a, b) {
                    return new Date(b[1].failed_run_starts[b[1].failed_run_starts.length - 1]).getTime() - new Date(a[1].failed_run_starts[a[1].failed_run_starts.length - 1]).getTime()
                })
            }
            const limit = inFullscreen ? 50 : 10;
            if (graphType == "bar") {
                var [datasets, labels, count] = [[], [], 0];
                for (key in sortedData) {
                    if (count == limit) {
                        break;
                    }
                    labels.push(sortedData[key][0]);
                    datasets.push(sortedData[key][1].flips);
                    count += 1;
                }
                const graphData = {
                    labels,
                    datasets: [{
                        data: datasets,
                        ...failedConfig,
                    }],
                };
                return [graphData, data];
            } else if (graphType == "timeline") {
                var [labels, runStarts, count, run_aliases] = [[], [], 0, []];
                for (key in sortedData) {
                    if (count == limit) {
                        break;
                    }
                    labels.push(sortedData[key][0]);
                    for (runStart of sortedData[key][1].run_starts) {
                        if (!runStarts.includes(runStart)) {
                            runStarts.push(runStart);
                        }
                    }
                    count += 1;
                }
                var datasets = [];
                var runAxis = 0;
                runStarts = runStarts.sort((a, b) => new Date(a).getTime() - new Date(b).getTime())
                for (runStart of runStarts) {
                    for (label of labels) {
                        var foundValues = [];
                        for (value of filteredData) {
                            if (value.name == label && value.run_start == runStart) {
                                foundValues.push(value);
                                if (!run_aliases.includes(value.run_alias)) { run_aliases.push(value.run_alias) }
                            }
                        }
                        if (foundValues.length > 0) {
                            var value = foundValues[0];
                            if (value.passed == 1) {
                                datasets.push({
                                    label: label,
                                    data: [{ x: [runAxis, runAxis + 1], y: label }],
                                    ...passedConfig,
                                });
                            }
                            else if (value.failed == 1) {
                                datasets.push({
                                    label: label,
                                    data: [{ x: [runAxis, runAxis + 1], y: label }],
                                    ...failedConfig,
                                });
                            }
                            else if (value.skipped == 1) {
                                datasets.push({
                                    label: label,
                                    data: [{ x: [runAxis, runAxis + 1], y: label }],
                                    ...skippedConfig,
                                });
                            }
                        }
                    }
                    runAxis += 1;
                }
                if (showAliases) { runStarts = run_aliases }
                datasets = convert_timeline_data(datasets)
                var graphData = {
                    labels: labels,
                    datasets: datasets,
                };
                return [graphData, runStarts];
            }
        }

        // function to prepare the data in the correct format for most failed graphs
        function get_most_failed_data(dataType, graphType, filteredData, recent) {
            const data = new Map();
            const aliases = new Map();
            for (const value of filteredData) {
                if (value.failed > 0) {
                    if (!data.has(value.name)) {
                        data.set(value.name, []);
                        aliases.set(value.name, []);
                    }
                    data.get(value.name).push(value.run_start);
                    aliases.get(value.name).push(value.run_alias);
                }
            }
            var sortedData = [...data.entries()].sort((a, b) => b[1].length - a[1].length);
            if (recent) { // Do extra filtering to get most most failed tests at the top
                sortedData = sortedData.slice().sort((a, b) => {
                    const latestA = a[1][a[1].length - 1];
                    const latestB = b[1][b[1].length - 1];
                    if (latestA > latestB) return -1;
                    if (latestA < latestB) return 1;
                    return 0; // Preserve original order if equal (stable sort)
                });
            }
            const limit = inFullscreen ? 50 : 10;
            if (graphType === "bar") {
                const datasets = [];
                const labels = [];
                const runStartsLabels = new Map();
                let count = 0;
                for (const [name, runStarts] of sortedData) {
                    if (count == limit) break;
                    labels.push(name);
                    if (showAliases) {
                        data.set(name, aliases.get(name));
                    }
                    datasets.push(runStarts.length);
                    runStartsLabels.set(name, runStarts)
                    count++;
                }
                const graphData = {
                    labels,
                    datasets: [{
                        data: datasets,
                        ...failedConfig,
                    }],
                };
                const callbackData = showAliases
                    ? Object.fromEntries(sortedData.map(([name, runs]) => [name, aliases.get(name)]))
                    : Object.fromEntries(sortedData.map(([name, runs]) => [name, runStartsLabels.get(name)]));
                return [graphData, callbackData];
            } else if (graphType === "timeline") {
                const labels = [];
                const runStartsSet = new Set();
                const runAliasesSet = new Set();
                let count = 0;
                for (const [name, runStarts] of sortedData) {
                    if (count == limit) break;
                    labels.push(name);
                    runStarts.forEach(runStart => runStartsSet.add(runStart));
                    count++;
                }
                const runStarts = Array.from(runStartsSet).sort((a, b) => new Date(a).getTime() - new Date(b).getTime());
                var datasets = [];
                let runAxis = 0;
                for (const runStart of runStarts) {
                    for (const label of labels) {
                        const foundValues = filteredData.filter(value => value.name === label && value.run_start === runStart && value.failed > 0);
                        if (foundValues.length > 0) {
                            const value = foundValues[0];
                            datasets.push({
                                label: label,
                                data: [{ x: [runAxis, runAxis + 1], y: label }],
                                ...failedConfig,
                            });
                            foundValues.forEach(value => runAliasesSet.add(value.run_alias));
                        }
                    }
                    runAxis++;
                }
                datasets = convert_timeline_data(datasets)
                const runStartsArray = showAliases ? Array.from(runAliasesSet) : runStarts;
                const graphData = {
                    labels,
                    datasets,
                };
                return [graphData, runStartsArray];
            }
        }

        // function to prepare the data in the correct format for messages graphs
        function get_messages_data(dataType, graphType, filteredData) {
            const data = new Map();
            const aliases = new Map();
            for (const value of filteredData) {
                if (value.message && (value.failed === 1 || value.skipped === 1)) {
                    if (!data.has(value.message)) {
                        data.set(value.message, []);
                        aliases.set(value.message, []);
                    }
                    data.get(value.message).push(value.run_start);
                    aliases.get(value.message).push(value.run_alias);
                }
            }
            // If there is a message config use that to merge the data
            if (!message_config.includes("placeholder_message_config")) {
                function matches_message_config(str, rule) {
                    rule = rule.replace(/\$\{.*?\}/g, "*") // match any ${something} string
                    var escapeRegex = (str) => str.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1"); // escape the test messages to prevent regex mismatches
                    return new RegExp("^" + rule.split("*").map(escapeRegex).join(".*") + "$").test(str);
                }
                for (const config of message_config) {
                    for (const [message, runStarts] of data) {
                        if (message == config) { continue }
                        if (matches_message_config(message, config)) {
                            if (!data.has(config)) {
                                data.set(config, []);
                            }
                            data.get(config).push(...runStarts);
                            data.delete(message)
                        }
                    }
                }

                for (const [message, runStarts] of data) {
                    arrayWithDuplicates = data.get(message)
                    data.set(message, [...new Set(arrayWithDuplicates)])
                }
            }
            const limit = inFullscreen ? 50 : 10;
            const sortedData = [...data.entries()].sort((a, b) => b[1].length - a[1].length); // Sort messages by failure count
            if (graphType === "bar") {
                const [datasets, labels] = [[], []];
                let count = 0;

                for (const [message, runStarts] of sortedData) {
                    if (count == limit) break;
                    labels.push(message);
                    datasets.push(runStarts.length);
                    if (showAliases) {
                        data.set(message, aliases.get(message));
                    }
                    count++;
                }
                const graphData = {
                    labels,
                    datasets: [{
                        data: datasets,
                        ...failedConfig,
                    }],
                };
                const callbackData = Object.fromEntries(sortedData.map(([message, runs]) => [message, aliases.get(message)]));
                return [graphData, callbackData];
            } else if (graphType === "timeline") {
                const labels = [];
                const runStartsSet = new Set();
                const runAliasesSet = new Set();
                let count = 0;
                for (const [message, runStarts] of sortedData) { // Collect unique run starts and labels
                    if (count == limit) break;
                    labels.push(message);
                    runStarts.forEach(runStart => runStartsSet.add(runStart));
                    count++;
                }
                const runStarts = Array.from(runStartsSet).sort((a, b) => new Date(a).getTime() - new Date(b).getTime());
                var datasets = [];
                let runAxis = 0;
                function check_label(message, label) {
                    return !message_config.includes("placeholder_message_config")
                        ? matches_message_config(message, label)
                        : message === label;
                }
                for (const runStart of runStarts) {
                    for (const label of labels) {
                        const foundValues = filteredData.filter(value => check_label(value.message, label) && value.run_start === runStart);
                        if (foundValues.length > 0) {
                            const value = foundValues[0];
                            datasets.push({
                                label: label,
                                data: [{ x: [runAxis, runAxis + 1], y: label }],
                                ...failedConfig,
                            });
                            foundValues.forEach(value => runAliasesSet.add(value.run_alias));
                        }
                    }
                    runAxis++;
                }
                datasets = convert_timeline_data(datasets)
                const runStartsArray = showAliases ? Array.from(runAliasesSet) : runStarts;
                const graphData = {
                    labels,
                    datasets,
                };
                return [graphData, runStartsArray];
            }
        }

        // function to get the compare statistics data
        function get_compare_statistics_graph_data(filteredData) {
            const selectedRuns = [...new Set(
                compareRunIds
                    .map(id => document.getElementById(id).value)
                    .filter(val => val !== "None")
            )];
            const datasets = selectedRuns.map(runId => {
                const match = filteredData.find(d =>
                    d.run_start === runId || d.run_alias === runId
                );
                return match ? {
                    label: showAliases ? match.run_alias : match.run_start,
                    data: [match.passed, match.failed, match.skipped],
                    ...barConfig
                } : null;
            }).filter(Boolean);
            return {
                labels: ['Passed', 'Failed', 'Skipped'],
                datasets
            };
        }

        function get_compare_suite_duration_data(filteredData) {
            var labels = new Set()
            const data = {}
            const datasets = []
            const selectedRuns = [...new Set(
                compareRunIds
                    .map(id => document.getElementById(id).value)
                    .filter(val => val !== "None")
            )];
            for (const selected of selectedRuns) {
                for (const value of filteredData) {
                    if (!(selected == value.run_start || selected == value.run_alias)) continue;
                    labels.add(value.name)
                    if (data[selected]) {
                        data[selected].push(value.elapsed_s)
                    } else {
                        data[selected] = [value.elapsed_s]
                    }
                }
                datasets.push({
                    label: selected,
                    data: data[selected],
                    fill: true,  
                })
            }
            labels = [...labels]
            // const datasets = []
            // for (const label of labels) {
            //     const filtered = data.filter(value => value.name == label)
            //     const datavalues = []
            //     for (const value of filtered) {
            //         datavalues.push(value.elapsed_s)
            //     }
            //     datasets.push({
            //         label: label,
            //         data: datavalues,
            //         fill: true,
            //     })
            // }
            const graphData = {
                labels: labels,
                datasets: datasets,
            }
            return graphData
        }

        // function to update the height of the test statistics graph and enable scrolling
        function update_height(verticalId, labels, title, graphType) {
            const vertical = document.getElementById(verticalId)
            vertical.style.height = `465px`
            if (labels > 10 && graphType != "bar") {
                // timeline view with more than 10 items -> update height
                const newHeight = 465 + (labels - 10) * 35;
                const parentHeight = parseFloat(getComputedStyle(vertical.parentElement).height) - 59;
                if (inFullscreen && newHeight < parentHeight) {
                    vertical.style.height = `${parentHeight}px`
                } else {
                    vertical.style.height = `${newHeight}px`
                }
            } else if (inFullscreen && graphType != "bar") {
                // not more than 10 items, set the height to fullscreen without scrollbar
                const parentHeight = parseFloat(getComputedStyle(vertical.parentElement).height) - 51;
                vertical.style.height = `${parentHeight}px`
            } else if (inFullscreen && graphType == "bar") {
                // bar chart should have fullscreen height because you get more labels on the horizontal axis
                const parentHeight = parseFloat(getComputedStyle(vertical.parentElement).height) - 59;
                vertical.style.height = `${parentHeight}px`
            }
        }

        // function to convert timeline data to improve performance
        function convert_timeline_data(oldDatasets) {
            const grouped = {};
            for (const dataset of oldDatasets) {
                const segment = dataset.data[0]; // assumes 1 item per dataset
                const status = `${dataset.label}:*:&:.:${dataset.backgroundColor}:*:&:.:${dataset.borderColor}`;
                if (!grouped[status]) {
                    grouped[status] = [];
                }
                grouped[status].push({
                    x: segment.x,
                    y: segment.y,
                });
            }
            const data = Object.entries(grouped)
                .filter(([_, data]) => data.length > 0)
                .map(([status, data]) => ({
                    label: status.split(":*:&:.:")[0],
                    data,
                    backgroundColor: status.split(":*:&:.:")[1],
                    borderColor: status.split(":*:&:.:")[2],
                    ...barConfig,
                    parsing: true
                }));
            return data
        }

        ///////////////////////////////////
        // RENDER DATA & GRAPH FUNCTIONS //
        ///////////////////////////////////

        // function to update all graph data, function is called when updating filters and when the page loads
        function setup_data_and_graphs(menuUpdate = false) {
            lastScrollY = window.scrollY;
            setup_spinner(false);

            // Let the spinner render before starting heavy setup
            requestAnimationFrame(() => {
                setup_filtered_data_and_filters();
                setup_section_order();
                setup_graph_order();
                setup_collapsables();
                setup_information_icons();
                setup_eventlisteners_filter_buttons();
                setup_eventlisteners_graph_view_buttons();
                setup_button_highlighting();
                setup_theme();

                requestAnimationFrame(() => {
                    setup_spinner(true);
                    setup_dasbhoard_graphs();

                    if (menuDashboard) {
                        setup_section_buttons();
                    }

                    if (!menuUpdate) {
                        requestAnimationFrame(() => {
                            if (lastScrollY > 0) {
                                window.scrollTo({
                                    top: lastScrollY,
                                    behavior: "auto"
                                });
                            }
                        });
                    }
                });
            });
        }

        // function updates the data in the graphs whenever filters are updated
        function setup_filtered_data_and_filters() {
            filteredRuns = remove_milliseconds(runs)
            filteredSuites = remove_milliseconds(suites)
            filteredTests = remove_milliseconds(tests)
            filteredKeywords = remove_milliseconds(keywords)
            // filter run data
            filteredRuns = filter_runs(filteredRuns);
            filteredRuns = filter_runtags(filteredRuns);
            filteredRuns = filter_dates(filteredRuns);
            filteredRuns = filter_amount(filteredRuns);
            filteredRuns = filter_metadata(filteredRuns);
            // filter suites and tests based on filtered runs
            filteredSuites = filter_data(filteredSuites);
            filteredTests = filter_data(filteredTests);
            filteredKeywords = filter_data(filteredKeywords);
            // set titles with amount of filtered items
            const runAmount = Object.keys(filteredRuns).length
            const message = `<h6>showing ${runAmount} of ${filteredAmount} runs</h6>`
            document.getElementById("runTitle").innerHTML = `Run Statistics (${runAmount}) ${message}`;
            document.getElementById("suiteTitle").innerHTML = `Suite Statistics (${Object.keys(filteredSuites).length}) ${message}`;
            document.getElementById("testTitle").innerHTML = `Test Statistics (${Object.keys(filteredTests).length}) ${message}`;
            document.getElementById("keywordTitle").innerHTML = `Keyword Statistics (${Object.keys(filteredKeywords).length}) ${message}`;
            document.getElementById("compareTitle").innerHTML = `Compare Statistics ${message}`;
            // update filters based on data
            setup_runs_in_compare_selects();
            setup_suites_in_suite_select();
            setup_suites_in_test_select();
            setup_testtags_in_select();
            setup_tests_in_select();
            setup_keywords_in_select();
        }

        // function that updates all graphs based on the new filtered data and hidden choices
        function setup_dasbhoard_graphs() {
            if (menuOverview) {
                create_overview_statistics_graphs();
            }
            if (menuDashboard) {
                create_run_statistics_graph();
                create_run_donut_graph();
                create_run_donut_total_graph();
                create_run_stats_graph();
                create_run_duration_graph();
                create_run_heatmap_graph();
                create_run_table();
                create_suite_statistics_graph();
                create_suite_folder_donut_graph();
                create_suite_folder_fail_donut_graph();
                create_suite_duration_graph();
                create_suite_most_failed_graph();
                create_suite_table();
                create_test_statistics_graph();
                create_test_duration_graph();
                create_test_duration_deviation_graph();
                create_test_messages_graph();
                create_test_most_flaky_graph();
                create_test_recent_most_flaky_graph();
                create_test_most_failed_graph();
                create_test_recent_most_failed_graph();
                create_test_table();
                create_keyword_statistics_graph();
                create_keyword_times_run_graph();
                create_keyword_total_duration_graph();
                create_keyword_average_duration_graph();
                create_keyword_min_duration_graph();
                create_keyword_max_duration_graph();
                create_keyword_most_failed_graph();
                create_keyword_table();
            }
            if (menuCompare) {
                create_compare_statistics_graph();
                create_compare_tests_graph();
                create_compare_suite_duration_graph();
            }
        }

        // function to order the sections according to the localstorage config
        function setup_section_order() {
            const overviewStatisticsSection = document.getElementById("overviewStatisticsSection");
            const sectionShowList = JSON.parse(localStorage.getItem("sectionShow")) || [];
            const sectionHideList = JSON.parse(localStorage.getItem("sectionHide")) || [];
            const allSections = [...sectionShowList, ...sectionHideList];
            const compareStatisticsSection = document.getElementById("compareStatisticsSection");
            const sectionButtons = [
                document.getElementById("runStatisticsSectionNav"),
                document.getElementById("suiteStatisticsSectionNav"),
                document.getElementById("testStatisticsSectionNav"),
                document.getElementById("keywordStatisticsSectionNav"),
            ];
            let prevId = "#loading";
            // Show and reorder visible dashboard sections
            for (const section of sectionShowList) {
                const sectionId = space_to_camelcase(section + " Section");
                const sectionEl = document.getElementById(sectionId);
                if (sectionEl) {
                    sectionEl.hidden = false;
                    $(`#${sectionId}`).insertAfter(prevId);
                    prevId = `#${sectionId}`;
                }
            }
            // Hide all hidden dashboard sections
            for (const section of sectionHideList) {
                const sectionId = space_to_camelcase(section + " Section");
                const sectionEl = document.getElementById(sectionId);
                if (sectionEl) sectionEl.hidden = true;
            }

            // View-specific overrides
            if (menuOverview) {
                allSections.forEach(section => {
                    const sectionEl = document.getElementById(space_to_camelcase(section + " Section"));
                    if (sectionEl) sectionEl.hidden = true;
                });
                sectionButtons.forEach(btn => btn.hidden = true);
                compareStatisticsSection.hidden = true;
                overviewStatisticsSection.hidden = false;
            } else if (menuDashboard) {
                overviewStatisticsSection.hidden = true;
                compareStatisticsSection.hidden = true;
                sectionButtons.forEach(btn => btn.hidden = false);
            } else if (menuCompare) {
                allSections.forEach(section => {
                    const sectionEl = document.getElementById(space_to_camelcase(section + " Section"));
                    if (sectionEl) sectionEl.hidden = true;
                });
                sectionButtons.forEach(btn => btn.hidden = true);
                overviewStatisticsSection.hidden = true;
                compareStatisticsSection.hidden = false;
            }
        }

        // function to order the grphs according to the localstorage config
        function setup_graph_order() {
            // setup_graphs("Overview")
            setup_graphs("Run")
            setup_graphs("Suite")
            setup_graphs("Test")
            setup_graphs("Keyword")
            setup_graphs("Compare")
        }

        // function to order the graphs in the sections
        function setup_graphs(section) {
            const lowerCaseSection = section.toLowerCase()
            const sectionDataElement = document.getElementById(lowerCaseSection + "Data")
            const sectionDataHiddenElement = document.getElementById(lowerCaseSection + "DataHidden")

            // remove the entire section if it exists
            if (sectionDataElement.children.length > 0) {
                sectionDataElement.innerHTML = ""
            }
            // remove the entire section if it exists
            if (sectionDataHiddenElement.children.length > 0) {
                sectionDataHiddenElement.innerHTML = ""
            }

            const chevronRow = `<div class="row" id="${lowerCaseSection}Chevron{index}">
                                    <div class="col-auto">
                                        <div class="btn btn-sm collapse-icon" id="${lowerCaseSection}ChevronButton{index}" data-bs-toggle="collapse"
                                            data-bs-target="#${lowerCaseSection}Data{index}" aria-expanded="true" aria-controls="${lowerCaseSection}Data{index}">
                                        </div>
                                    </div>
                                    <div class="col">
                                        <h6 class="sectionTitle">{title}</h6>
                                    </div>
                                </div>`
            const dataRow = `<div class="row collapse show" id="${lowerCaseSection}Data{index}">
                                {canvas}
                            </div>`

            // helper function to create the chevron rows and data rows in the sections
            function position_graph(graph, sectionElement, hidden = false) {
                const camelCaseGraph = space_to_camelcase(graph)
                const graphDataElement = document.getElementById(camelCaseGraph + "Canvas")
                if (graphDataElement) {
                    graphDataElement.remove()
                }

                const canvas = graphMetadata.find(g => g.label === graph).html
                if (sectionElement.lastChild == null) {
                    // no row yet
                    if (graph.includes("Table")) {
                        sectionElement.innerHTML = chevronRow
                            .replaceAll("{index}", "1")
                            .replace("{title}", graph)
                            .replace("collapse-icon", "collapse-icon collapsed")
                        sectionElement.insertAdjacentHTML(
                            "beforeend",
                            dataRow
                                .replace("{index}", "1")
                                .replace("{canvas}", canvas)
                                .replace("collapse show", "collapse")
                        )
                    } else {
                        sectionElement.innerHTML = chevronRow
                            .replaceAll("{index}", "1")
                            .replace("{title}", graph)
                        sectionElement.insertAdjacentHTML(
                            "beforeend",
                            dataRow
                                .replace("{index}", "1")
                                .replace("{canvas}", canvas))
                    }
                } else {
                    const lastRow = sectionElement.lastChild
                    const index = parseInt(lastRow.id.match(/\d+/)[0], 10) + 1

                    if (graph.includes("Table")) {
                        // tables always start a new row
                        sectionElement.insertAdjacentHTML(
                            "beforeend",
                            chevronRow
                                .replaceAll("{index}", `${index}`)
                                .replace("{title}", graph)
                                .replace("collapse-icon", "collapse-icon collapsed")
                        )
                        sectionElement.insertAdjacentHTML(
                            "beforeend",
                            dataRow
                                .replace("{index}", `${index}`)
                                .replace("{canvas}", canvas)
                                .replace("collapse show", "collapse")
                        )
                    } else if (lastRow.children.length < maxGraphsPerRow) {
                        const isTableRow = [...lastRow.children].some(child => child.id && child.id.includes("Table"))
                        if (isTableRow) {
                            // current row is a table row, start new row
                            sectionElement.insertAdjacentHTML(
                                "beforeend",
                                chevronRow.replaceAll("{index}", `${index}`).replace("{title}", graph)
                            )
                            sectionElement.insertAdjacentHTML(
                                "beforeend",
                                dataRow.replace("{index}", `${index}`).replace("{canvas}", canvas)
                            )
                        } else {
                            // add to current row
                            lastRow.insertAdjacentHTML("beforeend", canvas)
                            const titleElement = sectionElement.children[sectionElement.children.length - 2].querySelector(".sectionTitle")
                            titleElement.innerText += ` & ${graph}`
                        }
                    } else {
                        // max reached so new row
                        sectionElement.insertAdjacentHTML(
                            "beforeend",
                            chevronRow.replaceAll("{index}", `${index}`).replace("{title}", graph)
                        )
                        sectionElement.insertAdjacentHTML(
                            "beforeend",
                            dataRow.replace("{index}", `${index}`).replace("{canvas}", canvas)
                        )
                    }
                }
            }

            // order the graphs correctly
            const graphShowList = JSON.parse(localStorage.getItem("graphShow"));
            for (let graph of graphShowList) {
                if (graph.startsWith(section)) {
                    position_graph(graph, sectionDataElement)
                }
            }
            // move the hidden items to temp hidden to keep the HTML available for reconfiguration
            const graphHideList = JSON.parse(localStorage.getItem("graphHide"));
            for (let graph of graphHideList) {
                if (graph.startsWith(section)) {
                    position_graph(graph, sectionDataHiddenElement, true)
                }
            }
        }

        ///////////////////////////
        // MAIN FUNCTION ON LOAD //
        ///////////////////////////

        // function that triggers all functions that should be executed when the dashboard is loaded first
        // in the correct order!
        function main() {
            setup_stats();
            setup_settings_eventlisteners();
            setup_customize_view_arrow_eventlisteners();
            setup_customize_view_local_storage();
            setup_customize_view_content();
            update_customize_view_local_storage();
            setup_eventlisteners_section_filter_buttons();
            setup_run_amount_filter();
            setup_lowest_highest_dates();
            setup_metadata_filter();
            setup_runs_in_select_filter_buttons();
            setup_runtags_in_select_filter_buttons();
            setup_menu_eventlisteners();
        }

        // trigger of first load
        main()
    </script>
</body>

</html>